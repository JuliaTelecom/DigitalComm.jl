<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Function list · DigitalComm.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../"><img class="logo" src="../assets/logo.png" alt="DigitalComm.jl logo"/></a><h1>DigitalComm.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Introduction to DigitalComm</a></li><li class="current"><a class="toctext" href>Function list</a><ul class="internal"><li><a class="toctext" href="#Common-functions-1">Common functions</a></li><li><a class="toctext" href="#Quadrature-Amplitude-Modulation-1">Quadrature Amplitude Modulation</a></li><li><a class="toctext" href="#Channels-1">Channels</a></li><li class="toplevel"><a class="toctext" href="#Waveforms-1">Waveforms</a></li><li><a class="toctext" href="#Common-functions-2">Common functions</a></li><li><a class="toctext" href="#BF-OFDM-1">BF-OFDM</a></li><li><a class="toctext" href="#FBMC-1">FBMC</a></li><li><a class="toctext" href="#OFDM-1">OFDM</a></li><li><a class="toctext" href="#SC-FDMA-1">SC-FDMA</a></li><li><a class="toctext" href="#UF-OFDM-1">UF-OFDM</a></li><li><a class="toctext" href="#WOLA-1">WOLA</a></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../Examples/example_AWGN/">Transmission of xQAM with additive white Gaussian noise</a></li><li><a class="toctext" href="../Examples/example_BER/">Compute the theoretical BER for AWGN channel and various constellation size</a></li><li><a class="toctext" href="../Examples/example_PSD/">Plotting PSD of several multicarrier waveforms</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Function list</a></li></ul><a class="edit-page" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/master/docs/src/base.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Function list</span><a class="fa fa-bars" href="#"></a></div></header><h2><a class="nav-anchor" id="Common-functions-1" href="#Common-functions-1">Common functions</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.avgPower-Tuple{Any}" href="#DigitalComm.avgPower-Tuple{Any}"><code>DigitalComm.avgPower</code></a> — <span class="docstring-category">Method</span>.</div><div><div><hr/><p>Calculate the average power of the input signal  σ	= 1 / N Σ | x[n] | ^2 </p><p><strong>–- Syntax</strong></p><p>σ	= avgPower(x);</p><p><strong>–- Input parameters</strong></p><ul><li>x	  : Input signal [Array{Any}]</li></ul><p><strong>–- Output parameters</strong></p><ul><li>σ	  : Estimated power [Float64]</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/DigitalComm.jl#L128-L141">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.getSIR" href="#DigitalComm.getSIR"><code>DigitalComm.getSIR</code></a> — <span class="docstring-category">Function</span>.</div><div><div><hr/><p>Returns the Signal to interference ratio expressed in dB (or in linear) between a obersvation signal d(n) and a reference signal u(n) The ratio is expressed as 10*log10( E[ || d(n) - u(n) || / E[||u(n)||^2]  )  with E the expectation wrt to time  The 2 vectors d and u should have the same length L</p><p><strong>–- Syntax</strong></p><p>sir = getSIR( d, u , type=&quot;dB&quot;)</p><p><strong>–-  Input parameter</strong></p><ul><li>d	: Observation signal [Array{Any}]</li><li>u	: Reference signal [Array{Any}]	</li><li>type: Output unit [String]: &quot;dB&quot; or &quot;Linear&quot; (default, &quot;dB&quot;)</li></ul><p><strong>–- Output parameters</strong></p><ul><li>sir	: Signal to interference ratio in unit <code>type</code></li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/DigitalComm.jl#L81-L97">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.qFunc-Tuple{Any}" href="#DigitalComm.qFunc-Tuple{Any}"><code>DigitalComm.qFunc</code></a> — <span class="docstring-category">Method</span>.</div><div><div><hr/><p>Returns the Q function used for Bit error rate computation in digital system   Q(x)= 1/2 erfc(x/sqrt(2)) erfc is the Complexmplementary error function, i.e. the accurate version of 1-erf(x) for large x erfc is inherited from DSP</p><p><strong>–- Syntax</strong></p><p>y = qfunc(x)</p><p><strong>–- Input parameters</strong></p><ul><li>x: Input [Float64]</li></ul><p><strong>–- Output parameters</strong></p><ul><li>y: Q(x)[Float64] </li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/DigitalComm.jl#L59-L73">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.Waveform" href="#DigitalComm.Waveform"><code>DigitalComm.Waveform</code></a> — <span class="docstring-category">Type</span>.</div><div><div><hr/><p>Abstract type gathering all waveform configuration </p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/DigitalComm.jl#L163-L168">source</a></section><h2><a class="nav-anchor" id="Quadrature-Amplitude-Modulation-1" href="#Quadrature-Amplitude-Modulation-1">Quadrature Amplitude Modulation</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.genBitSequence" href="#DigitalComm.genBitSequence"><code>DigitalComm.genBitSequence</code></a> — <span class="docstring-category">Function</span>.</div><div><div><hr/><p>Create a binary sequence and return a buffer with nbBits bits The array is of type UInt8 with x00 or x01) If stated, randSeed controls the seed of the random generator</p><p><strong>–- Syntax</strong></p><pre><code class="language-none">  genBitsequence!(nbBits,randSeed=-1);</code></pre><p><strong>–- Input parameters</strong></p><ul><li>nbBits	: Number of bits to generate [Int]</li><li>randSeed	: Seed of random process (default -&gt; -1) [Int]</li></ul><p><strong>–- Output parameters</strong></p><ul><li>buffer	: Populated buffer [Array{UInt8}]</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/genBitSequence.jl#L44-L58">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.genBitSequence!" href="#DigitalComm.genBitSequence!"><code>DigitalComm.genBitSequence!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><hr/><p>Create a binary sequence and populate input buffer with nbBits bits The array is of type UInt8 with x00 or x01) If stated, randSeed controls the seed of the random generator</p><p><strong>–- Syntax</strong></p><pre><code class="language-none">  genBitsequence!(buffer,nbBits,randSeed=-1);</code></pre><p><strong>–- Input parameters</strong></p><ul><li>buffer	: Buffer to populate [Array{UInt8,nbBits}]</li><li>nbBits	: Number of bits to generate [Int]</li><li>randSeed	: Seed of random process (default -&gt; -1)</li></ul><p><strong>–- Output parameters</strong></p><ul><li>buffer	: Populated buffer [Array{UInt8}]</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/genBitSequence.jl#L13-L28">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.genByteSequence" href="#DigitalComm.genByteSequence"><code>DigitalComm.genByteSequence</code></a> — <span class="docstring-category">Function</span>.</div><div><div><hr/><p>Create a byte sequence and return a populated  buffer with nbytes bytes The array </p><p><strong>–- Syntax</strong></p><pre><code class="language-none">  genByteSequence(nbBytes,randSeed=-1);</code></pre><p><strong>–- Input parameters</strong></p><ul><li>nbBytes	: Number of byte to generate [Int]</li><li>randSeed	: Seed of random process (default -&gt; -1)</li></ul><p><strong>–- Output parameters</strong></p><ul><li>buffer	: Populated buffer [Array{UInt8}]</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/genBitSequence.jl#L108-L122">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.genByteSequence!" href="#DigitalComm.genByteSequence!"><code>DigitalComm.genByteSequence!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><hr/><p>Create a byte sequence and populate input buffer with nbytes bytes The array is of type UInt8 with x00 to xff If stated, randSeed controls the seed of the random generator</p><p><strong>–- Syntax</strong></p><pre><code class="language-none">  genByteSequence!(buffer,nbBytes,randSeed=-1);</code></pre><p><strong>–- Input parameters</strong></p><ul><li>buffer	: Buffer to populate [Array{UInt8,nbByte}]</li><li>nbBytes	: Number of byte to generate [Int]</li><li>randSeed	: Seed of random process (default -&gt; -1)</li></ul><p><strong>–- Output parameters</strong></p><ul><li>buffer	: Populated buffer [Array{UInt8}]</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/genBitSequence.jl#L75-L91">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.bitMappingQAM!-Tuple{Any,Any,Any}" href="#DigitalComm.bitMappingQAM!-Tuple{Any,Any,Any}"><code>DigitalComm.bitMappingQAM!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><hr/><p>Quadrature Amplitude Modulation (QAM) function    Apply symbol mapping to a input binary sequence (of size 1xL) with constellation size M. 	Output is a vector (1xN) with N = L / log2(M) 	Conventional gray mapping is used. Output constellation is casted in float, with unitary average power  Supported constellation</p><ul><li>QPSK</li><li>16-QAM</li><li>64-QAM</li><li>256-QAM</li></ul><p><strong>–- Syntax</strong></p><p>bitMappingQAM!(qamMat,M,bitSeq)</p><p><strong>–- Input parameters</strong></p><ul><li>qamMat	: Complex Vector to populate of size length(bitSeq) / log2(M) [Array{Complex{Float64}}]</li><li>M			: Modulation size (i.e from 4 to 256) such as bit per symbol is log2(M) [Int]</li><li>bitSeq	: Binary sequence to be transformed into QPSK symbols [Array{UInt8}]</li></ul><p><strong>–- Output parameters</strong></p><ul><li>[]</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/bitMapping.jl#L1-L23">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.bitDemappingQAM!-Tuple{Any,Any,Any}" href="#DigitalComm.bitDemappingQAM!-Tuple{Any,Any,Any}"><code>DigitalComm.bitDemappingQAM!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><hr/><p>Quadrature Amplitude Modulation (QAM) hard decoding function Apply symbol hard demapping to a input symbol sequence (of size 1xN) with constellation size M. Output is a binary (1xL) with N = L / log2(M) Conventional gray demapping is used. Input constellation is Array{Complex{Float64}} Output bitsream is Array{Int8}</p><p><strong>–- Syntax</strong></p><pre><code class="language-none">  bitDemappingQAM!(hardBits,M,qamVect)</code></pre><p><strong>–- Input parameters</strong></p><ul><li>hardBits	: Vector of bits to populate [Array{UInt8}, length(qamVect)/log2(M)]</li><li>M			: Constellation size (i.e from 4 to 256)</li><li>qamVect	: Complex observation vector to decode.</li></ul><p><strong>–- Output parameters</strong></p><ul><li>[]</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/bitDeMapping.jl#L1-L20">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.hardConstellation!-Tuple{Any,Any,Any}" href="#DigitalComm.hardConstellation!-Tuple{Any,Any,Any}"><code>DigitalComm.hardConstellation!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><hr/><p>Quadrature Amplitude Modulation (QAM) hard decoding function Return the hard decoded constellation with voronoi baseds decision. The difference with bitDeMapping is that bitDeMapping returns the decoded bit sequence whereas hardConstellation returns the closest constellation point. This can be use to compute raw EVM estimation (assuming a sufficiently high SNR to avoid errors).</p><p><strong>–- Syntax</strong></p><pre><code class="language-none">hardConstellation!(qamDec,M,qamMat)</code></pre><p><strong>–- Input parameters</strong></p><ul><li>qamDec	: Vector to populate [Array{Complex{Float64},N}] with N = length(qamMat)</li><li>M			: Constellation size (i.e 4 to 256) </li><li>qamMat	: Vector to decode</li></ul><p><strong>–- Output parameters</strong></p><ul><li>[]</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/hardConstellation.jl#L1-L15">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.llrToHardBits!-Tuple{Any,Array{Float64,N} where N}" href="#DigitalComm.llrToHardBits!-Tuple{Any,Array{Float64,N} where N}"><code>DigitalComm.llrToHardBits!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><hr/><p>Returns hard binary value from soft LLR estimate (no FEC decoder, only hard decision here!)</p><p><strong>–- Syntax</strong></p><pre><code class="language-none">llrToHardBits(hardD,llr)</code></pre><p><strong>–- Input parameters</strong></p><ul><li>hardD	  : Hard binary decision [Array{UInt},N] </li><li>llr	  : Input LLR (Float64 or UInt8 array) [Union{[Array{UInt}],[Array{Float64}]}]</li></ul><p><strong>–- Output parameters</strong></p><ul><li>[]</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/symbolDemapper.jl#L330-L343">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.llrToHardBits!-Tuple{Any,Array{UInt8,N} where N}" href="#DigitalComm.llrToHardBits!-Tuple{Any,Array{UInt8,N} where N}"><code>DigitalComm.llrToHardBits!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><hr/><p>Returns hard binary value from soft LLR estimate (no FEC decoder, only hard decision here!)</p><p><strong>–- Syntax</strong></p><pre><code class="language-none">llrToHardBits(hardD,llr)</code></pre><p><strong>–- Input parameters</strong></p><ul><li>hardD	  : Hard binary decision [Array{UInt},N] </li><li>llr	  : Input LLR (Float64 or UInt8 array) [Union{[Array{UInt}],[Array{Float64}]}]</li></ul><p><strong>–- Output parameters</strong></p><ul><li>[]</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/symbolDemapper.jl#L349-L361">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.llrToHardBits-Tuple{Array{Float64,N} where N}" href="#DigitalComm.llrToHardBits-Tuple{Array{Float64,N} where N}"><code>DigitalComm.llrToHardBits</code></a> — <span class="docstring-category">Method</span>.</div><div><div><hr/><p>Returns hard binary value from soft LLR estimate (no FEC decoder, only hard decision here!)</p><p><strong>–- Syntax</strong></p><pre><code class="language-none">hardD = llrToHardBits(llr)</code></pre><p><strong>–- Input parameters</strong></p><ul><li>llr	  : Input LLR (Float64 or UInt8 array) [Union{[Array{UInt}],[Array{Float64}]}]</li></ul><p><strong>–- Output parameters</strong></p><ul><li>hardD	  : Hard binary decision [Array{UInt},N] </li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/symbolDemapper.jl#L368-L379">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.llrToHardBits-Tuple{Array{UInt8,N} where N}" href="#DigitalComm.llrToHardBits-Tuple{Array{UInt8,N} where N}"><code>DigitalComm.llrToHardBits</code></a> — <span class="docstring-category">Method</span>.</div><div><div><hr/><p>Returns hard binary value from soft LLR estimate (no FEC decoder, only hard decision here!)</p><p><strong>–- Syntax</strong></p><pre><code class="language-none">hardD = llrToHardBits(llr)</code></pre><p><strong>–- Input parameters</strong></p><ul><li>llr	  : Input LLR (Float64 or UInt8 array) [Union{[Array{UInt}],[Array{Float64}]}]</li></ul><p><strong>–- Output parameters</strong></p><ul><li>hardD	  : Hard binary decision [Array{UInt},N] </li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/symbolDemapper.jl#L386-L398">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.llrToUInt!-Tuple{Any,Any}" href="#DigitalComm.llrToUInt!-Tuple{Any,Any}"><code>DigitalComm.llrToUInt!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><hr/><p>Convert a LLR floating array to a UInt LLR  Some method (espcially C functions as in libfec) expect LLR to be UInt value from  0 (Likely a 0) to 255 (Likely a 1).  symbolDemappingQAM create a Float64 array from -infty (likely a 0) to nfty (Likely a 1). This function take a Float64 LLR estimate and output a UInt8 vector</p><p><strong>–- Syntax</strong></p><pre><code class="language-none">llrToUInt!(llrUInt,llr)</code></pre><p><strong>–- Input parameters</strong></p><ul><li>llrUInt : Output LLR in UInt [Array{UInt},N]</li><li>llr	  : Input LLR [Array{Float64},N]</li></ul><p><strong>–- Output parameters</strong></p><ul><li>[]</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/symbolDemapper.jl#L272-L286">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.llrToUInt-Tuple{Any}" href="#DigitalComm.llrToUInt-Tuple{Any}"><code>DigitalComm.llrToUInt</code></a> — <span class="docstring-category">Method</span>.</div><div><div><hr/><p>Convert a LLR floating array to a UInt LLR  Some method (espcially C functions as in libfec) expect LLR to be UInt value from  0 (Likely a 0) to 255 (Likely a 1).  symbolDemappingQAM create a Float64 array from -infty to infty. This function take a Float64 LLR estimate and output a UInt8 vector</p><p><strong>–- Syntax</strong></p><pre><code class="language-none">llrUInt = llrToUInt(llr)</code></pre><p><strong>–- Input parameters</strong></p><ul><li>llr	  : Input LLR [Array{Float64},N]</li></ul><p><strong>–- Output parameters</strong></p><ul><li>llrUInt : Output LLR in UInt [Array{UInt},N]</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/symbolDemapper.jl#L303-L316">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.symbolDemappingQAM!-NTuple{4,Any}" href="#DigitalComm.symbolDemappingQAM!-NTuple{4,Any}"><code>DigitalComm.symbolDemappingQAM!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><hr/><p><strong>–- Description</strong></p><p>Returns the log likelihood ratio of the incoming sequence qamSeq based on the channel estimates channelIn qamSeq is an input noisy QAM sequence with same size of channel estimate vector Output is populated by  soft output binary sequence to be fed in a FEC </p><p><strong>–- Syntax</strong></p><p>output	  = :symbolDemappingQAM(mcs,qamSeq,channel)</p><p><strong>–- Input parameters</strong></p><ul><li>output  : Soft bits [Array{UInt8},N*log2(mcs)]</li><li>mcs	  : Constellation size (from 4 to 256) [Int]</li><li>qamSeq  : Complex noisy received sequence (after equalization) [Array{Float64},N]</li><li>channel : Complex channel estimate [Array{Float64},N]</li></ul><p><strong>–- Output parameters</strong></p><ul><li>[]</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/symbolDemapper.jl#L91-L109">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.symbolDemappingQAM-Tuple{Any,Any,Any}" href="#DigitalComm.symbolDemappingQAM-Tuple{Any,Any,Any}"><code>DigitalComm.symbolDemappingQAM</code></a> — <span class="docstring-category">Method</span>.</div><div><div><hr/><p><strong>–- Description</strong></p><p>Returns the log likelihood ratio of the incoming sequence qamSeq based on the channel estimates channelIn. Max log approximation is considered qamSeq is an input noisy QAM sequence with same size of channel estimate vector Output is a vector of soft output binary sequence to be fed in a FEC </p><p><strong>–- Syntax</strong></p><p>output	  = :symbolDemappingQAM(mcs,qamSeq,channel)</p><p><strong>–- Input parameters</strong></p><ul><li>mcs	  : Constellation size (from 4 to 256) [Int]</li><li>qamSeq  : Complex noisy received sequence (after equalization) [Array{Float64},N]</li><li>channel : Complex channel estimate [Array{Float64},N]</li></ul><p><strong>–- Output parameters</strong></p><ul><li>output  : Soft bits [Array{UInt8},N*log2(mcs)]</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/symbolDemapper.jl#L65-L81">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.calcLLR-Tuple{Any,Any,Any}" href="#DigitalComm.calcLLR-Tuple{Any,Any,Any}"><code>DigitalComm.calcLLR</code></a> — <span class="docstring-category">Method</span>.</div><div><div><hr/><p>Returns the final LLR value based on input distances </p><p><strong>–- Syntax</strong></p><p>llr = calcLLR(e0,e1,c)</p><p><strong>–- Input parameters</strong></p><ul><li>e0  : Minimal distance 1 </li><li>e1  : Minimal distance 2 </li><li>c	  : Channel estimate </li></ul><p><strong>–- Output parameters</strong></p><ul><li>llr : Max likelihood estimate </li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/symbolDemapper.jl#L47-L61">source</a></section><h2><a class="nav-anchor" id="Channels-1" href="#Channels-1">Channels</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.addNoise-Union{Tuple{T}, Tuple{Array{T,N} where N,Any}, Tuple{Array{T,N} where N,Any,Any}} where T" href="#DigitalComm.addNoise-Union{Tuple{T}, Tuple{Array{T,N} where N,Any}, Tuple{Array{T,N} where N,Any,Any}} where T"><code>DigitalComm.addNoise</code></a> — <span class="docstring-category">Method</span>.</div><div><div><hr/><p>Add a white additive circular gaussian noise to input signal Added noise is real if input signal is real and computedlex is input signal is complex Noise level is controled by the second input parameter which is the signal to noise ratio (SNR) Signal power powSig is computed based in the input sequence power (average power in time domain) although a third parameter (theoretical power of input signal is given). In that case, snr is computed based on the value powSig output parameters are the signal with noise, and the noise samples See the bang methods for non-buffer alloc.</p><p><strong>–- Syntax</strong></p><p>[y,n]   = addNoise(x,snr,powSig);</p><p><strong>–- Input parameters</strong></p><ul><li>x= Input signal [Array{Real{Float64}}, Array{Complex{Float64}}] of size N</li><li>snr= Desired signal to noise ratio [Float64]</li><li>powSig= Power of input signal. If not given, power is evaluated based on input signal x</li></ul><p><strong>–- Output parameters</strong></p><ul><li>y= Signal with noise [Array{Real{Float64}}, Array{Complex{Float6464}}] of size N</li><li>n= noise samples [Array{Real{Float64}}, Array{Complex{Float64}}] of size N</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/Channel/addNoise.jl#L1-L23">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.rayleighChan" href="#DigitalComm.rayleighChan"><code>DigitalComm.rayleighChan</code></a> — <span class="docstring-category">Function</span>.</div><div><div><hr/><p>Generates a correlated random rayleigh sequence of size N, parametrized by the doppler frequency fd and the sampling frqeuency fs. The method uses IFFT approach described in [1]</p><p><strong>–- Syntax</strong></p><p>α		= rayleighChan(nbPath,N,fs,fd,seed=-1)</p><p><strong>–- Input parameters</strong></p><ul><li>nbPath : Number of path to be generated (&gt;0) [Int]</li><li>N	: Size of desired output (size of FFT) [Union{Int,Float64}]</li><li>fs	: Sampling frequency [Union{Int,Float64}]</li><li>fd	: doppler frequency [Union{Int,Float64}]</li><li>seed: Seed for random generation ([Int], default =-1)</li></ul><p><strong>–- Output parameters</strong></p><ul><li>α	: Complex rayleigh coefficient [Array{Complex{Float64},N}]</li></ul><p><strong>–- References</strong></p><p>[1] D. J. Young and N. C. Beaulieu, &quot;The generation of correlated Rayleigh random variates by inverse discrete Fourier transform,&quot; in IEEE Transactions on Communications</p><p><strong>–-</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/Channel/rayleighChan.jl#L1-L20">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.applyChannel-Tuple{Any,Any}" href="#DigitalComm.applyChannel-Tuple{Any,Any}"><code>DigitalComm.applyChannel</code></a> — <span class="docstring-category">Method</span>.</div><div><div><hr/><p>Apply a channel implementation  to an input signal</p><p><strong>–- Syntax</strong></p><p>sigChan	  : applyChannel(sigId,channelImpl)</p><p><strong>–- Input parameters</strong></p><ul><li>sigId	  : Input signal [Array{Any}]</li><li>channelImpl : Channel implementation [ChannelImpl]</li></ul><p><strong>–- Output parameters</strong></p><ul><li>sigChan	: Output signal [Array{Any}]</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/Channel/getChannel.jl#L345-L358">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.getChannel" href="#DigitalComm.getChannel"><code>DigitalComm.getChannel</code></a> — <span class="docstring-category">Function</span>.</div><div><div><hr/><p>Create a channelImpl based on desired channel model and number of realisations </p><p><strong>–- Syntax</strong></p><p>channelImpl	  = getChannel(nbSamples,channelModel,randSeed=-1)</p><p><strong>–- Input parameters</strong></p><ul><li>nbSamples		: Number of samples on which channel will be applied [Int]</li><li>channelModel	: Channel object [ChannelModel]</li><li>randSeed		: Desired seed (default -1)</li></ul><p><strong>–- Output parameters</strong></p><ul><li>channelImpl	: Channel implementation </li></ul><p><strong>–-</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/Channel/getChannel.jl#L240-L253">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.getFIRResponse" href="#DigitalComm.getFIRResponse"><code>DigitalComm.getFIRResponse</code></a> — <span class="docstring-category">Function</span>.</div><div><div><hr/><p>Returns a complete FIR response based on the power profile (in linear scale), the delay profile (in s) and the sampling frequency.</p><p><strong>–- Syntax</strong></p><p>cir = getFIRResponse(delayProfile:,powerProfile,freq,sincSupport=5,interpSystem=0)</p><p><strong>–- Input parameters</strong></p><ul><li>delayProfile	: Vector of delay in second [Union{Array{Int},Array{Float64}}]</li><li>powerProfile	: Vector of attenuation with same size of delayProfile in linear scale with rayleigh distribution</li><li>freq			: Sampling frequency</li><li>sincSupport	: Size of interpolator (default 5)</li><li>interpSystem	: Forcing extra delay for all samples to have proper interpolation of the FIR beginning (default 0)</li></ul><p><strong>–- Ouput parameters</strong></p><ul><li>cir			: Finite impulse response [Array{Complex{Float64}},max(delayProfile)+sincSupport]</li></ul><p><strong>–-</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/Channel/getChannel.jl#L178-L193">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.initChannel-Tuple{String,Union{Float64, Int64},Union{Float64, Int64},Union{Float64, Int64}}" href="#DigitalComm.initChannel-Tuple{String,Union{Float64, Int64},Union{Float64, Int64},Union{Float64, Int64}}"><code>DigitalComm.initChannel</code></a> — <span class="docstring-category">Method</span>.</div><div><div><hr/><p>Create a channel object associated to physical parameters and propagation profile.</p><p><strong>–- Syntax</strong></p><p>channObj  = initChannel(profile,carrierFreq,samplingFreq,dopplerFreq,powerProfile,delayProfile,randSeed=-1)</p><p><strong>–- Input parameters</strong></p><p><strong>–- Input parameters</strong></p><ul><li>profile : Multipath profile (see below) [String]</li><li>carrierFreq : Carrier frequency in Hz [Union{Int,Float64}]</li><li>samplingFreq: baseband sampling frequency [Union{Int,Float64}]</li><li>speed : Velocity (km/h) [Float64]</li><li>randSeed : Seed if necessary (default: -1) [Float64]</li></ul><p><strong>–- Output parameters</strong></p><ul><li>channel : Julia Channel Object [Channel]</li></ul><p><strong>–- Channel models</strong></p><p>-	ETU	  : Extended Typical Urban -	EVA	  : Extended Vehicular area -	TDLC  : -	Rayleigh : Single tap rayleigh channel model</p><p><strong>–-</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/Channel/getChannel.jl#L56-L77">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.ChannelImpl" href="#DigitalComm.ChannelImpl"><code>DigitalComm.ChannelImpl</code></a> — <span class="docstring-category">Type</span>.</div><div><div><hr/><p>Object with channel realisations</p><p><strong>–- Syntax</strong></p><ul><li>timeVarying	: Flag for constant vs time varying channel [Int] </li><li>cir			: CIR matrix (nbTap x nbChannel) [Union{Array{Int},Array{Float64},Array{Complex{Float64}}}]</li><li>channelModel  : Model use for generation [DigitalComm.ChannelModel]</li><li>powerLin		: Power distribution with the rayleigh distribution [Array{Complex{Float64}}] </li><li>randSeed		: Seed use for rayleigh generation </li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/Channel/getChannel.jl#L33-L45">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.ChannelModel" href="#DigitalComm.ChannelModel"><code>DigitalComm.ChannelModel</code></a> — <span class="docstring-category">Type</span>.</div><div><div><hr/><p>Channel model object</p><p><strong>–- Syntax</strong></p><ul><li>profile		  : Name of profile [String]</li><li>carrierFreq	  : Carrier frequency [Union{Int,Float64}]</li><li>samplingFreq	  : Sampling frequency [Union{Int,Float64}]</li><li>speed			  : Desired speed (km/h) [Union{Int,Float64}]</li><li>powerProfile	  : Distribution of power values in dB [Array{Float64}]</li><li>delayProfile	  : Distribution of delay values in s <a href="same size as powerProfile">Array{Float64}</a> </li><li>dopplerFreq	  : Doppler frequency (inherited from samplingFreq  and speed) </li><li>delaySpread	  : Max support of CIR in samples [Int]</li></ul><p><strong>–-</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/Channel/getChannel.jl#L5-L19">source</a></section><h1><a class="nav-anchor" id="Waveforms-1" href="#Waveforms-1">Waveforms</a></h1><h2><a class="nav-anchor" id="Common-functions-2" href="#Common-functions-2">Common functions</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.decodeSig-Tuple{Any,Dict{String,Waveform},String}" href="#DigitalComm.decodeSig-Tuple{Any,Dict{String,Waveform},String}"><code>DigitalComm.decodeSig</code></a> — <span class="docstring-category">Method</span>.</div><div><div><hr/><p>Create a signal based on a waveform dictionnary and a desired configuration (i.e the key)</p><p><strong>–- Syntax</strong></p><p>sigId	= decodeSig(qamMat,dWav,key)</p><p><strong>–- Input parameters</strong></p><ul><li>signal	  : Time domain signal </li><li>qamMat  : Time frequency complex QAM matrix [Array{Complex{Float64}}]</li><li>dWav	  : Waveform dictionnary (see initWaveforms)</li><li>key	  : Desired waveform configuration</li></ul><p><strong>–- Output parameters</strong></p><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/Waveforms/genSig.jl#L151-L165">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.decodeSig-Tuple{Any,DigitalComm.StrucOFDM}" href="#DigitalComm.decodeSig-Tuple{Any,DigitalComm.StrucOFDM}"><code>DigitalComm.decodeSig</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Decode a time domain signal for a given multicarrier waveform and returns a T/F QAM constellation. Input are the compelx baseband signal  and the Waveform structure.</p><p><strong>–- Syntax</strong></p><pre><code class="language-none">qamDec	= decodeSig(signal,struc);</code></pre><p><strong>–- Input parameters</strong></p><ul><li>signal  : Time domain signal </li><li>struc	  : Waveform structure </li></ul><p><strong>–- Output parameters</strong></p><ul><li>qamDec  : Time frequency complex QAM matrix [Array{Complex{Float64}}]</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/Waveforms/genSig.jl#L34-L47">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.genSig-Tuple{Any,DigitalComm.StrucOFDM}" href="#DigitalComm.genSig-Tuple{Any,DigitalComm.StrucOFDM}"><code>DigitalComm.genSig</code></a> — <span class="docstring-category">Method</span>.</div><div><div><hr/><p>Generate a time domain signal for a given multicarrier waveform. Input are the Time-Frequency matrix qamMat and the Waveform structure.</p><p><strong>–- Syntax</strong></p><p>sigId	= genSig(qamMat,struc::Waveform)</p><p><strong>–- Input parameters</strong></p><ul><li>qamMat  : Time frequency complex QAM matrix [Array{Complex{Float64}}]</li><li>struc	  : Waveform structure </li></ul><p><strong>–- Output parameters</strong></p><ul><li>sigId	  : Time domain signal </li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/Waveforms/genSig.jl#L1-L14">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.genSig-Tuple{Array{Complex{Float64},N} where N,Dict{String,Waveform},String}" href="#DigitalComm.genSig-Tuple{Array{Complex{Float64},N} where N,Dict{String,Waveform},String}"><code>DigitalComm.genSig</code></a> — <span class="docstring-category">Method</span>.</div><div><div><hr/><p>Create a signal based on a waveform dictionnary and a desired configuration (i.e the key)</p><p><strong>–- Syntax</strong></p><p>sigId	= genSig(qamMat,dWav,key)</p><p><strong>–- Input parameters</strong></p><ul><li>qamMat  : Time frequency complex QAM matrix [Array{Complex{Float64}}]</li><li>dWav	  : Waveform dictionnary (see initWaveforms)</li><li>key	  : Desired waveform configuration</li></ul><p><strong>–- Output parameters</strong></p><ul><li>sigId	  : Time domain signal </li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/Waveforms/genSig.jl#L133-L147">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.getWaveformName-Tuple{Waveform}" href="#DigitalComm.getWaveformName-Tuple{Waveform}"><code>DigitalComm.getWaveformName</code></a> — <span class="docstring-category">Method</span>.</div><div><div><hr/><p>Returns the waveform name based on input type structure</p><p><strong>–- Syntax</strong></p><p>name = getWaveformName(struc)</p><p><strong>–- Input parameters</strong></p><ul><li>struc	  : Waveform structure [Waveform]</li></ul><p><strong>–- Output parameters</strong></p><ul><li>name	  : String associated to waveform name</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/Waveforms/genSig.jl#L67-L79">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.initWaveforms-Tuple" href="#DigitalComm.initWaveforms-Tuple"><code>DigitalComm.initWaveforms</code></a> — <span class="docstring-category">Method</span>.</div><div><div><hr/><p>Create a dictionnary of waveform configurations. To compare and use the same script for different waveform configuration, we propose to add a dictionnary to have a container that contains all waveform configuraton. The function is called with every desired waveform structure. The dictionnary as a key associated to the waveform name, and a field associated to the waveform structure. If the waveform is present several times (several configuration with same waveform type, for instance FBMC with different overlapping factor values), a counter index is added to the waveform key.</p><p><strong>–- Syntax</strong></p><pre><code class="language-none">dWav  = initWaveforms(x1,x2,...)</code></pre><p><strong>–- Input parameters</strong></p><ul><li>x		: Waveform structure [Waveform]</li></ul><p><strong>–- Output parameters</strong></p><ul><li>dWav	: Dictionnary of waveforms.</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/Waveforms/genSig.jl#L95-L107">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.genZCSequence" href="#DigitalComm.genZCSequence"><code>DigitalComm.genZCSequence</code></a> — <span class="docstring-category">Function</span>.</div><div><div><hr/><p>Constant Modulus Zero Autocorrelation (CAZAC) sequence generation. Sequence can be used as preamble sequences for OFDM systems. The function generate the ZC sequence in frequency domain. Generates a Zadoff-Chu  sequence on allocated subcarrier mapped on nFFT vector with generated kernel muPSS and power boost zcBoost</p><p><strong>–- Syntax</strong></p><p>zcSeq	  = genZCSequence(nFFT,allocatedSubcarrier,muPSS=0,zcBoost=0)</p><p><strong>–- Input parameters</strong></p><ul><li>nFFT				  : FFT size for output [Int]</li><li>allocatedSubcarrier : vector of allocated subcarrier [Array{Int,L}]. </li><li>muPSS				  : Kernel for ZC sequence [Int] – default 0</li><li>zcBoost			  : Power boost (in dB) applied to sequence [Float32] – default 0.</li></ul><p><strong>–- Output parameters</strong></p><ul><li>zcSeq				  : ZC sequence [Array{Complex{Float64}},nFFT]</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/Waveforms/genZCSequence.jl#L1-L17">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.getLTEAlloc-Tuple{Any}" href="#DigitalComm.getLTEAlloc-Tuple{Any}"><code>DigitalComm.getLTEAlloc</code></a> — <span class="docstring-category">Method</span>.</div><div><div><hr/><p>Returns the vector of allocated subcarriers associated to Long Term evolution frequency mapping. In LTE, depending on FFT size, only few subcarriers are allocated (45-55%). This function takes a FFT size as input  and returns an array of size nbSubcarriers </p><p><strong>–- Syntax</strong></p><p>allocatedSubcarrier = getLTEAlloc(nFFT)</p><p><strong>–- Input parameters</strong></p><ul><li>nFFT	  : Desired FFT size (128, 256, 512, 1024, 1536, 2048, 4096) [Int]</li></ul><p><strong>–- Output parameters</strong></p><ul><li>allocatedSubcarrier : Vector of subcarriers index [Array{Int}]</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/Waveforms/getLTEAlloc.jl#L1-L15">source</a></section><h2><a class="nav-anchor" id="BF-OFDM-1" href="#BF-OFDM-1">BF-OFDM</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.getBFOFDMFilter-Tuple{Any,Any,Any}" href="#DigitalComm.getBFOFDMFilter-Tuple{Any,Any,Any}"><code>DigitalComm.getBFOFDMFilter</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Returns prototype fitlering matrix for BF-OFDM  with specified by overlapping factor K, PPN size nFBMC, filter type. Additional parameters are the CP size of the precoding stage (set to optimal value by default) and filter structure for specific parameter overset.</p><p><strong>–- Syntax</strong></p><p>(p,pF) = getBFOFDMFilter(K,nFBMC,filter;GI,BT,filterStopBand,fS)&gt;</p><p><strong>–- Input parameters</strong></p><ul><li>K	  : Overlapping factor [Int]</li><li>nFBMC : PPN size (Number of FBMC carriers) [Int]</li><li>filter: Filter type: &quot;Gaussian&quot;,&quot;phydyas&quot;,&quot;FS&quot;,&quot;DC&quot;: [String]</li><li>BT	  : Bandwidth time product for custom gaussian filter (used with &quot;gaussian&quot;) [Float64]</li><li>filterStopBand : Attenuation with custom DC window (used with &quot;DC&quot;) [Float64]</li><li>fS	  : Frequency sampling custom  coefficients (Array{Float64,K}) (used with &quot;fs&quot;)</li></ul><p><strong>–- Output parameters</strong></p><ul><li>p		: Filter impulse response [Array{Float64,K*nFBMC}].</li><li>pF		: Filter coefficient in frequency domain (For Frequency sampling implementation)</li></ul><hr/><p>Filter types All filter type can be called with 2 ways. &quot;filter&quot; and &quot;filter<em>opt&quot;. When &quot;filter</em>opt&quot; is used, the filter coefficient are obtained through numerical optimisation (SIR optimisation). Otherwise, it uses its associated parameter to extract appropriate coefficients. See [1] and [2] for filter optimisation principles. See [4] for special cases about 5G-NR compatibilty.  The supported filter/windows are:</p><ul><li>Gaussian	: Gaussian filter shape, specified by BT. Optimized Gaussian shape can be used [1]</li><li>phydyas		: Classic FBMC pulse shape defined in frequency domain [3]</li><li>FS			: Coefficient defined in frequency domain. Filter coefficient are based on intrinsic SIR optimisation [1]</li><li>DC			: Dolph Chebyshev window. Can be based on window optimisation (SIR optimisation) or defined by filterStopBand parameter.</li></ul><p><strong>–-</strong></p><p><strong>References</strong></p><ul><li>[1]	Demmer, D and Gerzaguet, R and Doré, J-B and Le Ruyet, D. and Kténas, D, &quot;Filter Design for 5G BF-OFDM Waveform&quot;, 2017.</li><li>[2] A. Sahin, I. Guvenc, and H. Arslan, “A Survey on Multicarrier Communications: Prototype Filters, Lattice Structures, and Implementation Aspects&quot;, 2014</li><li>[3] Phydyas project, &quot;Deliverable D5.1 : Prototype filter and structure optimization&quot;, 2009</li><li>[4]	Demmer, D and Rostom, Z and Gerzaguet, R and Doré, J-B and Le Ruyet, D. &quot;Study of OFDM Precoded Filter-Bank Waveforms&quot;, 2018</li></ul><p><strong>Examples</strong></p><p>Get a classic FBMC filter with phydyas and an overlapping factor of 4, with a input PPN of size 64. The precodinng stage is a OFDM of size 64 and a GI of size 4.</p><pre><code class="language-none"># --- phydyas filter
( hphydyas,hFphydyas )	 = getBFOFDMFilter(4,64,&quot;phydyas&quot;);

# --- Gaussian shape
( hGaussian,hFGaussian )	 = getBFOFDMFilter(4,64,&quot;Gaussian_opt&quot;,GI=4);

# --- Custom Gaussian window
( hGaussianC,hFGaussianC ) = getBFOFDMFilter(4,64,&quot;Gaussian&quot;,GI=4,BT=0.5)</code></pre><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/Waveforms/BFOFDM/BFOFDM_filter.jl#L1-L45">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.bfofdmSigGen-Tuple{Array{Complex{Float64},N} where N,Int64,Int64,Int64,Int64,Float64,Array{Int64,N} where N,Any}" href="#DigitalComm.bfofdmSigGen-Tuple{Array{Complex{Float64},N} where N,Int64,Int64,Int64,Int64,Float64,Array{Int64,N} where N,Any}"><code>DigitalComm.bfofdmSigGen</code></a> — <span class="docstring-category">Method</span>.</div><div><div><hr/><p>Creates a Block Filtered - OFDM (BF-OFDM) signal parametrized by its numerlogy and its waveform parameter. Generate a time domain signal based on the input matrix qamMat. The input matrix is a T/F matrix of size (nRe x nbSymb) with nRe the number of allocated subcarrier and nbSymb the number of symbols.</p><p>The waveform is parametrized by the PPN size (number of carriers) nFBMC, the size of the precoding stage nOFDM, the CP size of the precoding stage GI and the compression factor parameter δ. See [1], [2] for waveform description and [3,5] for importance and design of compression rate (set to 0.5 in former works on BF-OFDM).</p><p>BF-OFDM is characterized by its pulse shape filter. Pulse shape can be automatically tuned to optimal (in terms of  innterference management) [4]. In such a case, filterType should be a string (can be &quot;gaussian<em>opt&quot;, &quot;dc</em>opt&quot; and &quot;fs_opt&quot;). For a specific pulse shape filter, an array of the nFBMC*K filter taps should be given (and generated for example  with getBFOFDMFilter).</p><p><strong>–- Syntax</strong></p><p>sigId	  =bfofdmSigGen(qamMat,nFBMC,nOFDM,K,GI,δ,allocatedSubcarriers,filterType;typeTx=&quot;PPN&quot;)</p><p><strong>–- Input parameters</strong></p><ul><li>qamMat		: T/F symbols to transmit (QAM symbols) [Array{Complex{Float64},nRe,nbSymb] with nbSymb number of BF-OFDM symbols and nRe number of allocated subcarriers.</li><li>nFBMC		: PPN size</li><li>nOFDM		: OFDM precoding size</li><li>GI			: CP size of precoding stage</li><li>K			: Overlapping factor</li><li>δ			: Compression rate</li><li>allocatedSubcarriers : Vector or allocated subcarriers Array{Int,nRe} with maximum(nRe) &lt; nOFDM<em>nFBMC</em>δ</li><li>filterType	: Pulse shape type. Can be a string (see getBFOFDMFilter) or a vector of size K x nFBMC with filter taps.</li><li>typeTx		: Filterbank architecture. Can be &quot;PPN&quot; (polyphase network) or &quot;FS&quot; (frequency spreading) if filterType is of type &quot;fs&quot; or &quot;fs_opt&quot;.</li></ul><p><strong>–- Output parameters</strong></p><ul><li>sigId		: Time domainn BF-OFDM signal. [Array{Complex{Float64},nChip}.</li></ul><p><strong>–-</strong></p><p><strong>References</strong></p><ul><li>[1] Gerzaguet, R and Demmer, D and Doré, J-B and Le Ruyet, D. and Kténas, D, &quot;Block-Filtered OFDM: A new Promising Waveform for Multi-service Scenarios&quot;, 2017</li><li>[2] Demmer, D and Gerzaguet, R and Doré, J-B and Le Ruyet, D. and Kténas, D, &quot;Block-filtered OFDM: A novel waveform for future wireless technologies&quot;, 2017.</li><li>[3] Demmer, D and Rostom, Z and Gerzaguet, R and Doré, J-B and Le Ruyet, D. &quot;Study of OFDM Precoded Filter-Bank Waveforms&quot;, 2018</li><li>[4] Demmer, D and Gerzaguet, R and Doré, J-B and Le Ruyet, D. and Kténas, D, &quot;Filter Design for 5G BF-OFDM Waveform&quot;, 2017.</li><li>[5] Demmer, D.; Zakaria, R.; Gerzaguet, R.; Doré, J. &amp; Le Ruyet, D. Study of OFDM Precoded Filter-Bank Waveforms, IEEE Transactions on Wireless Communications, 2019.</li></ul><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/Waveforms/BFOFDM/bfofdmSigGen.jl#L76-L106">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.initBFOFDM-NTuple{7,Any}" href="#DigitalComm.initBFOFDM-NTuple{7,Any}"><code>DigitalComm.initBFOFDM</code></a> — <span class="docstring-category">Method</span>.</div><div><div><hr/><p>BF-OFDM initialisation</p><p><strong>–- Syntax</strong></p><p>bfofdm = initBFOFDM(nFBMC::Int,nOFDM::Int,K::Int,GI::Int,δ::Float64,allocatedSubcarriers::Array{Int},filterType::String;BT=-1,filterStopBand=-1,fS=[],nFFT=-1,nCP=-1)</p><p><strong>–- Input parameters</strong></p><ul><li>nFBMC		: Number of carriers (PPN size)</li><li>nOFDM		: Number of subbcarriers per carrier (OFDM precoder size)</li><li>K			: Overlapping factor of the PPN </li><li>GI		: CP size of the precoder </li><li>δ			: Rate factor (compression factor)  </li><li>allocatedSubcarriers	: Vector of allocated subcarriers   </li><li>filterName  : Type of filter used (name)  </li><li>filterTaps  : FIR coefficient values </li><li>BT		: Gaussian parameters (if gaussian filter is used)</li><li>filterStopBand : DolphChebyshev attenuation factor (if DC is used)</li><li>fS		: Frqeuency spreading coefficients (if FS filter is used)</li><li>nFFT		: Equivalent OFDM FFT size </li><li>nCP		: Equivalent OFDM CP size </li></ul><p><strong>–- Output parameters</strong></p><p>bfofdm		: BF-OFDM structure </p><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/Waveforms/BFOFDM/bfofdmSigGen.jl#L40-L64">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.bfofdmSigDecode-NTuple{7,Any}" href="#DigitalComm.bfofdmSigDecode-NTuple{7,Any}"><code>DigitalComm.bfofdmSigDecode</code></a> — <span class="docstring-category">Method</span>.</div><div><div><hr/><p>Demodulate a BF-OFDM signal and returns the obtained T/F matrix composed of QAM symbols (without equalisation). Based on bfofdmSigGen.jl</p><p><strong>–- Syntax</strong></p><p>qamRx	= bfofdmSigDecode(sigRx,nFBMC,nOFDM,K,GI,δ,allocatedSubcarriers;posWindow=&quot;end&quot;)</p><p><strong>–- Input parameters</strong></p><ul><li>sigRx		: Complex baseband signal to decode [Array{Complex{Float64}}]</li><li>nFBMC		: PPN size [Int]</li><li>nOFDM		: FFT precoder size [Int]</li><li>K			: Overlapping factor [Int]</li><li>GI		: CP size of precoder [Int]</li><li>δ			: Compression rate  [Float64]</li><li>allocatedSubcarriers : Vector of allocated subcarriers [Array{Int}]</li><li>posWindow	  : Receiver window position. By default window is at same place as OFDM (i.e drop CP). For BF-OFDM, middle window position can also be considered with small delay spread channel (reduce ISI incuded by PPN). In that case, a phase rotation must be applied (see [1])</li></ul><p><strong>–- Output parameters</strong></p><ul><li>qamRx		: Decoded constellation [Array{Complex{Float64}}]</li></ul><p><strong>References</strong></p><ul><li>[1]	: Demmer, D.; Zakaria, R.; Gerzaguet, R.; Doré, J. &amp; Le Ruyet, D. Study of OFDM Precoded Filter-Bank Waveforms, IEEE Transactions on Wireless Communications, 2019.</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/Waveforms/BFOFDM/bfofdmSigDecode.jl#L1-L23">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.getBFOFDM_carrierFromSubcarriers-NTuple{4,Any}" href="#DigitalComm.getBFOFDM_carrierFromSubcarriers-NTuple{4,Any}"><code>DigitalComm.getBFOFDM_carrierFromSubcarriers</code></a> — <span class="docstring-category">Method</span>.</div><div><div><hr/><p>Get the index of the allocated carriers based on the index of the subcarriers. We consider here that a FBMC carriers bear data (i.e is allocated) is at least one of its subcarrier is enable.</p><p><strong>–- Syntax</strong></p><p>fbmcCarriers	= getBFOFDM_carrierFromSubcarriers(nFBMC,nOFDM,δ,subcarrier)</p><p><strong>–- Input parameters</strong></p><ul><li>nFBMC	  : FBMC carrier size (number of carriers) [Int]</li><li>nOFDM	  : OFDM subcarrier size [Int]</li><li>δ		  : Rate factor [Float64]</li><li>fbmcCarriers : Vector of allocated carrier [Array{Int,L}], L &lt; nFBMC<em>nOFDM</em>δ </li></ul><p><strong>–- Output parameters</strong></p><ul><li>fbmcCarriers : Vector of allocated carriers [Array{Int, P ] P &lt; nFBMC</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/Waveforms/BFOFDM/carrierManipulation.jl#L31-L46">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.getBFOFDM_oversampledGridSubcarriers-NTuple{4,Any}" href="#DigitalComm.getBFOFDM_oversampledGridSubcarriers-NTuple{4,Any}"><code>DigitalComm.getBFOFDM_oversampledGridSubcarriers</code></a> — <span class="docstring-category">Method</span>.</div><div><div><hr/><p>Returns the oversampled grid at the subcarrier level for BF-OFDM. In BF-OFDM as we use a nOFDM<em>nFBMC grid with nOFDM</em>δ allocated subcarrier per carriers (for a precodinng stage of size nOFDM), it can be usefull to get all the index of the allocated subcarrier per carrier. The output is a vector of the allocated subcarrier index in the oversampled frequency grid.</p><p><strong>–- Syntax</strong></p><p>subcarrierTx	= getCarrierFromSubcarriers(nOFDM,δ,fbmcCarriers)</p><p><strong>–- Input parameters</strong></p><ul><li>nOFDM	  : OFDM subcarrier size [Int]</li><li>δ		  : Rate factor [Float64]</li><li>fbmcCarriers : Vector of allocated carrier [Array{Int,L}], L &lt; nFBMC<em>nOFDM</em>δ</li></ul><p><strong>–- Output parameters</strong></p><ul><li>subcarrierTx : Vector of allocated carriers [Array{Int, L<em>nOFDM</em>δ  ]</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/Waveforms/BFOFDM/carrierManipulation.jl#L73-L87">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.getBFOFDM_subCarrierFromFBMCCarriers-NTuple{4,Any}" href="#DigitalComm.getBFOFDM_subCarrierFromFBMCCarriers-NTuple{4,Any}"><code>DigitalComm.getBFOFDM_subCarrierFromFBMCCarriers</code></a> — <span class="docstring-category">Method</span>.</div><div><div><hr/><p>Get the index of the oversampled carrier (i.e subcarriers index in the precoding field) based on the index of the allocated carriers. It is assumed that for each carriers, all subcarriers are enable (with orthogonality, i.e Nδ allocated subcarriers).</p><p><strong>–- Syntax</strong></p><p>subcarriers	= getBFOFDM_subCarrierFromFBMCCarriers(nFBMC,nOFDM,δ,fbmcCarriers)</p><p><strong>–- Input parameters</strong></p><ul><li>nFBMC	  : FBMC carrier size (number of carriers) [Int]</li><li>nOFDM	  : OFDM subcarrier size [Int]</li><li>δ		  : Rate factor [Float64]</li><li>fbmcCarriers : Vector of allocated carrier [Array{Int,L}], L &lt; nFBMC</li></ul><p><strong>–- Output parameters</strong></p><ul><li>subcarriers : Vector of allocated subcarriers [Array{Int, L δ ]</li></ul><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/Waveforms/BFOFDM/carrierManipulation.jl#L3-L17">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.StrucBFOFDM" href="#DigitalComm.StrucBFOFDM"><code>DigitalComm.StrucBFOFDM</code></a> — <span class="docstring-category">Type</span>.</div><div><div><hr/><p>BF-OFDM structure </p><p><strong>–- Syntax</strong></p><ul><li>nFBMC		: Number of carriers (PPN size)</li><li>nOFDM		: Number of subbcarriers per carrier (OFDM precoder size)</li><li>K			: Overlapping factor of the PPN </li><li>GI		: CP size of the precoder </li><li>δ			: Rate factor (compression factor)  </li><li>allocatedSubcarriers	: Vector of allocated subcarriers   </li><li>filterName  : Type of filter used (name)  </li><li>filterTaps  : FIR coefficient values </li><li>BT		: Gaussian parameters (if gaussian filter is used)</li><li>filterStopBand : DolphChebyshev attenuation factor (if DC is used)</li><li>fS		: Frqeuency spreading coefficients (if FS filter is used)</li><li>nFFT		: Equivalent OFDM FFT size </li><li>nCP		: Equivalent OFDM CP size </li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/Waveforms/BFOFDM/bfofdmSigGen.jl#L4-L23">source</a></section><h2><a class="nav-anchor" id="FBMC-1" href="#FBMC-1">FBMC</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.fbmcSigGen-NTuple{4,Any}" href="#DigitalComm.fbmcSigGen-NTuple{4,Any}"><code>DigitalComm.fbmcSigGen</code></a> — <span class="docstring-category">Method</span>.</div><div><div><hr/><p>Generate a FBMC-OQAM signal in time domain, based on input complex matrix (before OQAM processing) and FBMC parameters.</p><p>Transmitter is based on Polyphase Network implementation, with PHYDIAS filter (parametrized by overlapping factor).</p><p><strong>–- Syntax</strong></p><p>fbmcSigGen(qamMat,nFFT,K,allocatedSubcarriers)</p><p><strong>–- Input parameters</strong></p><ul><li>qamMat	: Complex QAM Time-Frequency matrix [Array{Complex{Float64}}]</li><li>nFFT		: FFT size  [Int]</li><li>K			: Overlapping factor [Int] </li><li>allocatedSubcarriers	: Vector of allocated subcarriers [Array{Int}]</li></ul><p><strong>–- Output parameters</strong></p><ul><li>sigId		: Complex baseband signal in time domain [Array{Complex{Float64}},nbEch]; nbEch = (2<em>nbSymb-1)</em>nFFT<em>/2+nFFT</em>K)</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/Waveforms/FBMC/fbmcSigGen.jl#L130-L146">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.getFBMCFilter-Tuple{Any,Any}" href="#DigitalComm.getFBMCFilter-Tuple{Any,Any}"><code>DigitalComm.getFBMCFilter</code></a> — <span class="docstring-category">Method</span>.</div><div><div><hr/><p>Returns the PHYDIAS time domain impulse response of desired FBMC filter parametrized by its overlapping factor and FFT size</p><p><strong>–- Syntax</strong></p><p>p = getFBMCFilter(K,nFFT,type);</p><p><strong>–- Input parameters</strong></p><ul><li>K	  : Overlapping factor</li><li>nFFT: FFT size </li></ul><p><strong>–- Output parameters</strong></p><ul><li>p	  : FBMC time impulse response </li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/Waveforms/FBMC/fbmcSigGen.jl#L74-L86">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.initFBMC-Tuple{Any,Any,Any}" href="#DigitalComm.initFBMC-Tuple{Any,Any,Any}"><code>DigitalComm.initFBMC</code></a> — <span class="docstring-category">Method</span>.</div><div><div><hr/><p>Initiate FBMC structure </p><p><strong>–- Syntax</strong></p><p>fbmc = initFBMC(nFFT,K,allocatedSubcarriers)</p><p><strong>–- Input parameters</strong></p><ul><li>nFFT	  : FFT size </li><li>K		  : Overlapping factor </li><li>allocatedSubcarriers	: Vector of allocated subcarriers [Array{Int}]</li></ul><p><strong>–- Output parameters</strong></p><ul><li>fbmc	  : FBMC structure [StrucFBMC]</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/Waveforms/FBMC/fbmcSigGen.jl#L17-L31">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.oqamMapping-Tuple{Any}" href="#DigitalComm.oqamMapping-Tuple{Any}"><code>DigitalComm.oqamMapping</code></a> — <span class="docstring-category">Method</span>.</div><div><div><hr/><p>Apply OQAM pre-processing to incoming matrix qamMat of size nbSubcarriers x nbSymb</p><p><strong>–- Syntax</strong></p><p>oqamMat = oqamConversion(qamMat)</p><p><strong>–- Input parameters</strong></p><ul><li>qamMat : Input complex qam Matrix [Array{Complex{Float64,nbSubcarriers,nbSymb}}]</li></ul><p><strong>–- Output parameters</strong></p><ul><li>oqamMat : OQAM matrix (pure real and pure imag. alterns) [Array{Complex{Float64,nbSubcarriers,nbSymb*2}}]</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/Waveforms/FBMC/fbmcSigGen.jl#L40-L51">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.fbmcSigDecode-NTuple{4,Any}" href="#DigitalComm.fbmcSigDecode-NTuple{4,Any}"><code>DigitalComm.fbmcSigDecode</code></a> — <span class="docstring-category">Method</span>.</div><div><div><hr/><p>Demodulate FBMC waveform based on the dual operation of fbmcSigGen</p><p>FBMC is parametrized by its FFT size, its cyclic prefix length (in samples) and the allocSubcarriers vector</p><p><strong>Syntax</strong></p><p>sigId	= fbmcSigDecode(sigRx,nFFT,K,allocSubcarriers)</p><p><strong>–-  Input parameters</strong></p><ul><li>sigRx	  : Time domain FBMC signal  [Array{Complex{Float64},nbEch}]</li><li>nFFT	  : FFT size [Int]</li><li>K		  : Overlapping factor [Int]</li></ul><p>allocSubcarriers : Vector of index of allocated subcarriers [Array{Int,nbSubcarriers}]</p><p><strong>–-  Output parameters</strong></p><ul><li>qamMat  : Time frequency matrix : [Array{Complex{Float64},nbSubcarriers,nbSymb}]</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/Waveforms/FBMC/fbmcSigDecode.jl#L35-L52">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.oqamDemapping-Tuple{Any}" href="#DigitalComm.oqamDemapping-Tuple{Any}"><code>DigitalComm.oqamDemapping</code></a> — <span class="docstring-category">Method</span>.</div><div><div><hr/><p>Apply OQAM demapping to incoming OQAM matrix qamMat of size nbSubcarriers x 2nbSymb</p><p><strong>–- Syntax</strong></p><p>qamMat = oqamDemapping(qamMat)</p><p><strong>–- Input parameters</strong></p><ul><li>oqamMat : OQAM matrix (pure real and pure imag. alterns) [Array{Complex{Float64,nbSubcarriers,nbSymb*2}}]</li></ul><p><strong>–- Output parameters</strong></p><ul><li>qamMat : Output complex qam Matrix [Array{Complex{Float64,nbSubcarriers,nbSymb}}]</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/Waveforms/FBMC/fbmcSigDecode.jl#L1-L13">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.StrucFBMC" href="#DigitalComm.StrucFBMC"><code>DigitalComm.StrucFBMC</code></a> — <span class="docstring-category">Type</span>.</div><div><div><hr/><p>FBMC waveform structure</p><p><strong>–- Syntax</strong></p><ul><li>nFFT	  : FFT size </li><li>K		  : Overlapping factor </li><li>allocatedSubcarriers	: Vector of allocated subcarriers [Array{Int}]</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/Waveforms/FBMC/fbmcSigGen.jl#L1-L11">source</a></section><h2><a class="nav-anchor" id="OFDM-1" href="#OFDM-1">OFDM</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.initOFDM-Tuple{Any,Any,Any}" href="#DigitalComm.initOFDM-Tuple{Any,Any,Any}"><code>DigitalComm.initOFDM</code></a> — <span class="docstring-category">Method</span>.</div><div><div><hr/><p>Create OFDM structure </p><p><strong>–- Syntax</strong></p><p>ofdm	= initOFDM(nFFT,nCP,allocatedSubcarriers)</p><p><strong>–- Input parameters</strong></p><ul><li>nFFT	  : FFT size [Int]</li><li>nCP	  : Cyclic prefix size [Int]</li><li>allocatedSubcarrier	: Vector of allocated subbcarriers [Array{Int}]</li></ul><p><strong>–- Output parameters</strong></p><ul><li>ofdm	  : OFDM structure [StrucOFDM] </li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/Waveforms/OFDM/ofdmSigGen.jl#L17-L31">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.ofdmSigGen!-NTuple{5,Any}" href="#DigitalComm.ofdmSigGen!-NTuple{5,Any}"><code>DigitalComm.ofdmSigGen!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><hr/><p>Populate a OFDM signal in time domain based on input T/F matrix and OFDM parameters</p><p>qamMat is a complex symbol matrix (for instance QPSK) of size length(allocatedSubcarriers) x nbSymb </p><p>The output signal in time domain is of size (nFFT+nCP)xnbSymb.</p><p><strong>–- Syntax</strong></p><p>ofdmSigGen!(sigId,qamMat,nFFT,nCP,allocatedSubcarriers)</p><p><strong>–- Input parameters</strong></p><ul><li>sigId	  : Signal in time domain [Array{Complex{Float64}},(nFFT+nCP)xnbSymb]</li><li>qamMat  : Complex T/F matrix to map [Array{Float64},length(allocatedSubcarriers),nbSymb]</li><li>nFFT	  : FFT size [Int] </li><li>nCP	  : Cylic prefix size [Int] </li><li>allocatedSubcarrier	: Vector of allocated subbcarriers [Array{Int}]</li></ul><p><strong>–- Output parameters</strong></p><ul><li>[]</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/Waveforms/OFDM/ofdmSigGen.jl#L67-L87">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.ofdmSigGen!-Tuple{Any,Any,DigitalComm.StrucOFDM}" href="#DigitalComm.ofdmSigGen!-Tuple{Any,Any,DigitalComm.StrucOFDM}"><code>DigitalComm.ofdmSigGen!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><hr/><p>Populate a  OFDM signal in time domain based on input T/F matrix and OFDM structure  </p><p>qamMat is a complex symbol matrix (for instance QPSK) of size length(allocatedSubcarriers) x nbSymb </p><p>The output signal in time domain is of size (nFFT+nCP)xnbSymb.</p><p><strong>–- Syntax</strong></p><p>ofdmSigGen!(sigId,qamMat,nFFT,nCP,allocatedSubcarriers)</p><p><strong>–- Input parameters</strong></p><ul><li>sigId	  : Signal in time domain [Array{Complex{Float64}},(nFFT+nCP)xnbSymb]</li><li>qamMat  : Complex T/F matrix to map [Array{Float64},length(allocatedSubcarriers),nbSymb]</li><li>ofdm	  : OFDM structure [StrucOFDM]</li></ul><p><strong>–- Output parameters</strong></p><ul><li>[]</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/Waveforms/OFDM/ofdmSigGen.jl#L133-L151">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.ofdmSigGen-NTuple{4,Any}" href="#DigitalComm.ofdmSigGen-NTuple{4,Any}"><code>DigitalComm.ofdmSigGen</code></a> — <span class="docstring-category">Method</span>.</div><div><div><hr/><p>Create OFDM signal in time domain based on input T/F matrix and OFDM parameters</p><p>qamMat is a complex symbol matrix (for instance QPSK) of size length(allocatedSubcarriers) x nbSymb </p><p>The output signal in time domain is of size (nFFT+nCP)xnbSymb.</p><p><strong>–- Syntax</strong></p><p>sigId = ofdmSigGen(qamMat,nFFT,nCP,allocatedSubcarriers)</p><p><strong>–- Input parameters</strong></p><ul><li>qamMat  : Complex T/F matrix to map [Array{Float64},length(allocatedSubcarriers),nbSymb]</li><li>nFFT	  : FFT size [Int] </li><li>nCP	  : Cylic prefix size [Int] </li><li>allocatedSubcarrier	: Vector of allocated subbcarriers [Array{Int}]</li></ul><p><strong>–- Output parameters</strong></p><ul><li>sigId	  : Signal in time domain [Array{Complex{Float64}},(nFFT+nCP)xnbSymb]</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/Waveforms/OFDM/ofdmSigGen.jl#L40-L59">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.ofdmSigGen-Tuple{Any,DigitalComm.StrucOFDM}" href="#DigitalComm.ofdmSigGen-Tuple{Any,DigitalComm.StrucOFDM}"><code>DigitalComm.ofdmSigGen</code></a> — <span class="docstring-category">Method</span>.</div><div><div><hr/><p>Create OFDM signal in time domain based on input T/F matrix and OFDM structure  </p><p>qamMat is a complex symbol matrix (for instance QPSK) of size length(allocatedSubcarriers) x nbSymb </p><p>The output signal in time domain is of size (nFFT+nCP)xnbSymb.</p><p><strong>–- Syntax</strong></p><p>sigId = ofdmSigGen(qamMat,nFFT,nCP,allocatedSubcarriers)</p><p><strong>–- Input parameters</strong></p><ul><li>qamMat  : Complex T/F matrix to map [Array{Float64},length(allocatedSubcarriers),nbSymb]</li><li>ofdm	  : OFDM structure [StrucOFDM]</li></ul><p><strong>–- Output parameters</strong></p><ul><li>sigId	  : Signal in time domain [Array{Complex{Float64}},(nFFT+nCP)xnbSymb]</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/Waveforms/OFDM/ofdmSigGen.jl#L110-L126">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.ofdmSigDecode!-NTuple{5,Any}" href="#DigitalComm.ofdmSigDecode!-NTuple{5,Any}"><code>DigitalComm.ofdmSigDecode!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><strong>ofdmSigDecode!</strong></p><p>Decodes a time domain OFDM signal and populate the  T/F matrix with decoded QAM symbols</p><p><strong>–- Syntax</strong></p><p>ofdmSigDecode(qamRx,sigId,nFFT,nCP,allocSubcarriers);</p><p><strong>–-  Input parameters</strong></p><ul><li>qamRx  : Time frequency matrix : [Array{Complex{Float64},nbSubcarriers,nbSymb}]</li><li>sigId	  : OFDM signal in time domain [Array{Complex{Float64},nbEch}]  ,(nbEch	: Number of samples: nbSymb*(nFFT+nCp))</li><li>nFFT	  : FFT size [Int]</li><li>nCp	  : Cyclic prefix size (in samples) [Int]</li></ul><p>allocSubcarriers : Vector of index of allocated subcarriers [Array{Int,nbSubcarriers}]</p><p><strong>–-  Output parameters</strong></p><ul><li>[]</li></ul><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/Waveforms/OFDM/ofdmSigDecode.jl#L25-L40">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.ofdmSigDecode!-Tuple{Any,Any,DigitalComm.StrucOFDM}" href="#DigitalComm.ofdmSigDecode!-Tuple{Any,Any,DigitalComm.StrucOFDM}"><code>DigitalComm.ofdmSigDecode!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><strong>ofdmSigDecode!</strong></p><p>Decodes a time domain OFDM signal and returns a T/F matrix with decoded QAM symbols</p><p><strong>–- Syntax</strong></p><p>qamRx	= ofdmSigDecode!(qamRx,sigId,ofdm);</p><p><strong>–-  Input parameters</strong></p><ul><li>qamRx  : Time frequency matrix : [Array{Complex{Float64},nbSubcarriers,nbSymb}]</li><li>sigId	  : OFDM signal in time domain [Array{Complex{Float64},nbEch}]  ,(nbEch	: Number of samples: nbSymb*(nFFT+nCp))</li><li>ofdm	  : OFDM structure [StrucOFDM]</li></ul><p><strong>–-  Output parameters</strong></p><ul><li>[]</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/Waveforms/OFDM/ofdmSigDecode.jl#L75-L89">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.ofdmSigDecode-NTuple{4,Any}" href="#DigitalComm.ofdmSigDecode-NTuple{4,Any}"><code>DigitalComm.ofdmSigDecode</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><strong>ofdmSigDecode</strong></p><p>Decodes a time domain OFDM signal and returns a T/F matrix with decoded QAM symbols</p><p><strong>–- Syntax</strong></p><p>qamRx	= ofdmSigDecode(sigId,nFFT,nCP,allocSubcarriers);</p><p><strong>–-  Input parameters</strong></p><ul><li>sigId	  : OFDM signal in time domain [Array{Complex{Float64},nbEch}]  ,(nbEch	: Number of samples: nbSymb*(nFFT+nCp))</li><li>nFFT	  : FFT size [Int]</li><li>nCp	  : Cyclic prefix size (in samples) [Int]</li></ul><p>allocSubcarriers : Vector of index of allocated subcarriers [Array{Int,nbSubcarriers}]</p><p><strong>–-  Output parameters</strong></p><ul><li>qamRx  : Time frequency matrix : [Array{Complex{Float64},nbSubcarriers,nbSymb}]</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/Waveforms/OFDM/ofdmSigDecode.jl#L1-L16">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.ofdmSigDecode-Tuple{Any,DigitalComm.StrucOFDM}" href="#DigitalComm.ofdmSigDecode-Tuple{Any,DigitalComm.StrucOFDM}"><code>DigitalComm.ofdmSigDecode</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><strong>ofdmSigDecode</strong></p><p>Decodes a time domain OFDM signal and returns a T/F matrix with decoded QAM symbols</p><p><strong>–- Syntax</strong></p><p>qamRx	= ofdmSigDecode(sigId,ofdm);</p><p><strong>–-  Input parameters</strong></p><ul><li>sigId	  : OFDM signal in time domain [Array{Complex{Float64},nbEch}]  ,(nbEch	: Number of samples: nbSymb*(nFFT+nCp))</li><li>ofdm	  : OFDM structure [StrucOFDM]</li></ul><p><strong>–-  Output parameters</strong></p><ul><li>qamRx  : Time frequency matrix : [Array{Complex{Float64},nbSubcarriers,nbSymb}]</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/Waveforms/OFDM/ofdmSigDecode.jl#L57-L70">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.StrucOFDM" href="#DigitalComm.StrucOFDM"><code>DigitalComm.StrucOFDM</code></a> — <span class="docstring-category">Type</span>.</div><div><div><hr/><p>Structure for OFDM</p><p><strong>–- Syntax</strong></p><ul><li>nFFT		: FFT size [Int] </li><li>nCP		: Cyclic prefix size [Int] </li><li>allocatedSubcarriers	: Vector of allocated subbcarriers [Array{Int}]</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/Waveforms/OFDM/ofdmSigGen.jl#L1-L10">source</a></section><h2><a class="nav-anchor" id="SC-FDMA-1" href="#SC-FDMA-1">SC-FDMA</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.initUFOFDM-Tuple{Any,Any,Any}" href="#DigitalComm.initUFOFDM-Tuple{Any,Any,Any}"><code>DigitalComm.initUFOFDM</code></a> — <span class="docstring-category">Method</span>.</div><div><div><hr/><p>Create UF-OFDM structure</p><p><strong>–- Syntax</strong></p><p>ufofdm	= initUFOFDM(nFFT,L,allocatedSubcarriers;sizeRB=12,applyPD=1,attenuation=40)</p><p><strong>–- Input parameters</strong></p><ul><li>nFFT		: FFT size [Int] </li><li>L			: Filter size [Int]</li><li>allocatedSubcarriers	: Vector of allocated subbcarriers [Array{Int}] </li><li>sizeRB	: Carrier size in terms of subcarrier (often 12)  [Array{Int}]</li><li>applyPD	: Apply Pre-distortion at Tx stage (default 1, 0 : not applied) [Int=0 or 1] </li><li>attenuation : dolphChebyshev filter attenation </li><li>filterTaps  : Filter impulse response coefficient [Array{Float64}]- </li></ul><p><strong>–- Output parameters</strong></p><ul><li>ufofdm	: UF-OFDM structure [StrucUFOFDM] </li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/Waveforms/UFOFDM/ufofdmSigGen.jl#L26-L44">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.ufofdmSigGen-NTuple{4,Any}" href="#DigitalComm.ufofdmSigGen-NTuple{4,Any}"><code>DigitalComm.ufofdmSigGen</code></a> — <span class="docstring-category">Method</span>.</div><div><div><hr/><p>Apply Universal Filtered Orthogonal Frequency Division Multiplexing (UF-OFDM) to the time frequency matrix qamMat and returns a time domain UF-OFDM signal [1,2]</p><p>ufofdm is parametrized by its FFT size, the filter length (in samples) and the allocatedSubcarriers vector. Optional parameters are carrier size in subcarrier (by default RB size which is 12) Dolph-Chebyshev window attenuation (40) and predistortion application (set to 1)</p><p><strong>–- Syntax</strong></p><p>sigId	= genereSignalufofdm(qamMat,nFFT,nCp,allocatedSubcarriers;sizeRB=12,applyPD=1,attenuation=40)</p><p><strong>–-  Input parameters</strong></p><ul><li>qamMat  : Time frequency matrix : [Array{Complex{Float64},nbSubcarriers,nbSymb}]</li><li>nbSymb			: Number of ufofdm symbol tro be transmitted</li><li>nbSubcarriers	: Number of allocated subcarriers (shall be &lt; nFFT)</li><li>nFFT	  : FFT size [Int]</li><li>L		  : Dolph Chebyshev filter length [Int]</li><li>allocatedSubcarriers : Vector of index of allocated subcarriers [Array{Int,nbSubcarriers}]</li><li>sizeRB  : Carrier size in subcarriers (default : LTE RB size: 12) [Int]</li><li>applyPD : Filter shape compensation (enabled by default) [Int]</li><li>attenuation : DC filter attenation in dB (default: 90) [Float64]</li><li>filterTaps : Filter coefficient (default empty and recreated)</li><li>pdCoeffs	  : Predistortion  Filter coefficient (default empty and recreated)</li></ul><p><strong>–-  Output parameters</strong></p><ul><li>sigId	  : ufofdm signal in time domain [Array{Complex{Float64},nbEch}]</li></ul><p><strong>References</strong></p><ul><li>[1] R. Gerzaguet and al. The 5G candidate waveform race: a comparison of complexity and performance. EURASIP Journal on Wireless Communications and Networking, 2017</li><li>[2] V. Vakilian and al: Universal-filtered multi-carrier technique for wireless systems beyond LTE. Proc. IEEE Globecom Workshops (GC Wkshps), 2013</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/Waveforms/UFOFDM/ufofdmSigGen.jl#L59-L86">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.ufofdmSigGen-Tuple{Any,DigitalComm.StrucUFOFDM}" href="#DigitalComm.ufofdmSigGen-Tuple{Any,DigitalComm.StrucUFOFDM}"><code>DigitalComm.ufofdmSigGen</code></a> — <span class="docstring-category">Method</span>.</div><div><div><hr/><p>Apply Universal Filtered Orthogonal Frequency Division Multiplexing (UF-OFDM) to the time frequency matrix qamMat and returns a time domain UF-OFDM signal [1,2]</p><p>ufofdm is parametrized by its FFT size, the filter length (in samples) and the allocatedSubcarriers vector. Optional parameters are carrier size in subcarrier (by default RB size which is 12) Dolph-Chebyshev window attenuation (40) and predistortion application (set to 1)</p><p><strong>–- Syntax</strong></p><p>sigId	= genereSignalufofdm(qamMat,ufofdm);</p><p><strong>–-  Input parameters</strong></p><ul><li>qamMat  : Time frequency matrix : [Array{Complex{Float64},nbSubcarriers,nbSymb}]</li><li>ufofdm  : UF-OFDM structure [StrucUFOFDM]</li></ul><p><strong>–-  Output parameters</strong></p><ul><li>sigId	  : ufofdm signal in time domain [Array{Complex{Float64},nbEch}]</li></ul><p><strong>References</strong></p><ul><li>[1] R. Gerzaguet and al. The 5G candidate waveform race: a comparison of complexity and performance. EURASIP Journal on Wireless Communications and Networking, 2017</li><li>[2] V. Vakilian and al: Universal-filtered multi-carrier technique for wireless systems beyond LTE. Proc. IEEE Globecom Workshops (GC Wkshps), 2013</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/Waveforms/UFOFDM/ufofdmSigGen.jl#L227-L245">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.convT-Union{Tuple{T}, Tuple{Array{T,N} where N,Array{T,N} where N}} where T" href="#DigitalComm.convT-Union{Tuple{T}, Tuple{Array{T,N} where N,Array{T,N} where N}} where T"><code>DigitalComm.convT</code></a> — <span class="docstring-category">Method</span>.</div><div><div><hr/><p>Perform time domain naive convolution. For UF-OFDM, size of filter is small so doing it in frequency domain is not appropriate</p><p><strong>–- Syntax</strong></p><p>c = convT(a,b);</p><p><strong>–- Input parameters</strong></p><ul><li>a	  : First signal </li><li>b	  : Second signal </li></ul><p><strong>–- Output parameters</strong></p><ul><li>c	  : a * b </li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/Waveforms/UFOFDM/ufofdmSigGen.jl#L151-L164">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.StrucUFOFDM" href="#DigitalComm.StrucUFOFDM"><code>DigitalComm.StrucUFOFDM</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Structure for UFOFDM</p><p><strong>–- Syntax</strong></p><ul><li>nFFT		: FFT size [Int] </li><li>L			: Filter size [Int]</li><li>allocatedSubcarriers	: Vector of allocated subbcarriers [Array{Int}] </li><li>sizeRB	: Carrier size in terms of subcarrier (often 12)  [Array{Int}]</li><li>applyPD	: Apply Pre-distortion at Tx stage (default 1, 0 : not applied) [Int=0 or 1] </li><li>attenuation : dolphChebyshev filter attenation </li><li>filterTaps  : Filter impulse response coefficient [Array{Float64}]</li><li>pd		  : PD coefficients [Array{Complex{Float64}}]</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/Waveforms/UFOFDM/ufofdmSigGen.jl#L1-L15">source</a></section><h2><a class="nav-anchor" id="UF-OFDM-1" href="#UF-OFDM-1">UF-OFDM</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.initSCFDMA-NTuple{4,Any}" href="#DigitalComm.initSCFDMA-NTuple{4,Any}"><code>DigitalComm.initSCFDMA</code></a> — <span class="docstring-category">Method</span>.</div><div><div><hr/><p>Create SCFDMA structure </p><p><strong>–- Syntax</strong></p><p>ofdm	= initSCFDMA(nFFT,nCP,allocatedSubcarriers)</p><p><strong>–- Input parameters</strong></p><ul><li>nFFT	  : FFT size [Int]</li><li>nCP	  : Cyclic prefix size [Int]</li><li>allocatedSubcarrier	: Vector of allocated subbcarriers [Array{Int}]</li><li>sizeDFT	: Size of DFT precoder (classic value is 12) [Int]</li></ul><p><strong>–- Output parameters</strong></p><ul><li>scfdma: SCFDMA structure [StrucSCFDMA] </li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/Waveforms/SCFDMA/scfdmaSigGen.jl#L20-L34">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.scfdmaSigGen-NTuple{5,Any}" href="#DigitalComm.scfdmaSigGen-NTuple{5,Any}"><code>DigitalComm.scfdmaSigGen</code></a> — <span class="docstring-category">Method</span>.</div><div><div><hr/><p>Create SCFDMA signal in time domain based on input T/F matrix and SCFDMA parameters. SCFDMA apply a precoder before the IFFT at the transmitter side in order to lower the signal fluctuation</p><p>qamMat is a complex symbol matrix (for instance QPSK) of size length(allocatedSubcarriers) x nbSymb </p><p>The output signal in time domain is of size (nFFT+nCP)xnbSymb.</p><p><strong>–- Syntax</strong></p><p>sigId = scfdmaSigGen(qamMat,nFFT,nCP,allocatedSubcarriers)</p><p><strong>–- Input parameters</strong></p><ul><li>qamMat  : Complex T/F matrix to map [Array{Float64},length(allocatedSubcarriers),nbSymb]</li><li>nFFT	  : FFT size [Int] </li><li>nCP	  : Cylic prefix size [Int] </li><li>allocatedSubcarrier	: Vector of allocated subbcarriers [Array{Int}]</li><li>sizeDFT	: Size of DFT precoder (classic value is 12) [Int]</li></ul><p><strong>–- Output parameters</strong></p><ul><li>sigId	  : Signal in time domain [Array{Complex{Float64}},(nFFT+nCP)xnbSymb]</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/Waveforms/SCFDMA/scfdmaSigGen.jl#L44-L63">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.scfdmaPostProcessing-Tuple{Any,Any}" href="#DigitalComm.scfdmaPostProcessing-Tuple{Any,Any}"><code>DigitalComm.scfdmaPostProcessing</code></a> — <span class="docstring-category">Method</span>.</div><div><div><hr/><p>Apply Post processing for SC-FDMA (i.e DFT post-processing stage). This function can be called if scfdmaSigDecode is called with post processing flag to 0 (if frequency egalisation is done for example)</p><p><strong>–- Syntax</strong></p><p>qamPost	  = scfdmaPostProcessing(qamMat,sizeDFT)</p><p><strong>–- Input parameters</strong></p><ul><li>qamMat  : T/F matrix after Rx FFT (and before Rx IDFT) [Array{Complex{Float64}},nbSubcarriers,nbSymb]</li><li>sizeDFT	: Precoder bloc size (often 12)</li></ul><p><strong>–- Output parameters</strong></p><ul><li>qamPost	: T/F matrix after IDFT processing [Array{Complex{Float64},nbSubcarriers,nbSymb}]</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/Waveforms/SCFDMA/scfdmaSigDecode.jl#L43-L55">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.scfdmaSigDecode" href="#DigitalComm.scfdmaSigDecode"><code>DigitalComm.scfdmaSigDecode</code></a> — <span class="docstring-category">Function</span>.</div><div><div><hr/><p>Apply SCFDMA demodulator to input signal and returns the T/F QAM matrix</p><p><strong>–- Syntax</strong></p><p>qamRx	= scfdmaSigDecode(sigId,nFFT,nCP,allocSubcarriers,sizeDFT);</p><p><strong>–- Input parameters</strong></p><p><strong>–-  Input parameters</strong></p><ul><li>sigId	  : SCFDMA signal in time domain [Array{Complex{Float64},nbEch}]</li><li>nFFT	  : FFT size [Int]</li><li>nCp	  : Cyclic prefix size (in samples) [Int]</li><li>allocSubcarriers : Vector of index of allocated subcarriers [Array{Int,nbSubcarriers}]</li><li>sizeDFT	: Post processing size (DFT size)</li><li>doPostProcessing : Do the post processing stage (IDFT): Default 1. In some case, we need the raw data (i.e data before postprocessing stage) such as in channel equalisation. In this case, the post processing should be done in a separate step (with the call of scfdmaPostProcessing function)</li></ul><p><strong>–-  Output parameters</strong></p><ul><li>qamRx  : Time frequency matrix : [Array{Complex{Float64},nbSubcarriers,nbSymb}]</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/Waveforms/SCFDMA/scfdmaSigDecode.jl#L1-L19">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.scfdmaSigDecode" href="#DigitalComm.scfdmaSigDecode"><code>DigitalComm.scfdmaSigDecode</code></a> — <span class="docstring-category">Function</span>.</div><div><div><hr/><p>Apply SCFDMA demodulator to input signal and returns the T/F QAM matrix</p><p><strong>–- Syntax</strong></p><p>qamRx	= scfdmaSigDecode(sigId,nFFT,nCP,allocSubcarriers,sizeDFT);</p><p><strong>–- Input parameters</strong></p><p><strong>–-  Input parameters</strong></p><ul><li>sigId	  : SCFDMA signal in time domain [Array{Complex{Float64},nbEch}]</li><li>scfdma  : SCFDMA structure [StrucSCFDMA]</li><li>doPostProcessing : Do the post processing stage (IDFT): Default 1. In some case, we need the raw data (i.e data before postprocessing stage) such as in channel equalisation. In this case, the post processing should be done in a separate step (with the call of scfdmaPostProcessing function)</li></ul><p><strong>–-  Output parameters</strong></p><ul><li>qamRx  : Time frequency matrix : [Array{Complex{Float64},nbSubcarriers,nbSymb}]</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/Waveforms/SCFDMA/scfdmaSigDecode.jl#L71-L85">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.StrucSCFDMA" href="#DigitalComm.StrucSCFDMA"><code>DigitalComm.StrucSCFDMA</code></a> — <span class="docstring-category">Type</span>.</div><div><div><hr/><p>Structure for SCFDMA</p><p><strong>–- Syntax</strong></p><ul><li>nFFT		: FFT size [Int] </li><li>nCP		: Cyclic prefix size [Int] </li><li>allocatedSubcarriers	: Vector of allocated subbcarriers [Array{Int}]</li><li>sizeDFT	: Size of DFT precoder (classic value is 12) [Int]</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/Waveforms/SCFDMA/scfdmaSigGen.jl#L1-L12">source</a></section><h2><a class="nav-anchor" id="WOLA-1" href="#WOLA-1">WOLA</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.initWOLA-NTuple{7,Any}" href="#DigitalComm.initWOLA-NTuple{7,Any}"><code>DigitalComm.initWOLA</code></a> — <span class="docstring-category">Method</span>.</div><div><div><hr/><p>Create and initiate a WOLA waveform structure </p><p><strong>–- Syntax</strong></p><p>wola = initWOLA(nFFT,nCP,allocatedSubcarriers,winFuncTx,winLengthTx,winFuncRx,winLengthRx;windowTx=[],windowRx=[])</p><p><strong>–- Input parameters</strong></p><ul><li>nFFT	  : FFT size [Int] </li><li>nCP	  : CP size [Int] </li><li>allocatedSubcarriers	: Vector of allocated subcarriers [Array{Int}] </li><li>winFuncTx	  : Name of window used @Tx </li><li>winLengthTx : Size of window @Tx </li><li>winFuncRx	  : Name of window used @Rx </li><li>winLengthRx : Size of window @Rx </li><li>windowTx	  : Coefficient of Tx window. By default it is empty. To force a given window, populate this vector. If let empty, the window will be created based on winLengthTx and winFuncTx</li><li>windowRx	  : Coefficient of Rx window. By default it is empty. To force a given window, populate this vector. If let empty, the window will be created based on winLengthRx and winFuncRx</li></ul><p><strong>–- Output parameters</strong></p><ul><li>wola		  : Waveform structure</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/Waveforms/WOLA/wolaSigGen.jl#L22-L42">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.wolaSigGen" href="#DigitalComm.wolaSigGen"><code>DigitalComm.wolaSigGen</code></a> — <span class="docstring-category">Function</span>.</div><div><div><hr/><p>Apply Weighted Overlap and Add Orthogonal Frequency Division Multiplexing (WOLA-OFDM) to the time frequency matrix qamMat and returns a time domain OFDM signal OFDM is parametrized by its FFT size, its cyclic prefix length (in samples) and the allocSubcarriers vector. The WOLA part is parametrized by the window applied at each beginning and ending of symbols. The window size can be (and is likely to be) higher than the length of the CP and pure OFDM compatibility is ensured by overlapping the symbols. The interested reader can refer to [1] [2] and [3] for WOLA principle description.</p><p><strong>–-</strong></p><p><strong>Syntax</strong></p><p>sigId	= wolaSigGen(qamMat,nFFT,nCP,allocSubcarriers,winFunc,winLength=0)</p><p><strong>–-  Input parameters</strong></p><ul><li>qamMat  : Time frequency matrix : [Array{Complex{Float64},nbSubcarriers,nbSymb}]</li><li>nbSymb			: Number of OFDM symbol tro be transmitted</li><li>nbSubcarriers	: Number of allocated subcarriers (shall be &lt; nFFT)</li><li>nFFT	  : FFT size [Int]</li><li>nCP	  : Cyclic prefix size (in samples) [Int]</li><li>allocSubcarriers : Vector of index of allocated subcarriers [Array{Int,nbSubcarriers}]</li><li>winFunc : Type of window. Can be a string of supported window or directly the window taps.</li><li>winLength : Length of window. This parameter is not used if winFunc is an array of the window tap.</li></ul><p><strong>–-  Output parameters</strong></p><ul><li>sigId	  : WOLA-OFDM signal in time domain [Array{Complex{Float64},nbEch}]. nbEch	: Number of samples: nbSymb*(nFFT+nCP)</li></ul><p><strong>–-</strong></p><p><strong>Supported window</strong></p><p>-	&quot;Triangle&quot;		: Triangle window -	&quot;srrc&quot;			: Square Root Raised Cosine -	&quot;Meyer&quot;			: Meyer window (See [1])</p><p><strong>–-</strong></p><p><strong>References</strong></p><ul><li>[1] R. Zayani, Y. Medjahdi, H. Shaiek and D. Roviras, &quot;WOLA-OFDM: A Potential Candidate for Asynchronous 5G,&quot; 2016.</li><li>[2] Y. Medjahdi and al, &quot;On the road to 5G: Comparative study of Physical layer in MTC context&quot;, 2017.</li><li>[3] R. Gerzaguet and al, &quot;Comparison of Promising Candidate Waveforms for 5G: WOLA-OFDM Versus BF-OFDM&quot;, 2017.</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/Waveforms/WOLA/wolaSigGen.jl#L77-L109">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.wolaSigDecode" href="#DigitalComm.wolaSigDecode"><code>DigitalComm.wolaSigDecode</code></a> — <span class="docstring-category">Function</span>.</div><div><div><hr/><p>Apply WOLA-OFDM demodulator to input signal and returns the T/F QAM matrix</p><p><strong>–-</strong></p><p>Syntax qamRx	= wolaSigDecode(sigId,nFFT,nCP,allocSubcarriers);</p><p><strong>–-  Input parameters</strong></p><ul><li>sigId	  : OFDM signal in time domain [Array{Complex{Float64},nbEch}]</li><li>nbEch	: Number of samples: nbSymb*(nFFT+nCP)</li><li>nFFT	  : FFT size [Int]</li><li>nCP	  : Cyclic prefix size (in samples) [Int]</li><li>allocSubcarriers : Vector of index of allocated subcarriers [Array{Int,nbSubcarriers}]</li><li>winLengthTx	: Window size @Tx side (FFT rotation)</li><li>doTailBiting	: Do tail biting approach (by default 1) [Int]</li><li>winFunc : Type of window. Can be a string of supported window or directly the window taps.</li><li>winLength : Length of window. This parameter is not used if winFunc is an array of the window tap.</li></ul><p><strong>–-  Output parameters</strong></p><ul><li>qamMat  : Time frequency matrix : [Array{Complex{Float64},nbSubcarriers,nbSymb}]</li></ul><p><strong>–-</strong></p><p><strong>Supported window</strong></p><p>-	&quot;Triangle&quot;		: Triangle window -	&quot;srrc&quot;			: Square Root Raised Cosine -	&quot;Meyer&quot;			: Meyer window (See [1])</p><p><strong>–-</strong></p><p><strong>References</strong></p><ul><li>[1] R. Zayani, Y. Medjahdi, H. Shaiek and D. Roviras, &quot;WOLA-OFDM: A Potential Candidate for Asynchronous 5G,&quot; 2016.</li><li>[2] Y. Medjahdi and al, &quot;On the road to 5G: Comparative study of Physical layer in MTC context&quot;, 2017.</li><li>[3] R. Gerzaguet and al, &quot;Comparison of Promising Candidate Waveforms for 5G: WOLA-OFDM Versus BF-OFDM&quot;, 2017.</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/Waveforms/WOLA/wolaSigDecode.jl#L1-L32">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DigitalComm.StrucWOLA" href="#DigitalComm.StrucWOLA"><code>DigitalComm.StrucWOLA</code></a> — <span class="docstring-category">Type</span>.</div><div><div><hr/><p>WOLA waveform structure </p><p><strong>–- Syntax</strong></p><ul><li>nFFT	  : FFT size [Int] </li><li>nCP	  : CP size [Int] </li><li>allocatedSubcarriers	: Vector of allocated subcarriers [Array{Int}] </li><li>windowTx	: Window used @ transmitter side </li><li>windowRx	: Window used @ recevier side </li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/RGerzaguet/DigitalComm.jl/blob/cf02e83556ebafe773aef37575b98a6eb5b4727c/src/Waveforms/WOLA/wolaSigGen.jl#L1-L13">source</a></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Introduction to DigitalComm</span></a><a class="next" href="../Examples/example_AWGN/"><span class="direction">Next</span><span class="title">Transmission of xQAM with additive white Gaussian noise</span></a></footer></article></body></html>
