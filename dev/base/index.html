<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Function list · DigitalComm.jl</title><meta name="title" content="Function list · DigitalComm.jl"/><meta property="og:title" content="Function list · DigitalComm.jl"/><meta property="twitter:title" content="Function list · DigitalComm.jl"/><meta name="description" content="Documentation for DigitalComm.jl."/><meta property="og:description" content="Documentation for DigitalComm.jl."/><meta property="twitter:description" content="Documentation for DigitalComm.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="DigitalComm.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">DigitalComm.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction to DigitalComm</a></li><li class="is-active"><a class="tocitem" href>Function list</a><ul class="internal"><li><a class="tocitem" href="#Common-functions"><span>Common functions</span></a></li><li><a class="tocitem" href="#NRZI-Encoding"><span>NRZI Encoding</span></a></li><li><a class="tocitem" href="#Quadrature-Amplitude-Modulation"><span>Quadrature Amplitude Modulation</span></a></li><li><a class="tocitem" href="#Channels"><span>Channels</span></a></li><li><a class="tocitem" href="#Windows-and-filters"><span>Windows and filters</span></a></li><li class="toplevel"><a class="tocitem" href="#Waveforms"><span>Waveforms</span></a></li><li><a class="tocitem" href="#Common-functions-2"><span>Common functions</span></a></li><li><a class="tocitem" href="#BF-OFDM"><span>BF-OFDM</span></a></li><li><a class="tocitem" href="#FBMC"><span>FBMC</span></a></li><li><a class="tocitem" href="#OFDM"><span>OFDM</span></a></li><li><a class="tocitem" href="#SC-FDMA"><span>SC-FDMA</span></a></li><li><a class="tocitem" href="#UF-OFDM"><span>UF-OFDM</span></a></li><li><a class="tocitem" href="#WOLA"><span>WOLA</span></a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../Examples/example_AWGN/">Transmission of xQAM with additive white Gaussian noise</a></li><li><a class="tocitem" href="../Examples/example_BER/">Compute the theoretical BER for AWGN channel and various constellation size</a></li><li><a class="tocitem" href="../Examples/example_PSD/">Plotting PSD of several multicarrier waveforms</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Function list</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Function list</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaTelecom/DigitalComm.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/master/docs/src/base.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Function-overview"><a class="docs-heading-anchor" href="#Function-overview">Function overview</a><a id="Function-overview-1"></a><a class="docs-heading-anchor-permalink" href="#Function-overview" title="Permalink"></a></h1><h2 id="Common-functions"><a class="docs-heading-anchor" href="#Common-functions">Common functions</a><a id="Common-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Common-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.avgPower-Tuple{Any}" href="#DigitalComm.avgPower-Tuple{Any}"><code>DigitalComm.avgPower</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><hr/><p>Calculate the average power of the input signal  σ	= 1 / N Σ | x[n] | ^2 </p><p><strong>–- Syntax</strong></p><p>σ	= avgPower(x);</p><p><strong>–- Input parameters</strong></p><ul><li>x	  : Input signal [Array{Any}]</li></ul><p><strong>–- Output parameters</strong></p><ul><li>σ	  : Estimated power [Float64]</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/DigitalComm.jl#L140-L153">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.getSIR" href="#DigitalComm.getSIR"><code>DigitalComm.getSIR</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><hr/><p>Returns the Signal to interference ratio expressed in dB (or in linear) between a obersvation signal d(n) and a reference signal u(n) The ratio is expressed as 10*log10( E[ || d(n) - u(n) || / E[||u(n)||^2]  )  with E the expectation wrt to time  The 2 vectors d and u should have the same length L</p><p><strong>–- Syntax</strong></p><p>sir = getSIR( d, u , type=&quot;dB&quot;)</p><p><strong>–-  Input parameter</strong></p><ul><li>d	: Observation signal [Array{Any}]</li><li>u	: Reference signal [Array{Any}]	</li><li>type: Output unit [String]: &quot;dB&quot; or &quot;Linear&quot; (default, &quot;dB&quot;)</li></ul><p><strong>–- Output parameters</strong></p><ul><li>sir	: Signal to interference ratio in unit <code>type</code></li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/DigitalComm.jl#L93-L109">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.qFunc-Tuple{Any}" href="#DigitalComm.qFunc-Tuple{Any}"><code>DigitalComm.qFunc</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><hr/><p>Returns the Q function used for Bit error rate computation in digital system   Q(x)= 1/2 erfc(x/sqrt(2)) erfc is the Complexmplementary error function, i.e. the accurate version of 1-erf(x) for large x erfc is inherited from DSP</p><p><strong>–- Syntax</strong></p><p>y = qfunc(x)</p><p><strong>–- Input parameters</strong></p><ul><li>x: Input [Float64]</li></ul><p><strong>–- Output parameters</strong></p><ul><li>y: Q(x)[Float64] </li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/DigitalComm.jl#L71-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.Waveform" href="#DigitalComm.Waveform"><code>DigitalComm.Waveform</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><hr/><p>Abstract type gathering all waveform configuration </p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/DigitalComm.jl#L175-L180">source</a></section></article><h2 id="NRZI-Encoding"><a class="docs-heading-anchor" href="#NRZI-Encoding">NRZI Encoding</a><a id="NRZI-Encoding-1"></a><a class="docs-heading-anchor-permalink" href="#NRZI-Encoding" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.decodeNRZI" href="#DigitalComm.decodeNRZI"><code>DigitalComm.decodeNRZI</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">decodeNRZI(bits::AbstractVector, transitions::Symbol=:low)::AbstractVector</code></pre><p>Decode a  Non-Return-to-Zero Inverted (NRZI) encoded bit sequence. Expects a vector of bits, e.g. <code>[0, 1, 1, 0, 0, 1, 0, 1, 0, 1]</code>.</p><p><strong>Arguments</strong></p><ul><li><code>bits::AbstractVector</code>: Vector of bits to encode.</li><li><code>transitions::Symbol</code>: Symbol represented by a transition in the NRZI coded sequence (<code>:low</code>/<code>:high</code>). Defaults to <code>:low</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>decoded_bits::AbstractVector</code>: Vector of decoded bits. The first bit of the output depends on a value of a memory bit in the decoder. this value is set to <code>0</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; decoded_bits = decodeNRZI(Int32[1, 1, 1, 0, 1, 1], :low);

julia&gt; transpose(decoded_bits)
1×6 transpose(::Vector{Int32}) with eltype Int32:
 0  1  1  0  0  1</code></pre><p>The example below shows how the <code>transitions</code> argument affects the decoded bit sequence.</p><pre><code class="language-julia-repl hljs">julia&gt; decoded_bits = decodeNRZI(Int32[0, 1, 0, 0, 0, 1], :high);

julia&gt; transpose(decoded_bits)
1×6 transpose(::Vector{Int32}) with eltype Int32:
 0  1  1  0  0  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/NRZI.jl#L55-L90">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.encodeNRZI" href="#DigitalComm.encodeNRZI"><code>DigitalComm.encodeNRZI</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">encodeNRZI(bits::AbstractVector, transitions::Symbol=:low)::AbstractVector</code></pre><p>Map a bit sequence to Non-Return-to-Zero Inverted (NRZI) encoded bits. Expects a vector of bits, e.g. <code>[0, 1, 1, 0, 0, 1, 0, 1, 0, 1]</code>.</p><p><strong>Arguments</strong></p><ul><li><code>bits::AbstractVector</code>: Vector of bits to encode.</li><li><code>transitions::Symbol</code>: Symbol indicating the symbol to transition on (<code>:low</code>/<code>:high</code>). Defaults to <code>:low</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>encoded_bits::AbstractVector</code>: Vector of encoded bits.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; encoded_bits = encodeNRZI(Int32[0, 1, 1, 0, 0, 1], :low);

julia&gt; transpose(encoded_bits)
1×6 transpose(::Vector{Int32}) with eltype Int32:
 1  1  1  0  1  1</code></pre><p>The example below shows how the <code>transitions</code> argument affects the encoded bit sequence.</p><pre><code class="language-julia-repl hljs">julia&gt; encoded_bits = encodeNRZI(Int32[0, 1, 1, 0, 0, 1], :high);

julia&gt; transpose(encoded_bits)
1×6 transpose(::Vector{Int32}) with eltype Int32:
 0  1  0  0  0  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/NRZI.jl#L1-L35">source</a></section></article><h2 id="Quadrature-Amplitude-Modulation"><a class="docs-heading-anchor" href="#Quadrature-Amplitude-Modulation">Quadrature Amplitude Modulation</a><a id="Quadrature-Amplitude-Modulation-1"></a><a class="docs-heading-anchor-permalink" href="#Quadrature-Amplitude-Modulation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.genBitSequence" href="#DigitalComm.genBitSequence"><code>DigitalComm.genBitSequence</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><hr/><p>Create a binary sequence and return a buffer with nbBits bits The array is of type UInt8 with x00 or x01) If stated, randSeed controls the seed of the random generator</p><p><strong>–- Syntax</strong></p><pre><code class="nohighlight hljs">  genBitsequence(nbBits,randSeed=-1);</code></pre><p><strong>–- Input parameters</strong></p><ul><li>nbBits	: Number of bits to generate [Int]</li><li>randSeed	: Seed of random process (default -&gt; -1) [Int]</li></ul><p><strong>–- Output parameters</strong></p><ul><li>buffer	: Populated buffer [Array{UInt8}]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/genBitSequence.jl#L42-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.genBitSequence!" href="#DigitalComm.genBitSequence!"><code>DigitalComm.genBitSequence!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><hr/><p>Create a binary sequence and populate input buffer with bits The array is of type UInt8 with x00 or x01) If stated, randSeed controls the seed of the random generator</p><p><strong>–- Syntax</strong></p><pre><code class="nohighlight hljs">  genBitsequence!(buffer,nbBits,randSeed=-1);</code></pre><p><strong>–- Input parameters</strong></p><ul><li>buffer	: Buffer to populate [Array{UInt8,nbBits}]</li><li>nbBits	: Number of bits to generate [Int]</li><li>randSeed	: Seed of random process (default -&gt; -1, no seed is used)</li></ul><p><strong>–- Output parameters</strong></p><ul><li>buffer	: Populated buffer [Array{UInt8}]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/genBitSequence.jl#L13-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.genByteSequence" href="#DigitalComm.genByteSequence"><code>DigitalComm.genByteSequence</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><hr/><p>Create a byte sequence and return a populated  buffer with nbytes bytes The array </p><p><strong>–- Syntax</strong></p><pre><code class="nohighlight hljs">  genByteSequence(nbBytes,randSeed=-1);</code></pre><p><strong>–- Input parameters</strong></p><ul><li>nbBytes	: Number of byte to generate [Int]</li><li>randSeed	: Seed of random process (default -&gt; -1)</li></ul><p><strong>–- Output parameters</strong></p><ul><li>buffer	: Populated buffer [Array{UInt8}]</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/genBitSequence.jl#L102-L116">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.genByteSequence!" href="#DigitalComm.genByteSequence!"><code>DigitalComm.genByteSequence!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><hr/><p>Create a byte sequence and populate input buffer with nbytes bytes The array is of type UInt8 with x00 to xff If stated, randSeed controls the seed of the random generator</p><p><strong>–- Syntax</strong></p><pre><code class="nohighlight hljs">  genByteSequence!(buffer,nbBytes,randSeed=-1);</code></pre><p><strong>–- Input parameters</strong></p><ul><li>buffer	: Buffer to populate [Array{UInt8,nbByte}]</li><li>randSeed	: Seed of random process (default -&gt; -1)</li></ul><p><strong>–- Output parameters</strong></p><ul><li>buffer	: Populated buffer [Array{UInt8}]</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/genBitSequence.jl#L71-L86">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.bitMappingQAM!-Tuple{Any, Any, Any}" href="#DigitalComm.bitMappingQAM!-Tuple{Any, Any, Any}"><code>DigitalComm.bitMappingQAM!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><hr/><p>Quadrature Amplitude Modulation (QAM) function    Apply symbol mapping to a input binary sequence (of size 1xL) with constellation size M. 	Output is a vector (1xN) with N = L / log2(M) 	Conventional gray mapping is used. Output constellation is casted in float, with unitary average power,  	except when <code>unitaryPower</code> is set to false.  Supported constellation</p><ul><li>QPSK</li><li>16-QAM</li><li>64-QAM</li><li>256-QAM</li></ul><p><strong>–- Syntax</strong></p><p>bitMappingQAM!(qamMat,M,bitSeq)</p><p><strong>–- Input parameters</strong></p><ul><li>qamMat        : Complex Vector to populate of size length(bitSeq) / log2(M) [Array{Complex{Float64}}]</li><li>M	            : Modulation size (i.e from 4 to 256) such as bit per symbol is log2(M) [Int]</li><li>bitSeq        : Binary sequence to be transformed into QPSK symbols [Array{UInt8}]</li><li>unitaryPower  : Normalize output power if set to true (default is true).</li></ul><p><strong>–- Output parameters</strong></p><ul><li>[]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/bitMapping.jl#L1-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.bitMappingQAM-Tuple{Any, Any}" href="#DigitalComm.bitMappingQAM-Tuple{Any, Any}"><code>DigitalComm.bitMappingQAM</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><hr/><p>Quadrature Amplitude Modulation (QAM) function    Apply symbol mapping to a input binary sequence (of size 1xL) with constellation size M. 	Output is a vector (1xN) with N = L / log2(M) 	Conventional gray mapping is used. Output constellation is casted in float, with unitary average power  Supported constellation</p><ul><li>QPSK</li><li>16-QAM</li><li>64-QAM</li><li>256-QAM</li></ul><p><strong>–- Syntax</strong></p><p>qamMat =  bitMappingQAM(M,bitSeq)</p><p><strong>–- Input parameters</strong></p><ul><li>M			: Modulation size (i.e from 4 to 256) such as bit per symbol is log2(M) [Int]</li><li>bitSeq	: Binary sequence to be transformed into QPSK symbols [Array{UInt8}]</li></ul><p><strong>–- Output parameters</strong></p><ul><li>qamMat	: Complex Vector to populate of size length(bitSeq) / log2(M) [Array{Complex{Float64}}]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/bitMapping.jl#L175-L194">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.bitDemappingQAM!-Tuple{Any, Any, Any}" href="#DigitalComm.bitDemappingQAM!-Tuple{Any, Any, Any}"><code>DigitalComm.bitDemappingQAM!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><hr/><p>Quadrature Amplitude Modulation (QAM) hard decoding function Apply symbol hard demapping to a input symbol sequence (of size 1xN) with constellation size M. Output is a binary (1xL) with N = L / log2(M) Conventional gray demapping is used. Input constellation is Array{Complex{Float64}} Output bitsream is Array{Int8}</p><p><strong>–- Syntax</strong></p><pre><code class="nohighlight hljs">  bitDemappingQAM!(hardBits,M,qamVect)</code></pre><p><strong>–- Input parameters</strong></p><ul><li>hardBits	: Vector of bits to populate [Array{UInt8}, length(qamVect)/log2(M)]</li><li>M			: Constellation size (i.e from 4 to 256)</li><li>qamVect	: Complex observation vector to decode.</li></ul><p><strong>–- Output parameters</strong></p><ul><li>[]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/bitDeMapping.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.bitDemappingQAM-Tuple{Any, Any}" href="#DigitalComm.bitDemappingQAM-Tuple{Any, Any}"><code>DigitalComm.bitDemappingQAM</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><hr/><p>Quadrature Amplitude Modulation (QAM) hard decoding function Apply symbol hard demapping to a input symbol sequence (of size 1xN) with constellation size M. Output is a binary (1xL) with N = L / log2(M) Conventional gray demapping is used. Input constellation is Array{Complex{Float64}} Output bitsream is Array{Int8}</p><p><strong>–- Syntax</strong></p><p>hardBits = 	 bitDemappingQAM!(hardBits,M,qamVect)</p><p><strong>–- Input parameters</strong></p><ul><li>M			: Constellation size (i.e from 4 to 256)</li><li>qamVect	: Complex observation vector to decode.</li></ul><p><strong>–- Output parameters</strong></p><ul><li>hardBits	: Vector of bits to populate [Array{UInt8}, length(qamVect)/log2(M)]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/bitDeMapping.jl#L377-L393">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.hardConstellation!-Tuple{Any, Any, Any}" href="#DigitalComm.hardConstellation!-Tuple{Any, Any, Any}"><code>DigitalComm.hardConstellation!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><hr/><p>Quadrature Amplitude Modulation (QAM) hard decoding function Return the hard decoded constellation with voronoi baseds decision. The difference with bitDeMapping is that bitDeMapping returns the decoded bit sequence whereas hardConstellation returns the closest constellation point. This can be use to compute raw EVM estimation (assuming a sufficiently high SNR to avoid errors).</p><p><strong>–- Syntax</strong></p><pre><code class="nohighlight hljs">hardConstellation!(qamDec,M,qamMat)</code></pre><p><strong>–- Input parameters</strong></p><ul><li>qamDec	: Vector to populate [Array{Complex{Float64},N}] with N = length(qamMat)</li><li>M			: Constellation size (i.e 4 to 256) </li><li>qamMat	: Vector to decode</li></ul><p><strong>–- Output parameters</strong></p><ul><li>[]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/hardConstellation.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.hardConstellation-Tuple{Any, Any}" href="#DigitalComm.hardConstellation-Tuple{Any, Any}"><code>DigitalComm.hardConstellation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><hr/><p>Quadrature Amplitude Modulation (QAM) hard decoding function Return the hard decoded constellation with voronoi baseds decision. The difference with bitDeMapping is that bitDeMapping returns the decoded bit sequence whereas hardConstellation returns the closest constellation point. This can be use to compute raw EVM estimation (assuming a sufficiently high SNR to avoid errors).</p><p><strong>–- Syntax</strong></p><p>qamDec = hardConstellation!(qamDec,M,qamMat)</p><p><strong>–- Input parameters</strong></p><ul><li>M			: Constellation size (i.e 4 to 256) </li><li>qamMat	: Vector to decode</li></ul><p><strong>–- Output parameters</strong></p><ul><li>qamDec	: Vector to populate [Array{Complex{Float64},N}] with N = length(qamMat)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/hardConstellation.jl#L133-L144">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.calcLLR-Tuple{Any, Any, Any}" href="#DigitalComm.calcLLR-Tuple{Any, Any, Any}"><code>DigitalComm.calcLLR</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><hr/><p>Returns the final LLR value based on input distances </p><p><strong>–- Syntax</strong></p><p>llr = calcLLR(e0,e1,c)</p><p><strong>–- Input parameters</strong></p><ul><li>e0  : Minimal distance 1 </li><li>e1  : Minimal distance 2 </li><li>c	  : Channel estimate </li></ul><p><strong>–- Output parameters</strong></p><ul><li>llr : Max likelihood estimate </li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/symbolDemapper.jl#L47-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.llrToHardBits!-Tuple{Any, Array{Float64, N} where N}" href="#DigitalComm.llrToHardBits!-Tuple{Any, Array{Float64, N} where N}"><code>DigitalComm.llrToHardBits!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><hr/><p>Returns hard binary value from soft LLR estimate (no FEC decoder, only hard decision here!)</p><p><strong>–- Syntax</strong></p><pre><code class="nohighlight hljs">llrToHardBits(hardD,llr)</code></pre><p><strong>–- Input parameters</strong></p><ul><li>hardD	  : Hard binary decision [Array{UInt},N] </li><li>llr	  : Input LLR (Float64 or UInt8 array) [Union{[Array{UInt}],[Array{Float64}]}]</li></ul><p><strong>–- Output parameters</strong></p><ul><li>[]</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/symbolDemapper.jl#L328-L341">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.llrToHardBits!-Tuple{Any, Array{UInt8, N} where N}" href="#DigitalComm.llrToHardBits!-Tuple{Any, Array{UInt8, N} where N}"><code>DigitalComm.llrToHardBits!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><hr/><p>Returns hard binary value from soft LLR estimate (no FEC decoder, only hard decision here!)</p><p><strong>–- Syntax</strong></p><pre><code class="nohighlight hljs">llrToHardBits(hardD,llr)</code></pre><p><strong>–- Input parameters</strong></p><ul><li>hardD	  : Hard binary decision [Array{UInt},N] </li><li>llr	  : Input LLR (Float64 or UInt8 array) [Union{[Array{UInt}],[Array{Float64}]}]</li></ul><p><strong>–- Output parameters</strong></p><ul><li>[]</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/symbolDemapper.jl#L347-L359">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.llrToHardBits-Tuple{Array{Float64, N} where N}" href="#DigitalComm.llrToHardBits-Tuple{Array{Float64, N} where N}"><code>DigitalComm.llrToHardBits</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><hr/><p>Returns hard binary value from soft LLR estimate (no FEC decoder, only hard decision here!)</p><p><strong>–- Syntax</strong></p><pre><code class="nohighlight hljs">hardD = llrToHardBits(llr)</code></pre><p><strong>–- Input parameters</strong></p><ul><li>llr	  : Input LLR (Float64 or UInt8 array) [Union{[Array{UInt}],[Array{Float64}]}]</li></ul><p><strong>–- Output parameters</strong></p><ul><li>hardD	  : Hard binary decision [Array{UInt},N] </li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/symbolDemapper.jl#L366-L377">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.llrToHardBits-Tuple{Array{UInt8, N} where N}" href="#DigitalComm.llrToHardBits-Tuple{Array{UInt8, N} where N}"><code>DigitalComm.llrToHardBits</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><hr/><p>Returns hard binary value from soft LLR estimate (no FEC decoder, only hard decision here!)</p><p><strong>–- Syntax</strong></p><pre><code class="nohighlight hljs">hardD = llrToHardBits(llr)</code></pre><p><strong>–- Input parameters</strong></p><ul><li>llr	  : Input LLR (Float64 or UInt8 array) [Union{[Array{UInt}],[Array{Float64}]}]</li></ul><p><strong>–- Output parameters</strong></p><ul><li>hardD	  : Hard binary decision [Array{UInt},N] </li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/symbolDemapper.jl#L384-L396">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.llrToUInt!-Tuple{Any, Any}" href="#DigitalComm.llrToUInt!-Tuple{Any, Any}"><code>DigitalComm.llrToUInt!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><hr/><p>Convert a LLR floating array to a UInt LLR  Some method (espcially C functions as in libfec) expect LLR to be UInt value from  0 (Likely a 0) to 255 (Likely a 1).  symbolDemappingQAM create a Float64 array from -infty (likely a 0) to nfty (Likely a 1). This function take a Float64 LLR estimate and output a UInt8 vector</p><p><strong>–- Syntax</strong></p><pre><code class="nohighlight hljs">llrToUInt!(llrUInt,llr)</code></pre><p><strong>–- Input parameters</strong></p><ul><li>llrUInt : Output LLR in UInt [Array{UInt},N]</li><li>llr	  : Input LLR [Array{Float64},N]</li></ul><p><strong>–- Output parameters</strong></p><ul><li>[]</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/symbolDemapper.jl#L270-L284">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.llrToUInt-Tuple{Any}" href="#DigitalComm.llrToUInt-Tuple{Any}"><code>DigitalComm.llrToUInt</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><hr/><p>Convert a LLR floating array to a UInt LLR  Some method (espcially C functions as in libfec) expect LLR to be UInt value from  0 (Likely a 0) to 255 (Likely a 1).  symbolDemappingQAM create a Float64 array from -infty to infty. This function take a Float64 LLR estimate and output a UInt8 vector</p><p><strong>–- Syntax</strong></p><pre><code class="nohighlight hljs">llrUInt = llrToUInt(llr)</code></pre><p><strong>–- Input parameters</strong></p><ul><li>llr	  : Input LLR [Array{Float64},N]</li></ul><p><strong>–- Output parameters</strong></p><ul><li>llrUInt : Output LLR in UInt [Array{UInt},N]</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/symbolDemapper.jl#L301-L314">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.symbolDemappingQAM!-NTuple{4, Any}" href="#DigitalComm.symbolDemappingQAM!-NTuple{4, Any}"><code>DigitalComm.symbolDemappingQAM!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><hr/><p><strong>–- Description</strong></p><p>Returns the log likelihood ratio of the incoming sequence qamSeq based on the channel estimates channelIn qamSeq is an input noisy QAM sequence with same size of channel estimate vector Output is populated by  soft output binary sequence to be fed in a FEC </p><p><strong>–- Syntax</strong></p><p>output	  = :symbolDemappingQAM(mcs,qamSeq,channel)</p><p><strong>–- Input parameters</strong></p><ul><li>output  : Soft bits [Array{UInt8},N*log2(mcs)]</li><li>mcs	  : Constellation size (from 4 to 256) [Int]</li><li>qamSeq  : Complex noisy received sequence (after equalization) [Array{Float64},N]</li><li>channel : Complex channel estimate [Array{Float64},N]</li></ul><p><strong>–- Output parameters</strong></p><ul><li>[]</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/symbolDemapper.jl#L89-L107">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.symbolDemappingQAM-Tuple{Any, Any, Any}" href="#DigitalComm.symbolDemappingQAM-Tuple{Any, Any, Any}"><code>DigitalComm.symbolDemappingQAM</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><hr/><p><strong>–- Description</strong></p><p>Returns the log likelihood ratio of the incoming sequence qamSeq based on the channel estimates channelIn. Max log approximation is considered qamSeq is an input noisy QAM sequence with same size of channel estimate vector Output is a vector of soft output binary sequence to be fed in a FEC </p><p><strong>–- Syntax</strong></p><p>output	  = symbolDemappingQAM(mcs,qamSeq,channel)</p><p><strong>–- Input parameters</strong></p><ul><li>mcs	  : Constellation size (from 4 to 256) [Int]</li><li>qamSeq  : Complex noisy received sequence (after equalization) [Array{Float64},N]</li><li>channel : Complex channel estimate [Array{Float64},N]</li></ul><p><strong>–- Output parameters</strong></p><ul><li>output  : Soft bits [Array{UInt8},N*log2(mcs)]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/symbolDemapper.jl#L65-L79">source</a></section></article><h2 id="Channels"><a class="docs-heading-anchor" href="#Channels">Channels</a><a id="Channels-1"></a><a class="docs-heading-anchor-permalink" href="#Channels" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.addNoise-Union{Tuple{T}, Tuple{Array{T, N} where N, Any}, Tuple{Array{T, N} where N, Any, Any}} where T" href="#DigitalComm.addNoise-Union{Tuple{T}, Tuple{Array{T, N} where N, Any}, Tuple{Array{T, N} where N, Any, Any}} where T"><code>DigitalComm.addNoise</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Add a white additive circular gaussian noise to input signal Added noise is real if input signal is real and computedlex is input signal is complex Noise level is controled by the second input parameter which is the signal to noise ratio (SNR) Signal power powSig is computed based in the input sequence power (average power in time domain) although a third parameter (theoretical power of input signal is given). In that case, snr is computed based on the value powSig <br/>output parameters are the signal with noise, and the noise samples <br/>See the bang methods for non-buffer alloc. <br/>[y,n]   = addNoise(x,snr,powSig); addNoise!(y,x,powSig)       # Fill y from x  addNoise!(x,powSig)         # Replace x</p><p><strong>–- Input parameters</strong></p><ul><li>x= Input signal [Array{Real{Float64}}, Array{Complex{Float64}}] of size N</li><li>snr= Desired signal to noise ratio [Float64]</li><li>powSig= Power of input signal. If not given, power is evaluated based on input signal x</li></ul><p><strong>–- Output parameters</strong></p><ul><li>y= Signal with noise [Array{Real{Float64}}, Array{Complex{Float6464}}] of size N</li><li>n= noise samples [Array{Real{Float64}}, Array{Complex{Float64}}] of size N</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/Channel/addNoise.jl#L1-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.rayleighChan" href="#DigitalComm.rayleighChan"><code>DigitalComm.rayleighChan</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><hr/><p>Generates a correlated random rayleigh sequence of size N, parametrized by the doppler frequency fd and the sampling frqeuency fs. The method uses IFFT approach described in [1]</p><p><strong>–- Syntax</strong></p><p>α		= rayleighChan(nbPath,N,fs,fd,seed=-1)</p><p><strong>–- Input parameters</strong></p><ul><li>nbPath : Number of path to be generated (&gt;0) [Int]</li><li>N	: Size of desired output (size of FFT) [Union{Int,Float64}]</li><li>fs	: Sampling frequency [Union{Int,Float64}]</li><li>fd	: doppler frequency [Union{Int,Float64}]</li><li>seed: Seed for random generation ([Int], default =-1)</li></ul><p><strong>–- Output parameters</strong></p><ul><li>α	: Complex rayleigh coefficient [Array{Complex{Float64},N}]</li></ul><p><strong>–- References</strong></p><p>[1] D. J. Young and N. C. Beaulieu, &quot;The generation of correlated Rayleigh random variates by inverse discrete Fourier transform,&quot; in IEEE Transactions on Communications</p><p><strong>–-</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/Channel/rayleighChan.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.applyChannel-Tuple{Any, Any}" href="#DigitalComm.applyChannel-Tuple{Any, Any}"><code>DigitalComm.applyChannel</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><hr/><p>Apply a channel implementation  to an input signal</p><p><strong>–- Syntax</strong></p><p>sigChan	  : applyChannel(sigId,channelImpl)</p><p><strong>–- Input parameters</strong></p><ul><li>sigId	  : Input signal [Array{Any}]</li><li>channelImpl : Channel implementation [ChannelImpl]</li></ul><p><strong>–- Output parameters</strong></p><ul><li>sigChan	: Output signal [Array{Any}]</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/Channel/getChannel.jl#L342-L355">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.getChannel" href="#DigitalComm.getChannel"><code>DigitalComm.getChannel</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><hr/><p>Create a channelImpl based on desired channel model and number of realisations </p><p><strong>–- Syntax</strong></p><p>channelImpl	  = getChannel(nbSamples,channelModel,randSeed=-1)</p><p><strong>–- Input parameters</strong></p><ul><li>nbSamples		: Number of samples on which channel will be applied [Int]</li><li>channelModel	: Channel object [ChannelModel]</li><li>randSeed		: Desired seed (default -1)</li></ul><p><strong>–- Output parameters</strong></p><ul><li>channelImpl	: Channel implementation </li></ul><p><strong>–-</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/Channel/getChannel.jl#L243-L256">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.getFIRResponse" href="#DigitalComm.getFIRResponse"><code>DigitalComm.getFIRResponse</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><hr/><p>Returns a complete FIR response based on the power profile (in linear scale), the delay profile (in s) and the sampling frequency.</p><p><strong>–- Syntax</strong></p><p>cir = getFIRResponse(delayProfile:,powerProfile,freq,sincSupport=5,interpSystem=0)</p><p><strong>–- Input parameters</strong></p><ul><li>delayProfile	: Vector of delay in second [Union{Array{Int},Array{Float64}}]</li><li>powerProfile	: Vector of attenuation with same size of delayProfile in linear scale with rayleigh distribution</li><li>freq			: Sampling frequency</li><li>sincSupport	: Size of interpolator (default 5)</li><li>interpSystem	: Forcing extra delay for all samples to have proper interpolation of the FIR beginning (default 0)</li></ul><p><strong>–- Ouput parameters</strong></p><ul><li>cir			: Finite impulse response [Array{Complex{Float64}},max(delayProfile)+sincSupport]</li></ul><p><strong>–-</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/Channel/getChannel.jl#L181-L196">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.initChannel-Tuple{String, Union{Float64, Int64}, Union{Float64, Int64}, Union{Float64, Int64}}" href="#DigitalComm.initChannel-Tuple{String, Union{Float64, Int64}, Union{Float64, Int64}, Union{Float64, Int64}}"><code>DigitalComm.initChannel</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><hr/><p>Create a channel object associated to physical parameters and propagation profile.</p><p><strong>–- Syntax</strong></p><p>channObj  = initChannel(profile,carrierFreq,samplingFreq,dopplerFreq;powerProfile=[],delayProfile=[],randSeed=-1)</p><p><strong>–- Input parameters</strong></p><ul><li>profile : Multipath profile (see below) [String]</li><li>carrierFreq : Carrier frequency in Hz [Union{Int,Float64}]</li><li>samplingFreq: baseband sampling frequency [Union{Int,Float64}]</li><li>speed : Velocity (km/h) [Float64]</li><li>powerProfile	: User defined power profile (default []). In case when it is defined, delayProfile should also be defined and profile is not used. [Array{Float}]</li><li>delayProfile	: User defined delay profile in second [Array{Float64}]</li><li>randSeed : Seed if necessary (default: -1) [Float64]</li></ul><p><strong>–- Output parameters</strong></p><ul><li>channel : Julia Channel Object [Channel]</li></ul><p><strong>–- Channel models</strong></p><p>-	ETU	  : Extended Typical Urban -	EVA	  : Extended Vehicular area -	TDLC  : -	Rayleigh : Single tap rayleigh channel model</p><p><strong>–-</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/Channel/getChannel.jl#L56-L78">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.ChannelImpl" href="#DigitalComm.ChannelImpl"><code>DigitalComm.ChannelImpl</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><hr/><p>Object with channel realisations</p><p><strong>–- Syntax</strong></p><ul><li>timeVarying	: Flag for constant vs time varying channel [Int] </li><li>cir			: CIR matrix (nbTap x nbChannel) [Union{Array{Int},Array{Float64},Array{Complex{Float64}}}]</li><li>channelModel  : Model use for generation [DigitalComm.ChannelModel]</li><li>powerLin		: Power distribution with the rayleigh distribution [Array{Complex{Float64}}] </li><li>randSeed		: Seed use for rayleigh generation </li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/Channel/getChannel.jl#L33-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.ChannelModel" href="#DigitalComm.ChannelModel"><code>DigitalComm.ChannelModel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><hr/><p>Channel model object</p><p><strong>–- Syntax</strong></p><ul><li>profile		  : Name of profile [String]</li><li>carrierFreq	  : Carrier frequency [Union{Int,Float64}]</li><li>samplingFreq	  : Sampling frequency [Union{Int,Float64}]</li><li>speed			  : Desired speed (km/h) [Union{Int,Float64}]</li><li>powerProfile	  : Distribution of power values in dB [Array{Float64}]</li><li>delayProfile	  : Distribution of delay values in s [Array{Float64}], same size as powerProfile</li><li>dopplerFreq	  : Doppler frequency (inherited from samplingFreq  and speed) </li><li>delaySpread	  : Max support of CIR in samples [Int]</li></ul><p><strong>–-</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/Channel/getChannel.jl#L5-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.addCFO-Union{Tuple{T}, Tuple{Union{AbstractArray{Complex{T}, 1}, AbstractVector{T}}, Any, Any}, Tuple{Union{AbstractArray{Complex{T}, 1}, AbstractVector{T}}, Any, Any, Any}} where T&lt;:Real" href="#DigitalComm.addCFO-Union{Tuple{T}, Tuple{Union{AbstractArray{Complex{T}, 1}, AbstractVector{T}}, Any, Any}, Tuple{Union{AbstractArray{Complex{T}, 1}, AbstractVector{T}}, Any, Any, Any}} where T&lt;:Real"><code>DigitalComm.addCFO</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Adding Carrier Frequency Offset δ in Hz to the input signal x sampled at frequency samplingRate (In Hz) with initial phase ϕ (default 0) This function does not mutate the input signal. See addCFO! for mutating function. In case you want to add normalized CFO, set the samplingRate to 1.</p><p><strong>–- Syntax</strong></p><p>y = addCFO(x,delta,samplingRate)</p><p><strong>–- Input parameters</strong></p><ul><li>x : Input signal </li><li>δ : Carrier frequency offset [Hz]</li><li>samplingRate : Sampling rate [Hz]</li></ul><p><strong>–- Output parameters</strong></p><ul><li>y : Signal with CFO</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/Channel/addCFO.jl#L1-L13">source</a></section></article><h2 id="Windows-and-filters"><a class="docs-heading-anchor" href="#Windows-and-filters">Windows and filters</a><a id="Windows-and-filters-1"></a><a class="docs-heading-anchor-permalink" href="#Windows-and-filters" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.raisedCosine-Tuple{Any, Any, Any}" href="#DigitalComm.raisedCosine-Tuple{Any, Any, Any}"><code>DigitalComm.raisedCosine</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Returns the Finite Impulse Response of a Raised Cosine (RC) filter.	The filter is defined by its span (evaluated in number of symbol N), its Roll-Off factor and its oversampling factor. The span corresponds to the number of symbol affected by filter before and after the center point.</p><p>Output is a Vector{Float64} array of size L= 2KN+1 </p><p>SRRC definition is based on [1]	 </p><p>[1]	 3GPP TS 25.104 V6.8.0 (2004-12). http://www.3gpp.org/ftp/Specs/archive/25_series/25.104/25104-680.zip </p><p>Syntax </p><pre><code class="nohighlight hljs">	h	= raisedCosine(N,beta,ovS)</code></pre><p>Input parameters </p><ul><li>N	  	: Symbol span (Int16)</li><li>beta  : Roll-off factor (Float64)</li><li>ovS	: Oversampling rate (Int16)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; h = raisedCosine(12,0.5,16);

julia&gt; length(h)
385</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/raisedCosine.jl#L1-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.sqrtRaisedCosine-Tuple{Any, Any, Any}" href="#DigitalComm.sqrtRaisedCosine-Tuple{Any, Any, Any}"><code>DigitalComm.sqrtRaisedCosine</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Returns the Finite Impulse Response of a Square Root Raised Cosine (SRRC) filter. </p><p>The filter is defined by its span (evaluated in number of symbol N), its Roll-Off factor and its oversampling factor. The span corresponds to the number of symbol affected by filter before and after the center point.</p><p>Output is a <code>Vector{Float64}</code> array of size L= 2KN+1</p><p>SRRC definition is based on [1]</p><p>[1]	 3GPP TS 25.104 V6.8.0 (2004-12). http://www.3gpp.org/ftp/ Specs/archive/25_series/25.104/25104-680.zip</p><p>Syntax</p><p>h	= sqrtRaisedCosine(N,beta,ovS) </p><p>Input parameters </p><ul><li>N	  	: Symbol span (Int16)</li><li>beta  : Roll-off factor (Float64)</li><li>ovS	: Oversampling rate (Int16)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; h = sqrtRaisedCosine(12,0.5,16);

julia&gt; length(h)
385</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/raisedCosine.jl#L45-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.cheb-Tuple{Any, Any}" href="#DigitalComm.cheb-Tuple{Any, Any}"><code>DigitalComm.cheb</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><hr/><p>Apply Chebyshev polynom of order L to input x</p><p><strong>–- Syntax</strong></p><pre><code class="nohighlight hljs">y = cheb(L,x)</code></pre><p><strong>–- Input parameters</strong></p><ul><li>L	  : Chebyshev order [Int] </li><li>x	  : Input [Any]</li></ul><p><strong>–- Output parameters</strong></p><ul><li>y	  : Output </li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/Waveforms/UFOFDM/filterUFOFDM.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.dolphChebyshev-Tuple{Any, Any}" href="#DigitalComm.dolphChebyshev-Tuple{Any, Any}"><code>DigitalComm.dolphChebyshev</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><hr/><p>Returns the Dolp Chebyshev filter of order L with desired attenation att</p><p>See Peter Lynch, &quot;The Dolph-Chebyshev Window: A Simple Optimal Filter&quot;, Monthly Weather Review, Vol. 125, pp. 655-660, April 1997. (http://www.maths.tcd.ie/~plynch/Publications/Dolph.pdf) Dolph, &quot;A current distribution for broadside arrays which optimizes the relationship between beam width and side-lobe level&quot;, Proc. IEEE, 34, pp. 335-348. 		cheb(m-1, beta * cos(pi * k/m)) W(k) =	–––––––––––––––- 			  cheb(m-1, beta)</p><p><strong>–- Syntax</strong></p><p>filterDC = dolphChebyshev(n,at)</p><p><strong>–- Input parameters</strong></p><ul><li>n		  : Size of desired filter </li><li>at	  : Attenation in dBB </li></ul><p><strong>–- Output parameters</strong></p><ul><li>filterDC : Filter impulse response [Array{Float64}] </li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/Waveforms/UFOFDM/filterUFOFDM.jl#L21-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.getWolaWindow-NTuple{4, Any}" href="#DigitalComm.getWolaWindow-NTuple{4, Any}"><code>DigitalComm.getWolaWindow</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><hr/><p>Returns the desired window used in transmitter or receiver weigthed overlap and add methods (WOLA). See [1] for window reference design.</p><p><strong>–- Syntax</strong></p><p>window = getWolaWindow(winFunc,nFFT,nCp,winlength)</p><p><strong>–- Input parameters</strong></p><ul><li>winFunc	: Window type (see supported format below) [String]</li><li>nFFT		: FFT size [Int]</li><li>nCP		: CP size [Int]</li><li>winlength : length of window [Int]</li></ul><p><strong>–- Output parameters</strong></p><p>window	: Window [Window]</p><p><strong>–-</strong></p><p><strong>Supported window</strong></p><ul><li>&quot;Triangle&quot;		: Triangle window</li><li>&quot;srrc&quot;			: Square Root Raised Cosine</li><li>&quot;Meyer&quot;			: Meyer window (See [1])</li></ul><p><strong>–-</strong></p><p><strong>References</strong></p><ul><li>[1] R. Zayani, Y. Medjahdi, H. Shaiek and D. Roviras, &quot;WOLA-OFDM: A Potential Candidate for Asynchronous 5G,&quot; 2016.</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/Waveforms/WOLA/getWolaWindow.jl#L17-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.Window" href="#DigitalComm.Window"><code>DigitalComm.Window</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><hr/><p>Structure describing window parameters </p><p><strong>–- Syntax</strong></p><ul><li>winFunc	: Name of window  </li><li>winLength : Size of window </li><li>window	: Window coefficients </li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/Waveforms/WOLA/getWolaWindow.jl#L1-L11">source</a></section></article><h1 id="Waveforms"><a class="docs-heading-anchor" href="#Waveforms">Waveforms</a><a id="Waveforms-1"></a><a class="docs-heading-anchor-permalink" href="#Waveforms" title="Permalink"></a></h1><h2 id="Common-functions-2"><a class="docs-heading-anchor" href="#Common-functions-2">Common functions</a><a class="docs-heading-anchor-permalink" href="#Common-functions-2" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.decodeSig-Tuple{Any, Dict{String, Waveform}, String}" href="#DigitalComm.decodeSig-Tuple{Any, Dict{String, Waveform}, String}"><code>DigitalComm.decodeSig</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><hr/><p>Create a signal based on a waveform dictionnary and a desired configuration (i.e the key)</p><p><strong>–- Syntax</strong></p><p>sigId	= decodeSig(qamMat,dWav,key)</p><p><strong>–- Input parameters</strong></p><ul><li>signal	  : Time domain signal </li><li>qamMat  : Time frequency complex QAM matrix [Array{Complex{Float64}}]</li><li>dWav	  : Waveform dictionnary (see initWaveforms)</li><li>key	  : Desired waveform configuration</li></ul><p><strong>–- Output parameters</strong></p><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/Waveforms/genSig.jl#L151-L165">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.decodeSig-Tuple{Any, DigitalComm.StrucOFDM}" href="#DigitalComm.decodeSig-Tuple{Any, DigitalComm.StrucOFDM}"><code>DigitalComm.decodeSig</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Decode a time domain signal for a given multicarrier waveform and returns a T/F QAM constellation. Input are the compelx baseband signal  and the Waveform structure.</p><p><strong>–- Syntax</strong></p><pre><code class="nohighlight hljs">qamDec	= decodeSig(signal,struc);</code></pre><p><strong>–- Input parameters</strong></p><ul><li>signal  : Time domain signal </li><li>struc	  : Waveform structure </li></ul><p><strong>–- Output parameters</strong></p><ul><li>qamDec  : Time frequency complex QAM matrix [Array{Complex{Float64}}]</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/Waveforms/genSig.jl#L34-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.genSig-Tuple{Any, DigitalComm.StrucOFDM}" href="#DigitalComm.genSig-Tuple{Any, DigitalComm.StrucOFDM}"><code>DigitalComm.genSig</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><hr/><p>Generate a time domain signal for a given multicarrier waveform. Input are the Time-Frequency matrix qamMat and the Waveform structure.</p><p><strong>–- Syntax</strong></p><p>sigId	= genSig(qamMat,struc::Waveform)</p><p><strong>–- Input parameters</strong></p><ul><li>qamMat  : Time frequency complex QAM matrix [Array{Complex{Float64}}]</li><li>struc	  : Waveform structure </li></ul><p><strong>–- Output parameters</strong></p><ul><li>sigId	  : Time domain signal </li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/Waveforms/genSig.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.genSig-Tuple{Array{ComplexF64, N} where N, Dict{String, Waveform}, String}" href="#DigitalComm.genSig-Tuple{Array{ComplexF64, N} where N, Dict{String, Waveform}, String}"><code>DigitalComm.genSig</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><hr/><p>Create a signal based on a waveform dictionnary and a desired configuration (i.e the key)</p><p><strong>–- Syntax</strong></p><p>sigId	= genSig(qamMat,dWav,key)</p><p><strong>–- Input parameters</strong></p><ul><li>qamMat  : Time frequency complex QAM matrix [Array{Complex{Float64}}]</li><li>dWav	  : Waveform dictionnary (see initWaveforms)</li><li>key	  : Desired waveform configuration</li></ul><p><strong>–- Output parameters</strong></p><ul><li>sigId	  : Time domain signal </li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/Waveforms/genSig.jl#L133-L147">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.getWaveformName-Tuple{Waveform}" href="#DigitalComm.getWaveformName-Tuple{Waveform}"><code>DigitalComm.getWaveformName</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><hr/><p>Returns the waveform name based on input type structure</p><p><strong>–- Syntax</strong></p><p>name = getWaveformName(struc)</p><p><strong>–- Input parameters</strong></p><ul><li>struc	  : Waveform structure [Waveform]</li></ul><p><strong>–- Output parameters</strong></p><ul><li>name	  : String associated to waveform name</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/Waveforms/genSig.jl#L67-L79">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.initWaveforms-Tuple" href="#DigitalComm.initWaveforms-Tuple"><code>DigitalComm.initWaveforms</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><hr/><p>Create a dictionnary of waveform configurations. To compare and use the same script for different waveform configuration, we propose to add a dictionnary to have a container that contains all waveform configuraton. The function is called with every desired waveform structure. The dictionnary as a key associated to the waveform name, and a field associated to the waveform structure. If the waveform is present several times (several configuration with same waveform type, for instance FBMC with different overlapping factor values), a counter index is added to the waveform key.</p><p><strong>–- Syntax</strong></p><pre><code class="nohighlight hljs">dWav  = initWaveforms(x1,x2,...)</code></pre><p><strong>–- Input parameters</strong></p><ul><li>x		: Waveform structure [Waveform]</li></ul><p><strong>–- Output parameters</strong></p><ul><li>dWav	: Dictionnary of waveforms.</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/Waveforms/genSig.jl#L95-L107">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.genZCSequence" href="#DigitalComm.genZCSequence"><code>DigitalComm.genZCSequence</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><hr/><p>Constant Modulus Zero Autocorrelation (CAZAC) sequence generation. Sequence can be used as preamble sequences for OFDM systems. The function generate the ZC sequence in frequency domain. Generates a Zadoff-Chu  sequence on allocated subcarrier mapped on nFFT vector with generated kernel muPSS and power boost zcBoost</p><p><strong>–- Syntax</strong></p><p>zcSeq	  = genZCSequence(nFFT,allocatedSubcarrier,muPSS=0,zcBoost=0)</p><p><strong>–- Input parameters</strong></p><ul><li>nFFT				  : FFT size for output [Int]</li><li>allocatedSubcarrier : vector of allocated subcarrier [Array{Int,L}]. </li><li>muPSS				  : Kernel for ZC sequence [Int] – default 0</li><li>zcBoost			  : Power boost (in dB) applied to sequence [Float32] – default 0.</li></ul><p><strong>–- Output parameters</strong></p><ul><li>zcSeq				  : ZC sequence [Array{Complex{Float64}},nFFT]</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/Waveforms/genZCSequence.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.get5GNRAlloc-Tuple{Any}" href="#DigitalComm.get5GNRAlloc-Tuple{Any}"><code>DigitalComm.get5GNRAlloc</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Returns the vector of allocated subcarriers associated to 5G New Radio frequency mapping. In 5G-NR, depending on FFT size, only few subcarriers are allocated (55-65%). This function takes a FFT size as input  and returns an array of size nbSubcarriers. The output has more subcarriers thanj getLTEAlloc (for 4G-LTE)  <br/>allocatedSubcarrier = getLTEAlloc(nFFT) <br/>Input parameters </p><ul><li>nFFT	  : Desired FFT size (128, 256, 512, 1024, 1536, 2048, 4096) [Int]</li></ul><p>Output parameters  <br/>- allocatedSubcarrier : Vector of subcarriers index [Array{Int}]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/Waveforms/getLTEAlloc.jl#L33-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.getLTEAlloc-Tuple{Any}" href="#DigitalComm.getLTEAlloc-Tuple{Any}"><code>DigitalComm.getLTEAlloc</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Returns the vector of allocated subcarriers associated to Long Term evolution frequency mapping. In LTE, depending on FFT size, only few subcarriers are allocated (45-55%). This function takes a FFT size as input  and returns an array of size nbSubcarriers  <br/>allocatedSubcarrier = getLTEAlloc(nFFT) <br/>Input parameters </p><ul><li>nFFT	  : Desired FFT size (128, 256, 512, 1024, 1536, 2048, 4096) [Int]</li></ul><p>Output parameters  <br/>- allocatedSubcarrier : Vector of subcarriers index [Array{Int}]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/Waveforms/getLTEAlloc.jl#L1-L11">source</a></section></article><h2 id="BF-OFDM"><a class="docs-heading-anchor" href="#BF-OFDM">BF-OFDM</a><a id="BF-OFDM-1"></a><a class="docs-heading-anchor-permalink" href="#BF-OFDM" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.getBFOFDMFilter-Tuple{Any, Any, Any}" href="#DigitalComm.getBFOFDMFilter-Tuple{Any, Any, Any}"><code>DigitalComm.getBFOFDMFilter</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Returns prototype fitlering matrix for BF-OFDM  with specified by overlapping factor K, PPN size nFBMC, filter type. Additional parameters are the CP size of the precoding stage (set to optimal value by default) and filter structure for specific parameter overset.</p><p><strong>–- Syntax</strong></p><p>(p,pF) = getBFOFDMFilter(K,nFBMC,filter;GI,BT,filterStopBand,fS)&gt;</p><p><strong>–- Input parameters</strong></p><ul><li>K	  : Overlapping factor [Int]</li><li>nFBMC : PPN size (Number of FBMC carriers) [Int]</li><li>filter: Filter type: &quot;Gaussian&quot;,&quot;phydyas&quot;,&quot;FS&quot;,&quot;DC&quot;: [String]</li><li>BT	  : Bandwidth time product for custom gaussian filter (used with &quot;gaussian&quot;) [Float64]</li><li>filterStopBand : Attenuation with custom DC window (used with &quot;DC&quot;) [Float64]</li><li>fS	  : Frequency sampling custom  coefficients (Array{Float64,K}) (used with &quot;fs&quot;)</li></ul><p><strong>–- Output parameters</strong></p><ul><li>p		: Filter impulse response [Array{Float64,K*nFBMC}].</li><li>pF		: Filter coefficient in frequency domain (For Frequency sampling implementation)</li></ul><hr/><p>Filter types All filter type can be called with 2 ways. &quot;filter&quot; and &quot;filter<em>opt&quot;. When &quot;filter</em>opt&quot; is used, the filter coefficient are obtained through numerical optimisation (SIR optimisation). Otherwise, it uses its associated parameter to extract appropriate coefficients. See [1] and [2] for filter optimisation principles. See [4] for special cases about 5G-NR compatibilty.  The supported filter/windows are:</p><ul><li>Gaussian	: Gaussian filter shape, specified by BT. Optimized Gaussian shape can be used [1]</li><li>phydyas		: Classic FBMC pulse shape defined in frequency domain [3]</li><li>FS			: Coefficient defined in frequency domain. Filter coefficient are based on intrinsic SIR optimisation [1]</li><li>DC			: Dolph Chebyshev window. Can be based on window optimisation (SIR optimisation) or defined by filterStopBand parameter.</li></ul><p><strong>–-</strong></p><p><strong>References</strong></p><ul><li>[1]	Demmer, D and Gerzaguet, R and Doré, J-B and Le Ruyet, D. and Kténas, D, &quot;Filter Design for 5G BF-OFDM Waveform&quot;, 2017.</li><li>[2] A. Sahin, I. Guvenc, and H. Arslan, “A Survey on Multicarrier Communications: Prototype Filters, Lattice Structures, and Implementation Aspects&quot;, 2014</li><li>[3] Phydyas project, &quot;Deliverable D5.1 : Prototype filter and structure optimization&quot;, 2009</li><li>[4]	Demmer, D and Rostom, Z and Gerzaguet, R and Doré, J-B and Le Ruyet, D. &quot;Study of OFDM Precoded Filter-Bank Waveforms&quot;, 2018</li></ul><p><strong>Examples</strong></p><p>Get a classic FBMC filter with phydyas and an overlapping factor of 4, with a input PPN of size 64. The precodinng stage is a OFDM of size 64 and a GI of size 4.</p><pre><code class="nohighlight hljs"># --- phydyas filter
( hphydyas,hFphydyas )	 = getBFOFDMFilter(4,64,&quot;phydyas&quot;);

# --- Gaussian shape
( hGaussian,hFGaussian )	 = getBFOFDMFilter(4,64,&quot;Gaussian_opt&quot;,GI=4);

# --- Custom Gaussian window
( hGaussianC,hFGaussianC ) = getBFOFDMFilter(4,64,&quot;Gaussian&quot;,GI=4,BT=0.5)</code></pre><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/Waveforms/BFOFDM/BFOFDM_filter.jl#L1-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.bfofdmSigGen-Tuple{Array{ComplexF64, N} where N, Int64, Int64, Int64, Int64, Float64, Array{Int64, N} where N, Any}" href="#DigitalComm.bfofdmSigGen-Tuple{Array{ComplexF64, N} where N, Int64, Int64, Int64, Int64, Float64, Array{Int64, N} where N, Any}"><code>DigitalComm.bfofdmSigGen</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><hr/><p>Creates a Block Filtered - OFDM (BF-OFDM) signal parametrized by its numerlogy and its waveform parameter. Generate a time domain signal based on the input matrix qamMat. The input matrix is a T/F matrix of size (nRe x nbSymb) with nRe the number of allocated subcarrier and nbSymb the number of symbols.</p><p>The waveform is parametrized by the PPN size (number of carriers) nFBMC, the size of the precoding stage nOFDM, the CP size of the precoding stage GI and the compression factor parameter δ. See [1], [2] for waveform description and [3,5] for importance and design of compression rate (set to 0.5 in former works on BF-OFDM).</p><p>BF-OFDM is characterized by its pulse shape filter. Pulse shape can be automatically tuned to optimal (in terms of  innterference management) [4]. In such a case, filterType should be a string (can be &quot;gaussian<em>opt&quot;, &quot;dc</em>opt&quot; and &quot;fs_opt&quot;). For a specific pulse shape filter, an array of the nFBMC*K filter taps should be given (and generated for example  with getBFOFDMFilter).</p><p><strong>–- Syntax</strong></p><p>sigId	  =bfofdmSigGen(qamMat,nFBMC,nOFDM,K,GI,δ,allocatedSubcarriers,filterType;typeTx=&quot;PPN&quot;)</p><p><strong>–- Input parameters</strong></p><ul><li>qamMat		: T/F symbols to transmit (QAM symbols) [Array{Complex{Float64},nRe,nbSymb] with nbSymb number of BF-OFDM symbols and nRe number of allocated subcarriers.</li><li>nFBMC		: PPN size</li><li>nOFDM		: OFDM precoding size</li><li>GI			: CP size of precoding stage</li><li>K			: Overlapping factor</li><li>δ			: Compression rate</li><li>allocatedSubcarriers : Vector or allocated subcarriers Array{Int,nRe} with maximum(nRe) &lt; nOFDM<em>nFBMC</em>δ</li><li>filterType	: Pulse shape type. Can be a string (see getBFOFDMFilter) or a vector of size K x nFBMC with filter taps.</li><li>typeTx		: Filterbank architecture. Can be &quot;PPN&quot; (polyphase network) or &quot;FS&quot; (frequency spreading) if filterType is of type &quot;fs&quot; or &quot;fs_opt&quot;.</li></ul><p><strong>–- Output parameters</strong></p><ul><li>sigId		: Time domainn BF-OFDM signal. [Array{Complex{Float64},nChip}.</li></ul><p><strong>–-</strong></p><p><strong>References</strong></p><ul><li>[1] Gerzaguet, R and Demmer, D and Doré, J-B and Le Ruyet, D. and Kténas, D, &quot;Block-Filtered OFDM: A new Promising Waveform for Multi-service Scenarios&quot;, 2017</li><li>[2] Demmer, D and Gerzaguet, R and Doré, J-B and Le Ruyet, D. and Kténas, D, &quot;Block-filtered OFDM: A novel waveform for future wireless technologies&quot;, 2017.</li><li>[3] Demmer, D and Rostom, Z and Gerzaguet, R and Doré, J-B and Le Ruyet, D. &quot;Study of OFDM Precoded Filter-Bank Waveforms&quot;, 2018</li><li>[4] Demmer, D and Gerzaguet, R and Doré, J-B and Le Ruyet, D. and Kténas, D, &quot;Filter Design for 5G BF-OFDM Waveform&quot;, 2017.</li><li>[5] Demmer, D.; Zakaria, R.; Gerzaguet, R.; Doré, J. &amp; Le Ruyet, D. Study of OFDM Precoded Filter-Bank Waveforms, IEEE Transactions on Wireless Communications, 2019.</li></ul><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/Waveforms/BFOFDM/bfofdmSigGen.jl#L76-L106">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.initBFOFDM-NTuple{7, Any}" href="#DigitalComm.initBFOFDM-NTuple{7, Any}"><code>DigitalComm.initBFOFDM</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><hr/><p>BF-OFDM initialisation</p><p><strong>–- Syntax</strong></p><p>bfofdm = initBFOFDM(nFBMC::Int,nOFDM::Int,K::Int,GI::Int,δ::Float64,allocatedSubcarriers::Array{Int},filterType::String;BT=-1,filterStopBand=-1,fS=[],nFFT=-1,nCP=-1)</p><p><strong>–- Input parameters</strong></p><ul><li>nFBMC		: Number of carriers (PPN size)</li><li>nOFDM		: Number of subbcarriers per carrier (OFDM precoder size)</li><li>K			: Overlapping factor of the PPN </li><li>GI		: CP size of the precoder </li><li>δ			: Rate factor (compression factor)  </li><li>allocatedSubcarriers	: Vector of allocated subcarriers   </li><li>filterName  : Type of filter used (name)  </li><li>filterTaps  : FIR coefficient values </li><li>BT		: Gaussian parameters (if gaussian filter is used)</li><li>filterStopBand : DolphChebyshev attenuation factor (if DC is used)</li><li>fS		: Frqeuency spreading coefficients (if FS filter is used)</li><li>nFFT		: Equivalent OFDM FFT size </li><li>nCP		: Equivalent OFDM CP size </li></ul><p><strong>–- Output parameters</strong></p><p>bfofdm		: BF-OFDM structure </p><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/Waveforms/BFOFDM/bfofdmSigGen.jl#L40-L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.StrucBFOFDM" href="#DigitalComm.StrucBFOFDM"><code>DigitalComm.StrucBFOFDM</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><hr/><p>BF-OFDM structure </p><p><strong>–- Syntax</strong></p><ul><li>nFBMC		: Number of carriers (PPN size)</li><li>nOFDM		: Number of subbcarriers per carrier (OFDM precoder size)</li><li>K			: Overlapping factor of the PPN </li><li>GI		: CP size of the precoder </li><li>δ			: Rate factor (compression factor)  </li><li>allocatedSubcarriers	: Vector of allocated subcarriers   </li><li>filterName  : Type of filter used (name)  </li><li>filterTaps  : FIR coefficient values </li><li>BT		: Gaussian parameters (if gaussian filter is used)</li><li>filterStopBand : DolphChebyshev attenuation factor (if DC is used)</li><li>fS		: Frqeuency spreading coefficients (if FS filter is used)</li><li>nFFT		: Equivalent OFDM FFT size </li><li>nCP		: Equivalent OFDM CP size </li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/Waveforms/BFOFDM/bfofdmSigGen.jl#L4-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.bfofdmSigDecode-NTuple{7, Any}" href="#DigitalComm.bfofdmSigDecode-NTuple{7, Any}"><code>DigitalComm.bfofdmSigDecode</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><hr/><p>Demodulate a BF-OFDM signal and returns the obtained T/F matrix composed of QAM symbols (without equalisation). Based on bfofdmSigGen.jl</p><p><strong>–- Syntax</strong></p><p>qamRx	= bfofdmSigDecode(sigRx,nFBMC,nOFDM,K,GI,δ,allocatedSubcarriers;posWindow=&quot;end&quot;)</p><p><strong>–- Input parameters</strong></p><ul><li>sigRx		: Complex baseband signal to decode [Array{Complex{Float64}}]</li><li>nFBMC		: PPN size [Int]</li><li>nOFDM		: FFT precoder size [Int]</li><li>K			: Overlapping factor [Int]</li><li>GI		: CP size of precoder [Int]</li><li>δ			: Compression rate  [Float64]</li><li>allocatedSubcarriers : Vector of allocated subcarriers [Array{Int}]</li><li>posWindow	  : Receiver window position. By default window is at same place as OFDM (i.e drop CP). For BF-OFDM, middle window position can also be considered with small delay spread channel (reduce ISI incuded by PPN). In that case, a phase rotation must be applied (see [1])</li></ul><p><strong>–- Output parameters</strong></p><ul><li>qamRx		: Decoded constellation [Array{Complex{Float64}}]</li></ul><p><strong>References</strong></p><ul><li>[1]	: Demmer, D.; Zakaria, R.; Gerzaguet, R.; Doré, J. &amp; Le Ruyet, D. Study of OFDM Precoded Filter-Bank Waveforms, IEEE Transactions on Wireless Communications, 2019.</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/Waveforms/BFOFDM/bfofdmSigDecode.jl#L1-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.getBFOFDM_carrierFromSubcarriers-NTuple{4, Any}" href="#DigitalComm.getBFOFDM_carrierFromSubcarriers-NTuple{4, Any}"><code>DigitalComm.getBFOFDM_carrierFromSubcarriers</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><hr/><p>Get the index of the allocated carriers based on the index of the subcarriers. We consider here that a FBMC carriers bear data (i.e is allocated) is at least one of its subcarrier is enable.</p><p><strong>–- Syntax</strong></p><p>fbmcCarriers	= getBFOFDM_carrierFromSubcarriers(nFBMC,nOFDM,δ,subcarrier)</p><p><strong>–- Input parameters</strong></p><ul><li>nFBMC	  : FBMC carrier size (number of carriers) [Int]</li><li>nOFDM	  : OFDM subcarrier size [Int]</li><li>δ		  : Rate factor [Float64]</li><li>fbmcCarriers : Vector of allocated carrier [Array{Int,L}], L &lt; nFBMC<em>nOFDM</em>δ </li></ul><p><strong>–- Output parameters</strong></p><ul><li>fbmcCarriers : Vector of allocated carriers [Array{Int, P ] P &lt; nFBMC</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/Waveforms/BFOFDM/carrierManipulation.jl#L31-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.getBFOFDM_oversampledGridSubcarriers-NTuple{4, Any}" href="#DigitalComm.getBFOFDM_oversampledGridSubcarriers-NTuple{4, Any}"><code>DigitalComm.getBFOFDM_oversampledGridSubcarriers</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><hr/><p>Returns the oversampled grid at the subcarrier level for BF-OFDM. In BF-OFDM as we use a nOFDM<em>nFBMC grid with nOFDM</em>δ allocated subcarrier per carriers (for a precodinng stage of size nOFDM), it can be usefull to get all the index of the allocated subcarrier per carrier. The output is a vector of the allocated subcarrier index in the oversampled frequency grid.</p><p><strong>–- Syntax</strong></p><p>subcarrierTx	= getCarrierFromSubcarriers(nOFDM,δ,fbmcCarriers)</p><p><strong>–- Input parameters</strong></p><ul><li>nOFDM	  : OFDM subcarrier size [Int]</li><li>δ		  : Rate factor [Float64]</li><li>fbmcCarriers : Vector of allocated carrier [Array{Int,L}], L &lt; nFBMC<em>nOFDM</em>δ</li></ul><p><strong>–- Output parameters</strong></p><ul><li>subcarrierTx : Vector of allocated carriers [Array{Int, L<em>nOFDM</em>δ  ]</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/Waveforms/BFOFDM/carrierManipulation.jl#L73-L87">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.getBFOFDM_subCarrierFromFBMCCarriers-NTuple{4, Any}" href="#DigitalComm.getBFOFDM_subCarrierFromFBMCCarriers-NTuple{4, Any}"><code>DigitalComm.getBFOFDM_subCarrierFromFBMCCarriers</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><hr/><p>Get the index of the oversampled carrier (i.e subcarriers index in the precoding field) based on the index of the allocated carriers. It is assumed that for each carriers, all subcarriers are enable (with orthogonality, i.e Nδ allocated subcarriers).</p><p><strong>–- Syntax</strong></p><p>subcarriers	= getBFOFDM_subCarrierFromFBMCCarriers(nFBMC,nOFDM,δ,fbmcCarriers)</p><p><strong>–- Input parameters</strong></p><ul><li>nFBMC	  : FBMC carrier size (number of carriers) [Int]</li><li>nOFDM	  : OFDM subcarrier size [Int]</li><li>δ		  : Rate factor [Float64]</li><li>fbmcCarriers : Vector of allocated carrier [Array{Int,L}], L &lt; nFBMC</li></ul><p><strong>–- Output parameters</strong></p><ul><li>subcarriers : Vector of allocated subcarriers [Array{Int, L δ ]</li></ul><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/Waveforms/BFOFDM/carrierManipulation.jl#L3-L17">source</a></section></article><h2 id="FBMC"><a class="docs-heading-anchor" href="#FBMC">FBMC</a><a id="FBMC-1"></a><a class="docs-heading-anchor-permalink" href="#FBMC" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.fbmcSigGen-NTuple{4, Any}" href="#DigitalComm.fbmcSigGen-NTuple{4, Any}"><code>DigitalComm.fbmcSigGen</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><hr/><p>Generate a FBMC-OQAM signal in time domain, based on input complex matrix (before OQAM processing) and FBMC parameters.</p><p>Transmitter is based on Polyphase Network implementation, with PHYDIAS filter (parametrized by overlapping factor).</p><p><strong>–- Syntax</strong></p><p>fbmcSigGen(qamMat,nFFT,K,allocatedSubcarriers)</p><p><strong>–- Input parameters</strong></p><ul><li>qamMat	: Complex QAM Time-Frequency matrix [Array{Complex{Float64}}]</li><li>nFFT		: FFT size  [Int]</li><li>K			: Overlapping factor [Int] </li><li>allocatedSubcarriers	: Vector of allocated subcarriers [Array{Int}]</li></ul><p><strong>–- Output parameters</strong></p><ul><li>sigId		: Complex baseband signal in time domain [Array{Complex{Float64}},nbEch]; nbEch = (2<em>nbSymb-1)</em>nFFT<em>/2+nFFT</em>K)</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/Waveforms/FBMC/fbmcSigGen.jl#L130-L146">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.getFBMCFilter-Tuple{Any, Any}" href="#DigitalComm.getFBMCFilter-Tuple{Any, Any}"><code>DigitalComm.getFBMCFilter</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><hr/><p>Returns the PHYDIAS time domain impulse response of desired FBMC filter parametrized by its overlapping factor and FFT size</p><p><strong>–- Syntax</strong></p><p>p = getFBMCFilter(K,nFFT,type);</p><p><strong>–- Input parameters</strong></p><ul><li>K	  : Overlapping factor</li><li>nFFT: FFT size </li></ul><p><strong>–- Output parameters</strong></p><ul><li>p	  : FBMC time impulse response </li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/Waveforms/FBMC/fbmcSigGen.jl#L74-L86">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.initFBMC-Tuple{Any, Any, Any}" href="#DigitalComm.initFBMC-Tuple{Any, Any, Any}"><code>DigitalComm.initFBMC</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><hr/><p>Initiate FBMC structure </p><p><strong>–- Syntax</strong></p><p>fbmc = initFBMC(nFFT,K,allocatedSubcarriers)</p><p><strong>–- Input parameters</strong></p><ul><li>nFFT	  : FFT size </li><li>K		  : Overlapping factor </li><li>allocatedSubcarriers	: Vector of allocated subcarriers [Array{Int}]</li></ul><p><strong>–- Output parameters</strong></p><ul><li>fbmc	  : FBMC structure [StrucFBMC]</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/Waveforms/FBMC/fbmcSigGen.jl#L17-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.oqamMapping-Tuple{Any}" href="#DigitalComm.oqamMapping-Tuple{Any}"><code>DigitalComm.oqamMapping</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><hr/><p>Apply OQAM pre-processing to incoming matrix qamMat of size nbSubcarriers x nbSymb</p><p><strong>–- Syntax</strong></p><p>oqamMat = oqamConversion(qamMat)</p><p><strong>–- Input parameters</strong></p><ul><li>qamMat : Input complex qam Matrix [Array{Complex{Float64,nbSubcarriers,nbSymb}}]</li></ul><p><strong>–- Output parameters</strong></p><ul><li>oqamMat : OQAM matrix (pure real and pure imag. alterns) [Array{Complex{Float64,nbSubcarriers,nbSymb*2}}]</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/Waveforms/FBMC/fbmcSigGen.jl#L40-L51">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.StrucFBMC" href="#DigitalComm.StrucFBMC"><code>DigitalComm.StrucFBMC</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><hr/><p>FBMC waveform structure</p><p><strong>–- Syntax</strong></p><ul><li>nFFT	  : FFT size </li><li>K		  : Overlapping factor </li><li>allocatedSubcarriers	: Vector of allocated subcarriers [Array{Int}]</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/Waveforms/FBMC/fbmcSigGen.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.fbmcSigDecode-NTuple{4, Any}" href="#DigitalComm.fbmcSigDecode-NTuple{4, Any}"><code>DigitalComm.fbmcSigDecode</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><hr/><p>Demodulate FBMC waveform based on the dual operation of fbmcSigGen</p><p>FBMC is parametrized by its FFT size, its cyclic prefix length (in samples) and the allocSubcarriers vector</p><p><strong>Syntax</strong></p><p>sigId	= fbmcSigDecode(sigRx,nFFT,K,allocSubcarriers)</p><p><strong>–-  Input parameters</strong></p><ul><li>sigRx	  : Time domain FBMC signal  [Array{Complex{Float64},nbEch}]</li><li>nFFT	  : FFT size [Int]</li><li>K		  : Overlapping factor [Int]</li></ul><p>allocSubcarriers : Vector of index of allocated subcarriers [Array{Int,nbSubcarriers}]</p><p><strong>–-  Output parameters</strong></p><ul><li>qamMat  : Time frequency matrix : [Array{Complex{Float64},nbSubcarriers,nbSymb}]</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/Waveforms/FBMC/fbmcSigDecode.jl#L35-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.oqamDemapping-Tuple{Any}" href="#DigitalComm.oqamDemapping-Tuple{Any}"><code>DigitalComm.oqamDemapping</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><hr/><p>Apply OQAM demapping to incoming OQAM matrix qamMat of size nbSubcarriers x 2nbSymb</p><p><strong>–- Syntax</strong></p><p>qamMat = oqamDemapping(qamMat)</p><p><strong>–- Input parameters</strong></p><ul><li>oqamMat : OQAM matrix (pure real and pure imag. alterns) [Array{Complex{Float64,nbSubcarriers,nbSymb*2}}]</li></ul><p><strong>–- Output parameters</strong></p><ul><li>qamMat : Output complex qam Matrix [Array{Complex{Float64,nbSubcarriers,nbSymb}}]</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/Waveforms/FBMC/fbmcSigDecode.jl#L1-L13">source</a></section></article><h2 id="OFDM"><a class="docs-heading-anchor" href="#OFDM">OFDM</a><a id="OFDM-1"></a><a class="docs-heading-anchor-permalink" href="#OFDM" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.initOFDM-Tuple{Any, Any, Any}" href="#DigitalComm.initOFDM-Tuple{Any, Any, Any}"><code>DigitalComm.initOFDM</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><hr/><p>Create OFDM structure </p><p><strong>–- Syntax</strong></p><p>ofdm	= initOFDM(nFFT,nCP,allocatedSubcarriers)</p><p><strong>–- Input parameters</strong></p><ul><li>nFFT	  : FFT size [Int]</li><li>nCP	  : Cyclic prefix size [Int]</li><li>allocatedSubcarrier	: Vector of allocated subbcarriers [Array{Int}]</li></ul><p><strong>–- Output parameters</strong></p><ul><li>ofdm	  : OFDM structure [StrucOFDM] </li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/Waveforms/OFDM/ofdmSigGen.jl#L17-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.ofdmSigGen!-NTuple{5, Any}" href="#DigitalComm.ofdmSigGen!-NTuple{5, Any}"><code>DigitalComm.ofdmSigGen!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><hr/><p>Populate a OFDM signal in time domain based on input T/F matrix and OFDM parameters</p><p>qamMat is a complex symbol matrix (for instance QPSK) of size length(allocatedSubcarriers) x nbSymb </p><p>The output signal in time domain is of size (nFFT+nCP)xnbSymb.</p><p><strong>–- Syntax</strong></p><p>ofdmSigGen!(sigId,qamMat,nFFT,nCP,allocatedSubcarriers)</p><p><strong>–- Input parameters</strong></p><ul><li>sigId	  : Signal in time domain [Array{Complex{Float64}},(nFFT+nCP)xnbSymb]</li><li>qamMat  : Complex T/F matrix to map [Array{Float64},length(allocatedSubcarriers),nbSymb]</li><li>nFFT	  : FFT size [Int] </li><li>nCP	  : Cylic prefix size [Int] </li><li>allocatedSubcarrier	: Vector of allocated subbcarriers [Array{Int}]</li></ul><p><strong>–- Output parameters</strong></p><ul><li>[]</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/Waveforms/OFDM/ofdmSigGen.jl#L67-L87">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.ofdmSigGen!-Tuple{Any, Any, DigitalComm.StrucOFDM}" href="#DigitalComm.ofdmSigGen!-Tuple{Any, Any, DigitalComm.StrucOFDM}"><code>DigitalComm.ofdmSigGen!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><hr/><p>Populate a  OFDM signal in time domain based on input T/F matrix and OFDM structure  </p><p>qamMat is a complex symbol matrix (for instance QPSK) of size length(allocatedSubcarriers) x nbSymb </p><p>The output signal in time domain is of size (nFFT+nCP)xnbSymb.</p><p><strong>–- Syntax</strong></p><p>ofdmSigGen!(sigId,qamMat,nFFT,nCP,allocatedSubcarriers)</p><p><strong>–- Input parameters</strong></p><ul><li>sigId	  : Signal in time domain [Array{Complex{Float64}},(nFFT+nCP)xnbSymb]</li><li>qamMat  : Complex T/F matrix to map [Array{Float64},length(allocatedSubcarriers),nbSymb]</li><li>ofdm	  : OFDM structure [StrucOFDM]</li></ul><p><strong>–- Output parameters</strong></p><ul><li>[]</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/Waveforms/OFDM/ofdmSigGen.jl#L133-L151">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.ofdmSigGen-NTuple{4, Any}" href="#DigitalComm.ofdmSigGen-NTuple{4, Any}"><code>DigitalComm.ofdmSigGen</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><hr/><p>Create OFDM signal in time domain based on input T/F matrix and OFDM parameters</p><p>qamMat is a complex symbol matrix (for instance QPSK) of size length(allocatedSubcarriers) x nbSymb </p><p>The output signal in time domain is of size (nFFT+nCP)xnbSymb.</p><p><strong>–- Syntax</strong></p><p>sigId = ofdmSigGen(qamMat,nFFT,nCP,allocatedSubcarriers)</p><p><strong>–- Input parameters</strong></p><ul><li>qamMat  : Complex T/F matrix to map [Array{Float64},length(allocatedSubcarriers),nbSymb]</li><li>nFFT	  : FFT size [Int] </li><li>nCP	  : Cylic prefix size [Int] </li><li>allocatedSubcarrier	: Vector of allocated subbcarriers [Array{Int}]</li></ul><p><strong>–- Output parameters</strong></p><ul><li>sigId	  : Signal in time domain [Array{Complex{Float64}},(nFFT+nCP)xnbSymb]</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/Waveforms/OFDM/ofdmSigGen.jl#L40-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.ofdmSigGen-Tuple{Any, DigitalComm.StrucOFDM}" href="#DigitalComm.ofdmSigGen-Tuple{Any, DigitalComm.StrucOFDM}"><code>DigitalComm.ofdmSigGen</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><hr/><p>Create OFDM signal in time domain based on input T/F matrix and OFDM structure  </p><p>qamMat is a complex symbol matrix (for instance QPSK) of size length(allocatedSubcarriers) x nbSymb </p><p>The output signal in time domain is of size (nFFT+nCP)xnbSymb.</p><p><strong>–- Syntax</strong></p><p>sigId = ofdmSigGen(qamMat,nFFT,nCP,allocatedSubcarriers)</p><p><strong>–- Input parameters</strong></p><ul><li>qamMat  : Complex T/F matrix to map [Array{Float64},length(allocatedSubcarriers),nbSymb]</li><li>ofdm	  : OFDM structure [StrucOFDM]</li></ul><p><strong>–- Output parameters</strong></p><ul><li>sigId	  : Signal in time domain [Array{Complex{Float64}},(nFFT+nCP)xnbSymb]</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/Waveforms/OFDM/ofdmSigGen.jl#L110-L126">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.StrucOFDM" href="#DigitalComm.StrucOFDM"><code>DigitalComm.StrucOFDM</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><hr/><p>Structure for OFDM</p><p><strong>–- Syntax</strong></p><ul><li>nFFT		: FFT size [Int] </li><li>nCP		: Cyclic prefix size [Int] </li><li>allocatedSubcarriers	: Vector of allocated subbcarriers [Array{Int}]</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/Waveforms/OFDM/ofdmSigGen.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.ofdmSigDecode!-NTuple{5, Any}" href="#DigitalComm.ofdmSigDecode!-NTuple{5, Any}"><code>DigitalComm.ofdmSigDecode!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>ofdmSigDecode!</strong></p><p>Decodes a time domain OFDM signal and populate the  T/F matrix with decoded QAM symbols</p><p><strong>–- Syntax</strong></p><p>ofdmSigDecode(qamRx,sigId,nFFT,nCP,allocSubcarriers);</p><p><strong>–-  Input parameters</strong></p><ul><li>qamRx  : Time frequency matrix : [Array{Complex{Float64},nbSubcarriers,nbSymb}]</li><li>sigId	  : OFDM signal in time domain [Array{Complex{Float64},nbEch}]  ,(nbEch	: Number of samples: nbSymb*(nFFT+nCp))</li><li>nFFT	  : FFT size [Int]</li><li>nCp	  : Cyclic prefix size (in samples) [Int]</li></ul><p>allocSubcarriers : Vector of index of allocated subcarriers [Array{Int,nbSubcarriers}]</p><p><strong>–-  Output parameters</strong></p><ul><li>[]</li></ul><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/Waveforms/OFDM/ofdmSigDecode.jl#L25-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.ofdmSigDecode!-Tuple{Any, Any, DigitalComm.StrucOFDM}" href="#DigitalComm.ofdmSigDecode!-Tuple{Any, Any, DigitalComm.StrucOFDM}"><code>DigitalComm.ofdmSigDecode!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>ofdmSigDecode!</strong></p><p>Decodes a time domain OFDM signal and returns a T/F matrix with decoded QAM symbols</p><p><strong>–- Syntax</strong></p><p>qamRx	= ofdmSigDecode!(qamRx,sigId,ofdm);</p><p><strong>–-  Input parameters</strong></p><ul><li>qamRx  : Time frequency matrix : [Array{Complex{Float64},nbSubcarriers,nbSymb}]</li><li>sigId	  : OFDM signal in time domain [Array{Complex{Float64},nbEch}]  ,(nbEch	: Number of samples: nbSymb*(nFFT+nCp))</li><li>ofdm	  : OFDM structure [StrucOFDM]</li></ul><p><strong>–-  Output parameters</strong></p><ul><li>[]</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/Waveforms/OFDM/ofdmSigDecode.jl#L75-L89">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.ofdmSigDecode-NTuple{4, Any}" href="#DigitalComm.ofdmSigDecode-NTuple{4, Any}"><code>DigitalComm.ofdmSigDecode</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>ofdmSigDecode</strong></p><p>Decodes a time domain OFDM signal and returns a T/F matrix with decoded QAM symbols</p><p><strong>–- Syntax</strong></p><p>qamRx	= ofdmSigDecode(sigId,nFFT,nCP,allocSubcarriers);</p><p><strong>–-  Input parameters</strong></p><ul><li>sigId	  : OFDM signal in time domain [Array{Complex{Float64},nbEch}]  ,(nbEch	: Number of samples: nbSymb*(nFFT+nCp))</li><li>nFFT	  : FFT size [Int]</li><li>nCp	  : Cyclic prefix size (in samples) [Int]</li></ul><p>allocSubcarriers : Vector of index of allocated subcarriers [Array{Int,nbSubcarriers}]</p><p><strong>–-  Output parameters</strong></p><ul><li>qamRx  : Time frequency matrix : [Array{Complex{Float64},nbSubcarriers,nbSymb}]</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/Waveforms/OFDM/ofdmSigDecode.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.ofdmSigDecode-Tuple{Any, DigitalComm.StrucOFDM}" href="#DigitalComm.ofdmSigDecode-Tuple{Any, DigitalComm.StrucOFDM}"><code>DigitalComm.ofdmSigDecode</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>ofdmSigDecode</strong></p><p>Decodes a time domain OFDM signal and returns a T/F matrix with decoded QAM symbols</p><p><strong>–- Syntax</strong></p><p>qamRx	= ofdmSigDecode(sigId,ofdm);</p><p><strong>–-  Input parameters</strong></p><ul><li>sigId	  : OFDM signal in time domain [Array{Complex{Float64},nbEch}]  ,(nbEch	: Number of samples: nbSymb*(nFFT+nCp))</li><li>ofdm	  : OFDM structure [StrucOFDM]</li></ul><p><strong>–-  Output parameters</strong></p><ul><li>qamRx  : Time frequency matrix : [Array{Complex{Float64},nbSubcarriers,nbSymb}]</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/Waveforms/OFDM/ofdmSigDecode.jl#L57-L70">source</a></section></article><h2 id="SC-FDMA"><a class="docs-heading-anchor" href="#SC-FDMA">SC-FDMA</a><a id="SC-FDMA-1"></a><a class="docs-heading-anchor-permalink" href="#SC-FDMA" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.convT-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N}} where T" href="#DigitalComm.convT-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N}} where T"><code>DigitalComm.convT</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><hr/><p>Perform time domain naive convolution. For UF-OFDM, size of filter is small so doing it in frequency domain is not appropriate</p><p><strong>–- Syntax</strong></p><p>c = convT(a,b);</p><p><strong>–- Input parameters</strong></p><ul><li>a	  : First signal </li><li>b	  : Second signal </li></ul><p><strong>–- Output parameters</strong></p><ul><li>c	  : a * b </li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/Waveforms/UFOFDM/ufofdmSigGen.jl#L151-L164">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.initUFOFDM-Tuple{Any, Any, Any}" href="#DigitalComm.initUFOFDM-Tuple{Any, Any, Any}"><code>DigitalComm.initUFOFDM</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><hr/><p>Create UF-OFDM structure</p><p><strong>–- Syntax</strong></p><p>ufofdm	= initUFOFDM(nFFT,L,allocatedSubcarriers;sizeRB=12,applyPD=1,attenuation=40)</p><p><strong>–- Input parameters</strong></p><ul><li>nFFT		: FFT size [Int] </li><li>L			: Filter size [Int]</li><li>allocatedSubcarriers	: Vector of allocated subbcarriers [Array{Int}] </li><li>sizeRB	: Carrier size in terms of subcarrier (often 12)  [Array{Int}]</li><li>applyPD	: Apply Pre-distortion at Tx stage (default 1, 0 : not applied) [Int=0 or 1] </li><li>attenuation : dolphChebyshev filter attenation </li><li>filterTaps  : Filter impulse response coefficient [Array{Float64}]- </li></ul><p><strong>–- Output parameters</strong></p><ul><li>ufofdm	: UF-OFDM structure [StrucUFOFDM] </li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/Waveforms/UFOFDM/ufofdmSigGen.jl#L26-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.ufofdmSigGen-NTuple{4, Any}" href="#DigitalComm.ufofdmSigGen-NTuple{4, Any}"><code>DigitalComm.ufofdmSigGen</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><hr/><p>Apply Universal Filtered Orthogonal Frequency Division Multiplexing (UF-OFDM) to the time frequency matrix qamMat and returns a time domain UF-OFDM signal [1,2]</p><p>ufofdm is parametrized by its FFT size, the filter length (in samples) and the allocatedSubcarriers vector. Optional parameters are carrier size in subcarrier (by default RB size which is 12) Dolph-Chebyshev window attenuation (40) and predistortion application (set to 1)</p><p><strong>–- Syntax</strong></p><p>sigId	= genereSignalufofdm(qamMat,nFFT,nCp,allocatedSubcarriers;sizeRB=12,applyPD=1,attenuation=40)</p><p><strong>–-  Input parameters</strong></p><ul><li>qamMat  : Time frequency matrix : [Array{Complex{Float64},nbSubcarriers,nbSymb}]</li><li>nbSymb			: Number of ufofdm symbol tro be transmitted</li><li>nbSubcarriers	: Number of allocated subcarriers (shall be &lt; nFFT)</li><li>nFFT	  : FFT size [Int]</li><li>L		  : Dolph Chebyshev filter length [Int]</li><li>allocatedSubcarriers : Vector of index of allocated subcarriers [Array{Int,nbSubcarriers}]</li><li>sizeRB  : Carrier size in subcarriers (default : LTE RB size: 12) [Int]</li><li>applyPD : Filter shape compensation (enabled by default) [Int]</li><li>attenuation : DC filter attenation in dB (default: 90) [Float64]</li><li>filterTaps : Filter coefficient (default empty and recreated)</li><li>pdCoeffs	  : Predistortion  Filter coefficient (default empty and recreated)</li></ul><p><strong>–-  Output parameters</strong></p><ul><li>sigId	  : ufofdm signal in time domain [Array{Complex{Float64},nbEch}]</li></ul><p><strong>References</strong></p><ul><li>[1] R. Gerzaguet and al. The 5G candidate waveform race: a comparison of complexity and performance. EURASIP Journal on Wireless Communications and Networking, 2017</li><li>[2] V. Vakilian and al: Universal-filtered multi-carrier technique for wireless systems beyond LTE. Proc. IEEE Globecom Workshops (GC Wkshps), 2013</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/Waveforms/UFOFDM/ufofdmSigGen.jl#L59-L86">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.ufofdmSigGen-Tuple{Any, DigitalComm.StrucUFOFDM}" href="#DigitalComm.ufofdmSigGen-Tuple{Any, DigitalComm.StrucUFOFDM}"><code>DigitalComm.ufofdmSigGen</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><hr/><p>Apply Universal Filtered Orthogonal Frequency Division Multiplexing (UF-OFDM) to the time frequency matrix qamMat and returns a time domain UF-OFDM signal [1,2]</p><p>ufofdm is parametrized by its FFT size, the filter length (in samples) and the allocatedSubcarriers vector. Optional parameters are carrier size in subcarrier (by default RB size which is 12) Dolph-Chebyshev window attenuation (40) and predistortion application (set to 1)</p><p><strong>–- Syntax</strong></p><p>sigId	= genereSignalufofdm(qamMat,ufofdm);</p><p><strong>–-  Input parameters</strong></p><ul><li>qamMat  : Time frequency matrix : [Array{Complex{Float64},nbSubcarriers,nbSymb}]</li><li>ufofdm  : UF-OFDM structure [StrucUFOFDM]</li></ul><p><strong>–-  Output parameters</strong></p><ul><li>sigId	  : ufofdm signal in time domain [Array{Complex{Float64},nbEch}]</li></ul><p><strong>References</strong></p><ul><li>[1] R. Gerzaguet and al. The 5G candidate waveform race: a comparison of complexity and performance. EURASIP Journal on Wireless Communications and Networking, 2017</li><li>[2] V. Vakilian and al: Universal-filtered multi-carrier technique for wireless systems beyond LTE. Proc. IEEE Globecom Workshops (GC Wkshps), 2013</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/Waveforms/UFOFDM/ufofdmSigGen.jl#L227-L245">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.StrucUFOFDM" href="#DigitalComm.StrucUFOFDM"><code>DigitalComm.StrucUFOFDM</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Structure for UFOFDM</p><p><strong>–- Syntax</strong></p><ul><li>nFFT		: FFT size [Int] </li><li>L			: Filter size [Int]</li><li>allocatedSubcarriers	: Vector of allocated subbcarriers [Array{Int}] </li><li>sizeRB	: Carrier size in terms of subcarrier (often 12)  [Array{Int}]</li><li>applyPD	: Apply Pre-distortion at Tx stage (default 1, 0 : not applied) [Int=0 or 1] </li><li>attenuation : dolphChebyshev filter attenation </li><li>filterTaps  : Filter impulse response coefficient [Array{Float64}]</li><li>pd		  : PD coefficients [Array{Complex{Float64}}]</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/Waveforms/UFOFDM/ufofdmSigGen.jl#L1-L15">source</a></section></article><h2 id="UF-OFDM"><a class="docs-heading-anchor" href="#UF-OFDM">UF-OFDM</a><a id="UF-OFDM-1"></a><a class="docs-heading-anchor-permalink" href="#UF-OFDM" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.initSCFDMA-NTuple{4, Any}" href="#DigitalComm.initSCFDMA-NTuple{4, Any}"><code>DigitalComm.initSCFDMA</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><hr/><p>Create SCFDMA structure </p><p><strong>–- Syntax</strong></p><p>ofdm	= initSCFDMA(nFFT,nCP,allocatedSubcarriers)</p><p><strong>–- Input parameters</strong></p><ul><li>nFFT	  : FFT size [Int]</li><li>nCP	  : Cyclic prefix size [Int]</li><li>allocatedSubcarrier	: Vector of allocated subbcarriers [Array{Int}]</li><li>sizeDFT	: Size of DFT precoder (classic value is 12) [Int]</li></ul><p><strong>–- Output parameters</strong></p><ul><li>scfdma: SCFDMA structure [StrucSCFDMA] </li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/Waveforms/SCFDMA/scfdmaSigGen.jl#L20-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.scfdmaSigGen-NTuple{5, Any}" href="#DigitalComm.scfdmaSigGen-NTuple{5, Any}"><code>DigitalComm.scfdmaSigGen</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><hr/><p>Create SCFDMA signal in time domain based on input T/F matrix and SCFDMA parameters. SCFDMA apply a precoder before the IFFT at the transmitter side in order to lower the signal fluctuation</p><p>qamMat is a complex symbol matrix (for instance QPSK) of size length(allocatedSubcarriers) x nbSymb </p><p>The output signal in time domain is of size (nFFT+nCP)xnbSymb.</p><p><strong>–- Syntax</strong></p><p>sigId = scfdmaSigGen(qamMat,nFFT,nCP,allocatedSubcarriers)</p><p><strong>–- Input parameters</strong></p><ul><li>qamMat  : Complex T/F matrix to map [Array{Float64},length(allocatedSubcarriers),nbSymb]</li><li>nFFT	  : FFT size [Int] </li><li>nCP	  : Cylic prefix size [Int] </li><li>allocatedSubcarrier	: Vector of allocated subbcarriers [Array{Int}]</li><li>sizeDFT	: Size of DFT precoder (classic value is 12) [Int]</li></ul><p><strong>–- Output parameters</strong></p><ul><li>sigId	  : Signal in time domain [Array{Complex{Float64}},(nFFT+nCP)xnbSymb]</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/Waveforms/SCFDMA/scfdmaSigGen.jl#L44-L63">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.StrucSCFDMA" href="#DigitalComm.StrucSCFDMA"><code>DigitalComm.StrucSCFDMA</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><hr/><p>Structure for SCFDMA</p><p><strong>–- Syntax</strong></p><ul><li>nFFT		: FFT size [Int] </li><li>nCP		: Cyclic prefix size [Int] </li><li>allocatedSubcarriers	: Vector of allocated subbcarriers [Array{Int}]</li><li>sizeDFT	: Size of DFT precoder (classic value is 12) [Int]</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/Waveforms/SCFDMA/scfdmaSigGen.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.scfdmaPostProcessing-Tuple{Any, Any}" href="#DigitalComm.scfdmaPostProcessing-Tuple{Any, Any}"><code>DigitalComm.scfdmaPostProcessing</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><hr/><p>Apply Post processing for SC-FDMA (i.e DFT post-processing stage). This function can be called if scfdmaSigDecode is called with post processing flag to 0 (if frequency egalisation is done for example)</p><p><strong>–- Syntax</strong></p><p>qamPost	  = scfdmaPostProcessing(qamMat,sizeDFT)</p><p><strong>–- Input parameters</strong></p><ul><li>qamMat  : T/F matrix after Rx FFT (and before Rx IDFT) [Array{Complex{Float64}},nbSubcarriers,nbSymb]</li><li>sizeDFT	: Precoder bloc size (often 12)</li></ul><p><strong>–- Output parameters</strong></p><ul><li>qamPost	: T/F matrix after IDFT processing [Array{Complex{Float64},nbSubcarriers,nbSymb}]</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/Waveforms/SCFDMA/scfdmaSigDecode.jl#L43-L55">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.scfdmaSigDecode" href="#DigitalComm.scfdmaSigDecode"><code>DigitalComm.scfdmaSigDecode</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><hr/><p>Apply SCFDMA demodulator to input signal and returns the T/F QAM matrix</p><p><strong>–- Syntax</strong></p><p>qamRx	= scfdmaSigDecode(sigId,nFFT,nCP,allocSubcarriers,sizeDFT);</p><p><strong>–- Input parameters</strong></p><p><strong>–-  Input parameters</strong></p><ul><li>sigId	  : SCFDMA signal in time domain [Array{Complex{Float64},nbEch}]</li><li>nFFT	  : FFT size [Int]</li><li>nCp	  : Cyclic prefix size (in samples) [Int]</li><li>allocSubcarriers : Vector of index of allocated subcarriers [Array{Int,nbSubcarriers}]</li><li>sizeDFT	: Post processing size (DFT size)</li><li>doPostProcessing : Do the post processing stage (IDFT): Default 1. In some case, we need the raw data (i.e data before postprocessing stage) such as in channel equalisation. In this case, the post processing should be done in a separate step (with the call of scfdmaPostProcessing function)</li></ul><p><strong>–-  Output parameters</strong></p><ul><li>qamRx  : Time frequency matrix : [Array{Complex{Float64},nbSubcarriers,nbSymb}]</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/Waveforms/SCFDMA/scfdmaSigDecode.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.scfdmaSigDecode" href="#DigitalComm.scfdmaSigDecode"><code>DigitalComm.scfdmaSigDecode</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><hr/><p>Apply SCFDMA demodulator to input signal and returns the T/F QAM matrix</p><p><strong>–- Syntax</strong></p><p>qamRx	= scfdmaSigDecode(sigId,nFFT,nCP,allocSubcarriers,sizeDFT);</p><p><strong>–- Input parameters</strong></p><p><strong>–-  Input parameters</strong></p><ul><li>sigId	  : SCFDMA signal in time domain [Array{Complex{Float64},nbEch}]</li><li>scfdma  : SCFDMA structure [StrucSCFDMA]</li><li>doPostProcessing : Do the post processing stage (IDFT): Default 1. In some case, we need the raw data (i.e data before postprocessing stage) such as in channel equalisation. In this case, the post processing should be done in a separate step (with the call of scfdmaPostProcessing function)</li></ul><p><strong>–-  Output parameters</strong></p><ul><li>qamRx  : Time frequency matrix : [Array{Complex{Float64},nbSubcarriers,nbSymb}]</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/Waveforms/SCFDMA/scfdmaSigDecode.jl#L71-L85">source</a></section></article><h2 id="WOLA"><a class="docs-heading-anchor" href="#WOLA">WOLA</a><a id="WOLA-1"></a><a class="docs-heading-anchor-permalink" href="#WOLA" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.initWOLA-NTuple{7, Any}" href="#DigitalComm.initWOLA-NTuple{7, Any}"><code>DigitalComm.initWOLA</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><hr/><p>Create and initiate a WOLA waveform structure </p><p><strong>–- Syntax</strong></p><p>wola = initWOLA(nFFT,nCP,allocatedSubcarriers,winFuncTx,winLengthTx,winFuncRx,winLengthRx;windowTx=[],windowRx=[])</p><p><strong>–- Input parameters</strong></p><ul><li>nFFT	  : FFT size [Int] </li><li>nCP	  : CP size [Int] </li><li>allocatedSubcarriers	: Vector of allocated subcarriers [Array{Int}] </li><li>winFuncTx	  : Name of window used @Tx </li><li>winLengthTx : Size of window @Tx </li><li>winFuncRx	  : Name of window used @Rx </li><li>winLengthRx : Size of window @Rx </li><li>windowTx	  : Coefficient of Tx window. By default it is empty. To force a given window, populate this vector. If let empty, the window will be created based on winLengthTx and winFuncTx</li><li>windowRx	  : Coefficient of Rx window. By default it is empty. To force a given window, populate this vector. If let empty, the window will be created based on winLengthRx and winFuncRx</li></ul><p><strong>–- Output parameters</strong></p><ul><li>wola		  : Waveform structure</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/Waveforms/WOLA/wolaSigGen.jl#L22-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.wolaSigGen" href="#DigitalComm.wolaSigGen"><code>DigitalComm.wolaSigGen</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><hr/><p>Apply Weighted Overlap and Add Orthogonal Frequency Division Multiplexing (WOLA-OFDM) to the time frequency matrix qamMat and returns a time domain OFDM signal OFDM is parametrized by its FFT size, its cyclic prefix length (in samples) and the allocSubcarriers vector. The WOLA part is parametrized by the window applied at each beginning and ending of symbols. The window size can be (and is likely to be) higher than the length of the CP and pure OFDM compatibility is ensured by overlapping the symbols. The interested reader can refer to [1] [2] and [3] for WOLA principle description.</p><p><strong>–-</strong></p><p><strong>Syntax</strong></p><p>sigId	= wolaSigGen(qamMat,nFFT,nCP,allocSubcarriers,winFunc,winLength=0)</p><p><strong>–-  Input parameters</strong></p><ul><li>qamMat  : Time frequency matrix : [Array{Complex{Float64},nbSubcarriers,nbSymb}]</li><li>nbSymb			: Number of OFDM symbol tro be transmitted</li><li>nbSubcarriers	: Number of allocated subcarriers (shall be &lt; nFFT)</li><li>nFFT	  : FFT size [Int]</li><li>nCP	  : Cyclic prefix size (in samples) [Int]</li><li>allocSubcarriers : Vector of index of allocated subcarriers [Array{Int,nbSubcarriers}]</li><li>winFunc : Type of window. Can be a string of supported window or directly the window taps.</li><li>winLength : Length of window. This parameter is not used if winFunc is an array of the window tap.</li></ul><p><strong>–-  Output parameters</strong></p><ul><li>sigId	  : WOLA-OFDM signal in time domain [Array{Complex{Float64},nbEch}]. nbEch	: Number of samples: nbSymb*(nFFT+nCP)</li></ul><p><strong>–-</strong></p><p><strong>Supported window</strong></p><p>-	&quot;Triangle&quot;		: Triangle window -	&quot;srrc&quot;			: Square Root Raised Cosine -	&quot;Meyer&quot;			: Meyer window (See [1])</p><p><strong>–-</strong></p><p><strong>References</strong></p><ul><li>[1] R. Zayani, Y. Medjahdi, H. Shaiek and D. Roviras, &quot;WOLA-OFDM: A Potential Candidate for Asynchronous 5G,&quot; 2016.</li><li>[2] Y. Medjahdi and al, &quot;On the road to 5G: Comparative study of Physical layer in MTC context&quot;, 2017.</li><li>[3] R. Gerzaguet and al, &quot;Comparison of Promising Candidate Waveforms for 5G: WOLA-OFDM Versus BF-OFDM&quot;, 2017.</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/Waveforms/WOLA/wolaSigGen.jl#L77-L109">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.StrucWOLA" href="#DigitalComm.StrucWOLA"><code>DigitalComm.StrucWOLA</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><hr/><p>WOLA waveform structure </p><p><strong>–- Syntax</strong></p><ul><li>nFFT	  : FFT size [Int] </li><li>nCP	  : CP size [Int] </li><li>allocatedSubcarriers	: Vector of allocated subcarriers [Array{Int}] </li><li>windowTx	: Window used @ transmitter side </li><li>windowRx	: Window used @ recevier side </li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/Waveforms/WOLA/wolaSigGen.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DigitalComm.wolaSigDecode" href="#DigitalComm.wolaSigDecode"><code>DigitalComm.wolaSigDecode</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><hr/><p>Apply WOLA-OFDM demodulator to input signal and returns the T/F QAM matrix</p><p><strong>–-</strong></p><p>Syntax qamRx	= wolaSigDecode(sigId,nFFT,nCP,allocSubcarriers);</p><p><strong>–-  Input parameters</strong></p><ul><li>sigId	  : OFDM signal in time domain [Array{Complex{Float64},nbEch}]</li><li>nbEch	: Number of samples: nbSymb*(nFFT+nCP)</li><li>nFFT	  : FFT size [Int]</li><li>nCP	  : Cyclic prefix size (in samples) [Int]</li><li>allocSubcarriers : Vector of index of allocated subcarriers [Array{Int,nbSubcarriers}]</li><li>winLengthTx	: Window size @Tx side (FFT rotation)</li><li>doTailBiting	: Do tail biting approach (by default 1) [Int]</li><li>winFunc : Type of window. Can be a string of supported window or directly the window taps.</li><li>winLength : Length of window. This parameter is not used if winFunc is an array of the window tap.</li></ul><p><strong>–-  Output parameters</strong></p><ul><li>qamMat  : Time frequency matrix : [Array{Complex{Float64},nbSubcarriers,nbSymb}]</li></ul><p><strong>–-</strong></p><p><strong>Supported window</strong></p><p>-	&quot;Triangle&quot;		: Triangle window -	&quot;srrc&quot;			: Square Root Raised Cosine -	&quot;Meyer&quot;			: Meyer window (See [1])</p><p><strong>–-</strong></p><p><strong>References</strong></p><ul><li>[1] R. Zayani, Y. Medjahdi, H. Shaiek and D. Roviras, &quot;WOLA-OFDM: A Potential Candidate for Asynchronous 5G,&quot; 2016.</li><li>[2] Y. Medjahdi and al, &quot;On the road to 5G: Comparative study of Physical layer in MTC context&quot;, 2017.</li><li>[3] R. Gerzaguet and al, &quot;Comparison of Promising Candidate Waveforms for 5G: WOLA-OFDM Versus BF-OFDM&quot;, 2017.</li></ul><p><strong>–-</strong></p><p><strong>v 1.0 - Robin Gerzaguet.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTelecom/DigitalComm.jl/blob/9cd9e4ef8118bb49600c20602b7126c74f5ab0d2/src/Waveforms/WOLA/wolaSigDecode.jl#L1-L32">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Introduction to DigitalComm</a><a class="docs-footer-nextpage" href="../Examples/example_AWGN/">Transmission of xQAM with additive white Gaussian noise »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.1 on <span class="colophon-date" title="Thursday 17 April 2025 14:38">Thursday 17 April 2025</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
