var documenterSearchIndex = {"docs":
[{"location":"base/#Function-overview","page":"Function list","title":"Function overview","text":"","category":"section"},{"location":"base/#Common-functions","page":"Function list","title":"Common functions","text":"","category":"section"},{"location":"base/","page":"Function list","title":"Function list","text":"Modules = [DigitalComm]\nPages   = [\"DigitalComm.jl\"]\nOrder   = [:function, :type]","category":"page"},{"location":"base/#DigitalComm.avgPower-Tuple{Any}","page":"Function list","title":"DigitalComm.avgPower","text":"\n\nCalculate the average power of the input signal  σ\t= 1 / N Σ | x[n] | ^2 \n\n–- Syntax\n\nσ\t= avgPower(x);\n\n–- Input parameters\n\nx\t  : Input signal [Array{Any}]\n\n–- Output parameters\n\nσ\t  : Estimated power [Float64]\n\n–-\n\nv 1.0 - Robin Gerzaguet.\n\n\n\n\n\n","category":"method"},{"location":"base/#DigitalComm.getSIR","page":"Function list","title":"DigitalComm.getSIR","text":"\n\nReturns the Signal to interference ratio expressed in dB (or in linear) between a obersvation signal d(n) and a reference signal u(n) The ratio is expressed as 10*log10( E[ || d(n) - u(n) || / E[||u(n)||^2]  )  with E the expectation wrt to time  The 2 vectors d and u should have the same length L\n\n–- Syntax\n\nsir = getSIR( d, u , type=\"dB\")\n\n–-  Input parameter\n\nd\t: Observation signal [Array{Any}]\nu\t: Reference signal [Array{Any}]\t\ntype: Output unit [String]: \"dB\" or \"Linear\" (default, \"dB\")\n\n–- Output parameters\n\nsir\t: Signal to interference ratio in unit type\n\n–-\n\nv 1.0 - Robin Gerzaguet.\n\n\n\n\n\n","category":"function"},{"location":"base/#DigitalComm.qFunc-Tuple{Any}","page":"Function list","title":"DigitalComm.qFunc","text":"\n\nReturns the Q function used for Bit error rate computation in digital system   Q(x)= 1/2 erfc(x/sqrt(2)) erfc is the Complexmplementary error function, i.e. the accurate version of 1-erf(x) for large x erfc is inherited from DSP\n\n–- Syntax\n\ny = qfunc(x)\n\n–- Input parameters\n\nx: Input [Float64]\n\n–- Output parameters\n\ny: Q(x)[Float64] \n\n–-\n\nv 1.0 - Robin Gerzaguet.\n\n\n\n\n\n","category":"method"},{"location":"base/#DigitalComm.Waveform","page":"Function list","title":"DigitalComm.Waveform","text":"\n\nAbstract type gathering all waveform configuration \n\nv 1.0 - Robin Gerzaguet.\n\n\n\n\n\n","category":"type"},{"location":"base/#NRZI-Encoding","page":"Function list","title":"NRZI Encoding","text":"","category":"section"},{"location":"base/","page":"Function list","title":"Function list","text":"Modules = [DigitalComm]\nPages   = [\"NRZI.jl\"]\nOrder   = [:function, :type]","category":"page"},{"location":"base/#DigitalComm.decodeNRZI","page":"Function list","title":"DigitalComm.decodeNRZI","text":"decodeNRZI(bits::AbstractVector, transitions::Symbol=:low)::AbstractVector\n\nDecode a  Non-Return-to-Zero Inverted (NRZI) encoded bit sequence. Expects a vector of bits, e.g. [0, 1, 1, 0, 0, 1, 0, 1, 0, 1].\n\nArguments\n\nbits::AbstractVector: Vector of bits to encode.\ntransitions::Symbol: Symbol represented by a transition in the NRZI coded sequence (:low/:high). Defaults to :low.\n\nReturns\n\ndecoded_bits::AbstractVector: Vector of decoded bits. The first bit of the output depends on a value of a memory bit in the decoder. this value is set to 0.\n\nExamples\n\njulia> decoded_bits = decodeNRZI(Int32[1, 1, 1, 0, 1, 1], :low);\n\njulia> transpose(decoded_bits)\n1×6 transpose(::Vector{Int32}) with eltype Int32:\n 0  1  1  0  0  1\n\nThe example below shows how the transitions argument affects the decoded bit sequence.\n\njulia> decoded_bits = decodeNRZI(Int32[0, 1, 0, 0, 0, 1], :high);\n\njulia> transpose(decoded_bits)\n1×6 transpose(::Vector{Int32}) with eltype Int32:\n 0  1  1  0  0  1\n\n\n\n\n\n","category":"function"},{"location":"base/#DigitalComm.encodeNRZI","page":"Function list","title":"DigitalComm.encodeNRZI","text":"encodeNRZI(bits::AbstractVector, transitions::Symbol=:low)::AbstractVector\n\nMap a bit sequence to Non-Return-to-Zero Inverted (NRZI) encoded bits. Expects a vector of bits, e.g. [0, 1, 1, 0, 0, 1, 0, 1, 0, 1].\n\nArguments\n\nbits::AbstractVector: Vector of bits to encode.\ntransitions::Symbol: Symbol indicating the symbol to transition on (:low/:high). Defaults to :low.\n\nReturns\n\nencoded_bits::AbstractVector: Vector of encoded bits.\n\nExamples\n\njulia> encoded_bits = encodeNRZI(Int32[0, 1, 1, 0, 0, 1], :low);\n\njulia> transpose(encoded_bits)\n1×6 transpose(::Vector{Int32}) with eltype Int32:\n 1  1  1  0  1  1\n\nThe example below shows how the transitions argument affects the encoded bit sequence.\n\njulia> encoded_bits = encodeNRZI(Int32[0, 1, 1, 0, 0, 1], :high);\n\njulia> transpose(encoded_bits)\n1×6 transpose(::Vector{Int32}) with eltype Int32:\n 0  1  0  0  0  1\n\n\n\n\n\n","category":"function"},{"location":"base/#Quadrature-Amplitude-Modulation","page":"Function list","title":"Quadrature Amplitude Modulation","text":"","category":"section"},{"location":"base/","page":"Function list","title":"Function list","text":"Modules = [DigitalComm]\nPages   = [\"genBitSequence.jl\",\"bitMapping.jl\",\"bitDeMapping.jl\",\"hardConstellation.jl\",\"symbolDemapper.jl\"]\nOrder   = [:function, :type]","category":"page"},{"location":"base/#DigitalComm.genBitSequence","page":"Function list","title":"DigitalComm.genBitSequence","text":"\n\nCreate a binary sequence and return a buffer with nbBits bits The array is of type UInt8 with x00 or x01) If stated, randSeed controls the seed of the random generator\n\n–- Syntax\n\n  genBitsequence(nbBits,randSeed=-1);\n\n–- Input parameters\n\nnbBits\t: Number of bits to generate [Int]\nrandSeed\t: Seed of random process (default -> -1) [Int]\n\n–- Output parameters\n\nbuffer\t: Populated buffer [Array{UInt8}]\n\n\n\n\n\n","category":"function"},{"location":"base/#DigitalComm.genBitSequence!","page":"Function list","title":"DigitalComm.genBitSequence!","text":"\n\nCreate a binary sequence and populate input buffer with bits The array is of type UInt8 with x00 or x01) If stated, randSeed controls the seed of the random generator\n\n–- Syntax\n\n  genBitsequence!(buffer,nbBits,randSeed=-1);\n\n–- Input parameters\n\nbuffer\t: Buffer to populate [Array{UInt8,nbBits}]\nnbBits\t: Number of bits to generate [Int]\nrandSeed\t: Seed of random process (default -> -1, no seed is used)\n\n–- Output parameters\n\nbuffer\t: Populated buffer [Array{UInt8}]\n\n\n\n\n\n","category":"function"},{"location":"base/#DigitalComm.genByteSequence","page":"Function list","title":"DigitalComm.genByteSequence","text":"\n\nCreate a byte sequence and return a populated  buffer with nbytes bytes The array \n\n–- Syntax\n\n  genByteSequence(nbBytes,randSeed=-1);\n\n–- Input parameters\n\nnbBytes\t: Number of byte to generate [Int]\nrandSeed\t: Seed of random process (default -> -1)\n\n–- Output parameters\n\nbuffer\t: Populated buffer [Array{UInt8}]\n\n–-\n\nv 1.0 - Robin Gerzaguet.\n\n\n\n\n\n","category":"function"},{"location":"base/#DigitalComm.genByteSequence!","page":"Function list","title":"DigitalComm.genByteSequence!","text":"\n\nCreate a byte sequence and populate input buffer with nbytes bytes The array is of type UInt8 with x00 to xff If stated, randSeed controls the seed of the random generator\n\n–- Syntax\n\n  genByteSequence!(buffer,nbBytes,randSeed=-1);\n\n–- Input parameters\n\nbuffer\t: Buffer to populate [Array{UInt8,nbByte}]\nrandSeed\t: Seed of random process (default -> -1)\n\n–- Output parameters\n\nbuffer\t: Populated buffer [Array{UInt8}]\n\n–-\n\nv 1.0 - Robin Gerzaguet.\n\n\n\n\n\n","category":"function"},{"location":"base/#DigitalComm.bitMappingQAM!-Tuple{Any, Any, Any}","page":"Function list","title":"DigitalComm.bitMappingQAM!","text":"\n\nQuadrature Amplitude Modulation (QAM) function    Apply symbol mapping to a input binary sequence (of size 1xL) with constellation size M. \tOutput is a vector (1xN) with N = L / log2(M) \tConventional gray mapping is used. Output constellation is casted in float, with unitary average power  Supported constellation\n\nQPSK\n16-QAM\n64-QAM\n256-QAM\n\n–- Syntax\n\nbitMappingQAM!(qamMat,M,bitSeq)\n\n–- Input parameters\n\nqamMat\t: Complex Vector to populate of size length(bitSeq) / log2(M) [Array{Complex{Float64}}]\nM\t\t\t: Modulation size (i.e from 4 to 256) such as bit per symbol is log2(M) [Int]\nbitSeq\t: Binary sequence to be transformed into QPSK symbols [Array{UInt8}]\n\n–- Output parameters\n\n[]\n\n\n\n\n\n","category":"method"},{"location":"base/#DigitalComm.bitMappingQAM-Tuple{Any, Any}","page":"Function list","title":"DigitalComm.bitMappingQAM","text":"\n\nQuadrature Amplitude Modulation (QAM) function    Apply symbol mapping to a input binary sequence (of size 1xL) with constellation size M. \tOutput is a vector (1xN) with N = L / log2(M) \tConventional gray mapping is used. Output constellation is casted in float, with unitary average power  Supported constellation\n\nQPSK\n16-QAM\n64-QAM\n256-QAM\n\n–- Syntax\n\nqamMat =  bitMappingQAM(M,bitSeq)\n\n–- Input parameters\n\nM\t\t\t: Modulation size (i.e from 4 to 256) such as bit per symbol is log2(M) [Int]\nbitSeq\t: Binary sequence to be transformed into QPSK symbols [Array{UInt8}]\n\n–- Output parameters\n\nqamMat\t: Complex Vector to populate of size length(bitSeq) / log2(M) [Array{Complex{Float64}}]\n\n\n\n\n\n","category":"method"},{"location":"base/#DigitalComm.bitDemappingQAM!-Tuple{Any, Any, Any}","page":"Function list","title":"DigitalComm.bitDemappingQAM!","text":"\n\nQuadrature Amplitude Modulation (QAM) hard decoding function Apply symbol hard demapping to a input symbol sequence (of size 1xN) with constellation size M. Output is a binary (1xL) with N = L / log2(M) Conventional gray demapping is used. Input constellation is Array{Complex{Float64}} Output bitsream is Array{Int8}\n\n–- Syntax\n\n  bitDemappingQAM!(hardBits,M,qamVect)\n\n–- Input parameters\n\nhardBits\t: Vector of bits to populate [Array{UInt8}, length(qamVect)/log2(M)]\nM\t\t\t: Constellation size (i.e from 4 to 256)\nqamVect\t: Complex observation vector to decode.\n\n–- Output parameters\n\n[]\n\n\n\n\n\n","category":"method"},{"location":"base/#DigitalComm.bitDemappingQAM-Tuple{Any, Any}","page":"Function list","title":"DigitalComm.bitDemappingQAM","text":"\n\nQuadrature Amplitude Modulation (QAM) hard decoding function Apply symbol hard demapping to a input symbol sequence (of size 1xN) with constellation size M. Output is a binary (1xL) with N = L / log2(M) Conventional gray demapping is used. Input constellation is Array{Complex{Float64}} Output bitsream is Array{Int8}\n\n–- Syntax\n\nhardBits = \t bitDemappingQAM!(hardBits,M,qamVect)\n\n–- Input parameters\n\nM\t\t\t: Constellation size (i.e from 4 to 256)\nqamVect\t: Complex observation vector to decode.\n\n–- Output parameters\n\nhardBits\t: Vector of bits to populate [Array{UInt8}, length(qamVect)/log2(M)]\n\n\n\n\n\n","category":"method"},{"location":"base/#DigitalComm.hardConstellation!-Tuple{Any, Any, Any}","page":"Function list","title":"DigitalComm.hardConstellation!","text":"\n\nQuadrature Amplitude Modulation (QAM) hard decoding function Return the hard decoded constellation with voronoi baseds decision. The difference with bitDeMapping is that bitDeMapping returns the decoded bit sequence whereas hardConstellation returns the closest constellation point. This can be use to compute raw EVM estimation (assuming a sufficiently high SNR to avoid errors).\n\n–- Syntax\n\nhardConstellation!(qamDec,M,qamMat)\n\n–- Input parameters\n\nqamDec\t: Vector to populate [Array{Complex{Float64},N}] with N = length(qamMat)\nM\t\t\t: Constellation size (i.e 4 to 256) \nqamMat\t: Vector to decode\n\n–- Output parameters\n\n[]\n\n\n\n\n\n","category":"method"},{"location":"base/#DigitalComm.hardConstellation-Tuple{Any, Any}","page":"Function list","title":"DigitalComm.hardConstellation","text":"\n\nQuadrature Amplitude Modulation (QAM) hard decoding function Return the hard decoded constellation with voronoi baseds decision. The difference with bitDeMapping is that bitDeMapping returns the decoded bit sequence whereas hardConstellation returns the closest constellation point. This can be use to compute raw EVM estimation (assuming a sufficiently high SNR to avoid errors).\n\n–- Syntax\n\nqamDec = hardConstellation!(qamDec,M,qamMat)\n\n–- Input parameters\n\nM\t\t\t: Constellation size (i.e 4 to 256) \nqamMat\t: Vector to decode\n\n–- Output parameters\n\nqamDec\t: Vector to populate [Array{Complex{Float64},N}] with N = length(qamMat)\n\n\n\n\n\n","category":"method"},{"location":"base/#DigitalComm.calcLLR-Tuple{Any, Any, Any}","page":"Function list","title":"DigitalComm.calcLLR","text":"\n\nReturns the final LLR value based on input distances \n\n–- Syntax\n\nllr = calcLLR(e0,e1,c)\n\n–- Input parameters\n\ne0  : Minimal distance 1 \ne1  : Minimal distance 2 \nc\t  : Channel estimate \n\n–- Output parameters\n\nllr : Max likelihood estimate \n\n–-\n\nv 1.0 - Robin Gerzaguet.\n\n\n\n\n\n","category":"method"},{"location":"base/#DigitalComm.llrToHardBits!-Tuple{Any, Array{Float64, N} where N}","page":"Function list","title":"DigitalComm.llrToHardBits!","text":"\n\nReturns hard binary value from soft LLR estimate (no FEC decoder, only hard decision here!)\n\n–- Syntax\n\nllrToHardBits(hardD,llr)\n\n–- Input parameters\n\nhardD\t  : Hard binary decision [Array{UInt},N] \nllr\t  : Input LLR (Float64 or UInt8 array) [Union{[Array{UInt}],[Array{Float64}]}]\n\n–- Output parameters\n\n[]\n\n–-\n\nv 1.0 - Robin Gerzaguet.\n\n\n\n\n\n","category":"method"},{"location":"base/#DigitalComm.llrToHardBits!-Tuple{Any, Array{UInt8, N} where N}","page":"Function list","title":"DigitalComm.llrToHardBits!","text":"\n\nReturns hard binary value from soft LLR estimate (no FEC decoder, only hard decision here!)\n\n–- Syntax\n\nllrToHardBits(hardD,llr)\n\n–- Input parameters\n\nhardD\t  : Hard binary decision [Array{UInt},N] \nllr\t  : Input LLR (Float64 or UInt8 array) [Union{[Array{UInt}],[Array{Float64}]}]\n\n–- Output parameters\n\n[]\n\n–-\n\nv 1.0 - Robin Gerzaguet.\n\n\n\n\n\n","category":"method"},{"location":"base/#DigitalComm.llrToHardBits-Tuple{Array{Float64, N} where N}","page":"Function list","title":"DigitalComm.llrToHardBits","text":"\n\nReturns hard binary value from soft LLR estimate (no FEC decoder, only hard decision here!)\n\n–- Syntax\n\nhardD = llrToHardBits(llr)\n\n–- Input parameters\n\nllr\t  : Input LLR (Float64 or UInt8 array) [Union{[Array{UInt}],[Array{Float64}]}]\n\n–- Output parameters\n\nhardD\t  : Hard binary decision [Array{UInt},N] \n\n–-\n\nv 1.0 - Robin Gerzaguet.\n\n\n\n\n\n","category":"method"},{"location":"base/#DigitalComm.llrToHardBits-Tuple{Array{UInt8, N} where N}","page":"Function list","title":"DigitalComm.llrToHardBits","text":"\n\nReturns hard binary value from soft LLR estimate (no FEC decoder, only hard decision here!)\n\n–- Syntax\n\nhardD = llrToHardBits(llr)\n\n–- Input parameters\n\nllr\t  : Input LLR (Float64 or UInt8 array) [Union{[Array{UInt}],[Array{Float64}]}]\n\n–- Output parameters\n\nhardD\t  : Hard binary decision [Array{UInt},N] \n\n–-\n\nv 1.0 - Robin Gerzaguet.\n\n\n\n\n\n","category":"method"},{"location":"base/#DigitalComm.llrToUInt!-Tuple{Any, Any}","page":"Function list","title":"DigitalComm.llrToUInt!","text":"\n\nConvert a LLR floating array to a UInt LLR  Some method (espcially C functions as in libfec) expect LLR to be UInt value from  0 (Likely a 0) to 255 (Likely a 1).  symbolDemappingQAM create a Float64 array from -infty (likely a 0) to nfty (Likely a 1). This function take a Float64 LLR estimate and output a UInt8 vector\n\n–- Syntax\n\nllrToUInt!(llrUInt,llr)\n\n–- Input parameters\n\nllrUInt : Output LLR in UInt [Array{UInt},N]\nllr\t  : Input LLR [Array{Float64},N]\n\n–- Output parameters\n\n[]\n\n–-\n\nv 1.0 - Robin Gerzaguet.\n\n\n\n\n\n","category":"method"},{"location":"base/#DigitalComm.llrToUInt-Tuple{Any}","page":"Function list","title":"DigitalComm.llrToUInt","text":"\n\nConvert a LLR floating array to a UInt LLR  Some method (espcially C functions as in libfec) expect LLR to be UInt value from  0 (Likely a 0) to 255 (Likely a 1).  symbolDemappingQAM create a Float64 array from -infty to infty. This function take a Float64 LLR estimate and output a UInt8 vector\n\n–- Syntax\n\nllrUInt = llrToUInt(llr)\n\n–- Input parameters\n\nllr\t  : Input LLR [Array{Float64},N]\n\n–- Output parameters\n\nllrUInt : Output LLR in UInt [Array{UInt},N]\n\n–-\n\nv 1.0 - Robin Gerzaguet.\n\n\n\n\n\n","category":"method"},{"location":"base/#DigitalComm.symbolDemappingQAM!-NTuple{4, Any}","page":"Function list","title":"DigitalComm.symbolDemappingQAM!","text":"\n\n–- Description\n\nReturns the log likelihood ratio of the incoming sequence qamSeq based on the channel estimates channelIn qamSeq is an input noisy QAM sequence with same size of channel estimate vector Output is populated by  soft output binary sequence to be fed in a FEC \n\n–- Syntax\n\noutput\t  = :symbolDemappingQAM(mcs,qamSeq,channel)\n\n–- Input parameters\n\noutput  : Soft bits [Array{UInt8},N*log2(mcs)]\nmcs\t  : Constellation size (from 4 to 256) [Int]\nqamSeq  : Complex noisy received sequence (after equalization) [Array{Float64},N]\nchannel : Complex channel estimate [Array{Float64},N]\n\n–- Output parameters\n\n[]\n\n–-\n\nv 1.0 - Robin Gerzaguet.\n\n\n\n\n\n","category":"method"},{"location":"base/#DigitalComm.symbolDemappingQAM-Tuple{Any, Any, Any}","page":"Function list","title":"DigitalComm.symbolDemappingQAM","text":"\n\n–- Description\n\nReturns the log likelihood ratio of the incoming sequence qamSeq based on the channel estimates channelIn. Max log approximation is considered qamSeq is an input noisy QAM sequence with same size of channel estimate vector Output is a vector of soft output binary sequence to be fed in a FEC \n\n–- Syntax\n\noutput\t  = symbolDemappingQAM(mcs,qamSeq,channel)\n\n–- Input parameters\n\nmcs\t  : Constellation size (from 4 to 256) [Int]\nqamSeq  : Complex noisy received sequence (after equalization) [Array{Float64},N]\nchannel : Complex channel estimate [Array{Float64},N]\n\n–- Output parameters\n\noutput  : Soft bits [Array{UInt8},N*log2(mcs)]\n\n\n\n\n\n","category":"method"},{"location":"base/#Channels","page":"Function list","title":"Channels","text":"","category":"section"},{"location":"base/","page":"Function list","title":"Function list","text":"Modules = [DigitalComm]\nPages   = [\"Channel/addNoise.jl\",\"Channel/rayleighChan.jl\",\"Channel/getChannel.jl\", \"Channel/addCFO.jl\"]\nOrder   = [:function, :type]","category":"page"},{"location":"base/#DigitalComm.addNoise-Union{Tuple{T}, Tuple{Array{T, N} where N, Any}, Tuple{Array{T, N} where N, Any, Any}} where T","page":"Function list","title":"DigitalComm.addNoise","text":"Add a white additive circular gaussian noise to input signal Added noise is real if input signal is real and computedlex is input signal is complex Noise level is controled by the second input parameter which is the signal to noise ratio (SNR) Signal power powSig is computed based in the input sequence power (average power in time domain) although a third parameter (theoretical power of input signal is given). In that case, snr is computed based on the value powSig \noutput parameters are the signal with noise, and the noise samples \nSee the bang methods for non-buffer alloc. \n[y,n]   = addNoise(x,snr,powSig); addNoise!(y,x,powSig)       # Fill y from x  addNoise!(x,powSig)         # Replace x\n\n–- Input parameters\n\nx= Input signal [Array{Real{Float64}}, Array{Complex{Float64}}] of size N\nsnr= Desired signal to noise ratio [Float64]\npowSig= Power of input signal. If not given, power is evaluated based on input signal x\n\n–- Output parameters\n\ny= Signal with noise [Array{Real{Float64}}, Array{Complex{Float6464}}] of size N\nn= noise samples [Array{Real{Float64}}, Array{Complex{Float64}}] of size N\n\n–-\n\nv 1.0 - Robin Gerzaguet.\n\n\n\n\n\n","category":"method"},{"location":"base/#DigitalComm.rayleighChan","page":"Function list","title":"DigitalComm.rayleighChan","text":"\n\nGenerates a correlated random rayleigh sequence of size N, parametrized by the doppler frequency fd and the sampling frqeuency fs. The method uses IFFT approach described in [1]\n\n–- Syntax\n\nα\t\t= rayleighChan(nbPath,N,fs,fd,seed=-1)\n\n–- Input parameters\n\nnbPath : Number of path to be generated (>0) [Int]\nN\t: Size of desired output (size of FFT) [Union{Int,Float64}]\nfs\t: Sampling frequency [Union{Int,Float64}]\nfd\t: doppler frequency [Union{Int,Float64}]\nseed: Seed for random generation ([Int], default =-1)\n\n–- Output parameters\n\nα\t: Complex rayleigh coefficient [Array{Complex{Float64},N}]\n\n–- References\n\n[1] D. J. Young and N. C. Beaulieu, \"The generation of correlated Rayleigh random variates by inverse discrete Fourier transform,\" in IEEE Transactions on Communications\n\n–-\n\n\n\n\n\n","category":"function"},{"location":"base/#DigitalComm.applyChannel-Tuple{Any, Any}","page":"Function list","title":"DigitalComm.applyChannel","text":"\n\nApply a channel implementation  to an input signal\n\n–- Syntax\n\nsigChan\t  : applyChannel(sigId,channelImpl)\n\n–- Input parameters\n\nsigId\t  : Input signal [Array{Any}]\nchannelImpl : Channel implementation [ChannelImpl]\n\n–- Output parameters\n\nsigChan\t: Output signal [Array{Any}]\n\n–-\n\nv 1.0 - Robin Gerzaguet.\n\n\n\n\n\n","category":"method"},{"location":"base/#DigitalComm.getChannel","page":"Function list","title":"DigitalComm.getChannel","text":"\n\nCreate a channelImpl based on desired channel model and number of realisations \n\n–- Syntax\n\nchannelImpl\t  = getChannel(nbSamples,channelModel,randSeed=-1)\n\n–- Input parameters\n\nnbSamples\t\t: Number of samples on which channel will be applied [Int]\nchannelModel\t: Channel object [ChannelModel]\nrandSeed\t\t: Desired seed (default -1)\n\n–- Output parameters\n\nchannelImpl\t: Channel implementation \n\n–-\n\n\n\n\n\n","category":"function"},{"location":"base/#DigitalComm.getFIRResponse","page":"Function list","title":"DigitalComm.getFIRResponse","text":"\n\nReturns a complete FIR response based on the power profile (in linear scale), the delay profile (in s) and the sampling frequency.\n\n–- Syntax\n\ncir = getFIRResponse(delayProfile:,powerProfile,freq,sincSupport=5,interpSystem=0)\n\n–- Input parameters\n\ndelayProfile\t: Vector of delay in second [Union{Array{Int},Array{Float64}}]\npowerProfile\t: Vector of attenuation with same size of delayProfile in linear scale with rayleigh distribution\nfreq\t\t\t: Sampling frequency\nsincSupport\t: Size of interpolator (default 5)\ninterpSystem\t: Forcing extra delay for all samples to have proper interpolation of the FIR beginning (default 0)\n\n–- Ouput parameters\n\ncir\t\t\t: Finite impulse response [Array{Complex{Float64}},max(delayProfile)+sincSupport]\n\n–-\n\n\n\n\n\n","category":"function"},{"location":"base/#DigitalComm.initChannel-Tuple{String, Union{Float64, Int64}, Union{Float64, Int64}, Union{Float64, Int64}}","page":"Function list","title":"DigitalComm.initChannel","text":"\n\nCreate a channel object associated to physical parameters and propagation profile.\n\n–- Syntax\n\nchannObj  = initChannel(profile,carrierFreq,samplingFreq,dopplerFreq;powerProfile=[],delayProfile=[],randSeed=-1)\n\n–- Input parameters\n\nprofile : Multipath profile (see below) [String]\ncarrierFreq : Carrier frequency in Hz [Union{Int,Float64}]\nsamplingFreq: baseband sampling frequency [Union{Int,Float64}]\nspeed : Velocity (km/h) [Float64]\npowerProfile\t: User defined power profile (default []). In case when it is defined, delayProfile should also be defined and profile is not used. [Array{Float}]\ndelayProfile\t: User defined delay profile in second [Array{Float64}]\nrandSeed : Seed if necessary (default: -1) [Float64]\n\n–- Output parameters\n\nchannel : Julia Channel Object [Channel]\n\n–- Channel models\n\n-\tETU\t  : Extended Typical Urban -\tEVA\t  : Extended Vehicular area -\tTDLC  : -\tRayleigh : Single tap rayleigh channel model\n\n–-\n\n\n\n\n\n","category":"method"},{"location":"base/#DigitalComm.ChannelImpl","page":"Function list","title":"DigitalComm.ChannelImpl","text":"\n\nObject with channel realisations\n\n–- Syntax\n\ntimeVarying\t: Flag for constant vs time varying channel [Int] \ncir\t\t\t: CIR matrix (nbTap x nbChannel) [Union{Array{Int},Array{Float64},Array{Complex{Float64}}}]\nchannelModel  : Model use for generation [DigitalComm.ChannelModel]\npowerLin\t\t: Power distribution with the rayleigh distribution [Array{Complex{Float64}}] \nrandSeed\t\t: Seed use for rayleigh generation \n\n–-\n\nv 1.0 - Robin Gerzaguet.\n\n\n\n\n\n","category":"type"},{"location":"base/#DigitalComm.ChannelModel","page":"Function list","title":"DigitalComm.ChannelModel","text":"\n\nChannel model object\n\n–- Syntax\n\nprofile\t\t  : Name of profile [String]\ncarrierFreq\t  : Carrier frequency [Union{Int,Float64}]\nsamplingFreq\t  : Sampling frequency [Union{Int,Float64}]\nspeed\t\t\t  : Desired speed (km/h) [Union{Int,Float64}]\npowerProfile\t  : Distribution of power values in dB [Array{Float64}]\ndelayProfile\t  : Distribution of delay values in s [Array{Float64}], same size as powerProfile\ndopplerFreq\t  : Doppler frequency (inherited from samplingFreq  and speed) \ndelaySpread\t  : Max support of CIR in samples [Int]\n\n–-\n\n\n\n\n\n","category":"type"},{"location":"base/#DigitalComm.addCFO-Union{Tuple{T}, Tuple{Union{AbstractArray{Complex{T}, 1}, AbstractVector{T}}, Any, Any}, Tuple{Union{AbstractArray{Complex{T}, 1}, AbstractVector{T}}, Any, Any, Any}} where T<:Real","page":"Function list","title":"DigitalComm.addCFO","text":"Adding Carrier Frequency Offset δ in Hz to the input signal x sampled at frequency samplingRate (In Hz) with initial phase ϕ (default 0) This function does not mutate the input signal. See addCFO! for mutating function. In case you want to add normalized CFO, set the samplingRate to 1.\n\n–- Syntax\n\ny = addCFO(x,delta,samplingRate)\n\n–- Input parameters\n\nx : Input signal \nδ : Carrier frequency offset [Hz]\nsamplingRate : Sampling rate [Hz]\n\n–- Output parameters\n\ny : Signal with CFO\n\n\n\n\n\n","category":"method"},{"location":"base/#Windows-and-filters","page":"Function list","title":"Windows and filters","text":"","category":"section"},{"location":"base/","page":"Function list","title":"Function list","text":"Modules = [DigitalComm]\nPages   = [\"raisedCosine.jl\", \"UFOFDM/filterUFOFDM.jl\", \"WOLA/getWolaWindow.jl\"]\nOrder   = [:function, :type]","category":"page"},{"location":"base/#DigitalComm.raisedCosine-Tuple{Any, Any, Any}","page":"Function list","title":"DigitalComm.raisedCosine","text":"Returns the Finite Impulse Response of a Raised Cosine (RC) filter.\tThe filter is defined by its span (evaluated in number of symbol N), its Roll-Off factor and its oversampling factor. The span corresponds to the number of symbol affected by filter before and after the center point.\n\nOutput is a Vector{Float64} array of size L= 2KN+1 \n\nSRRC definition is based on [1]\t \n\n[1]\t 3GPP TS 25.104 V6.8.0 (2004-12). http://www.3gpp.org/ftp/Specs/archive/25_series/25.104/25104-680.zip \n\nSyntax \n\n\th\t= raisedCosine(N,beta,ovS)\n\nInput parameters \n\nN\t  \t: Symbol span (Int16)\nbeta  : Roll-off factor (Float64)\novS\t: Oversampling rate (Int16)\n\nExamples\n\njulia> h = raisedCosine(12,0.5,16);\n\njulia> length(h)\n385\n\n\n\n\n\n","category":"method"},{"location":"base/#DigitalComm.sqrtRaisedCosine-Tuple{Any, Any, Any}","page":"Function list","title":"DigitalComm.sqrtRaisedCosine","text":"Returns the Finite Impulse Response of a Square Root Raised Cosine (SRRC) filter. \n\nThe filter is defined by its span (evaluated in number of symbol N), its Roll-Off factor and its oversampling factor. The span corresponds to the number of symbol affected by filter before and after the center point.\n\nOutput is a Vector{Float64} array of size L= 2KN+1\n\nSRRC definition is based on [1]\n\n[1]\t 3GPP TS 25.104 V6.8.0 (2004-12). http://www.3gpp.org/ftp/ Specs/archive/25_series/25.104/25104-680.zip\n\nSyntax\n\nh\t= sqrtRaisedCosine(N,beta,ovS) \n\nInput parameters \n\nN\t  \t: Symbol span (Int16)\nbeta  : Roll-off factor (Float64)\novS\t: Oversampling rate (Int16)\n\nExamples\n\njulia> h = sqrtRaisedCosine(12,0.5,16);\n\njulia> length(h)\n385\n\n\n\n\n\n","category":"method"},{"location":"base/#DigitalComm.cheb-Tuple{Any, Any}","page":"Function list","title":"DigitalComm.cheb","text":"\n\nApply Chebyshev polynom of order L to input x\n\n–- Syntax\n\ny = cheb(L,x)\n\n–- Input parameters\n\nL\t  : Chebyshev order [Int] \nx\t  : Input [Any]\n\n–- Output parameters\n\ny\t  : Output \n\n–-\n\nv 1.0 - Robin Gerzaguet.\n\n\n\n\n\n","category":"method"},{"location":"base/#DigitalComm.dolphChebyshev-Tuple{Any, Any}","page":"Function list","title":"DigitalComm.dolphChebyshev","text":"\n\nReturns the Dolp Chebyshev filter of order L with desired attenation att\n\nSee Peter Lynch, \"The Dolph-Chebyshev Window: A Simple Optimal Filter\", Monthly Weather Review, Vol. 125, pp. 655-660, April 1997. (http://www.maths.tcd.ie/~plynch/Publications/Dolph.pdf) Dolph, \"A current distribution for broadside arrays which optimizes the relationship between beam width and side-lobe level\", Proc. IEEE, 34, pp. 335-348. \t\tcheb(m-1, beta * cos(pi * k/m)) W(k) =\t–––––––––––––––- \t\t\t  cheb(m-1, beta)\n\n–- Syntax\n\nfilterDC = dolphChebyshev(n,at)\n\n–- Input parameters\n\nn\t\t  : Size of desired filter \nat\t  : Attenation in dBB \n\n–- Output parameters\n\nfilterDC : Filter impulse response [Array{Float64}] \n\n–-\n\nv 1.0 - Robin Gerzaguet.\n\n\n\n\n\n","category":"method"},{"location":"base/#DigitalComm.getWolaWindow-NTuple{4, Any}","page":"Function list","title":"DigitalComm.getWolaWindow","text":"\n\nReturns the desired window used in transmitter or receiver weigthed overlap and add methods (WOLA). See [1] for window reference design.\n\n–- Syntax\n\nwindow = getWolaWindow(winFunc,nFFT,nCp,winlength)\n\n–- Input parameters\n\nwinFunc\t: Window type (see supported format below) [String]\nnFFT\t\t: FFT size [Int]\nnCP\t\t: CP size [Int]\nwinlength : length of window [Int]\n\n–- Output parameters\n\nwindow\t: Window [Window]\n\n–-\n\nSupported window\n\n\"Triangle\"\t\t: Triangle window\n\"srrc\"\t\t\t: Square Root Raised Cosine\n\"Meyer\"\t\t\t: Meyer window (See [1])\n\n–-\n\nReferences\n\n[1] R. Zayani, Y. Medjahdi, H. Shaiek and D. Roviras, \"WOLA-OFDM: A Potential Candidate for Asynchronous 5G,\" 2016.\n\n–-\n\nv 1.0 - Robin Gerzaguet.\n\n\n\n\n\n","category":"method"},{"location":"base/#DigitalComm.Window","page":"Function list","title":"DigitalComm.Window","text":"\n\nStructure describing window parameters \n\n–- Syntax\n\nwinFunc\t: Name of window  \nwinLength : Size of window \nwindow\t: Window coefficients \n\n–-\n\nv 1.0 - Robin Gerzaguet.\n\n\n\n\n\n","category":"type"},{"location":"base/#Waveforms","page":"Function list","title":"Waveforms","text":"","category":"section"},{"location":"base/#Common-functions-2","page":"Function list","title":"Common functions","text":"","category":"section"},{"location":"base/","page":"Function list","title":"Function list","text":"Modules = [DigitalComm]\nPages   = [\"genSig.jl\",\"genZCSequence.jl\",\"getLTEAlloc.jl\"]\nOrder   = [:function, :type]","category":"page"},{"location":"base/#DigitalComm.decodeSig-Tuple{Any, Dict{String, Waveform}, String}","page":"Function list","title":"DigitalComm.decodeSig","text":"\n\nCreate a signal based on a waveform dictionnary and a desired configuration (i.e the key)\n\n–- Syntax\n\nsigId\t= decodeSig(qamMat,dWav,key)\n\n–- Input parameters\n\nsignal\t  : Time domain signal \nqamMat  : Time frequency complex QAM matrix [Array{Complex{Float64}}]\ndWav\t  : Waveform dictionnary (see initWaveforms)\nkey\t  : Desired waveform configuration\n\n–- Output parameters\n\n–-\n\nv 1.0 - Robin Gerzaguet.\n\n\n\n\n\n","category":"method"},{"location":"base/#DigitalComm.decodeSig-Tuple{Any, DigitalComm.StrucOFDM}","page":"Function list","title":"DigitalComm.decodeSig","text":"Decode a time domain signal for a given multicarrier waveform and returns a T/F QAM constellation. Input are the compelx baseband signal  and the Waveform structure.\n\n–- Syntax\n\nqamDec\t= decodeSig(signal,struc);\n\n–- Input parameters\n\nsignal  : Time domain signal \nstruc\t  : Waveform structure \n\n–- Output parameters\n\nqamDec  : Time frequency complex QAM matrix [Array{Complex{Float64}}]\n\n–-\n\nv 1.0 - Robin Gerzaguet.\n\n\n\n\n\n","category":"method"},{"location":"base/#DigitalComm.genSig-Tuple{Any, DigitalComm.StrucOFDM}","page":"Function list","title":"DigitalComm.genSig","text":"\n\nGenerate a time domain signal for a given multicarrier waveform. Input are the Time-Frequency matrix qamMat and the Waveform structure.\n\n–- Syntax\n\nsigId\t= genSig(qamMat,struc::Waveform)\n\n–- Input parameters\n\nqamMat  : Time frequency complex QAM matrix [Array{Complex{Float64}}]\nstruc\t  : Waveform structure \n\n–- Output parameters\n\nsigId\t  : Time domain signal \n\n–-\n\nv 1.0 - Robin Gerzaguet.\n\n\n\n\n\n","category":"method"},{"location":"base/#DigitalComm.genSig-Tuple{Array{ComplexF64, N} where N, Dict{String, Waveform}, String}","page":"Function list","title":"DigitalComm.genSig","text":"\n\nCreate a signal based on a waveform dictionnary and a desired configuration (i.e the key)\n\n–- Syntax\n\nsigId\t= genSig(qamMat,dWav,key)\n\n–- Input parameters\n\nqamMat  : Time frequency complex QAM matrix [Array{Complex{Float64}}]\ndWav\t  : Waveform dictionnary (see initWaveforms)\nkey\t  : Desired waveform configuration\n\n–- Output parameters\n\nsigId\t  : Time domain signal \n\n–-\n\nv 1.0 - Robin Gerzaguet.\n\n\n\n\n\n","category":"method"},{"location":"base/#DigitalComm.getWaveformName-Tuple{Waveform}","page":"Function list","title":"DigitalComm.getWaveformName","text":"\n\nReturns the waveform name based on input type structure\n\n–- Syntax\n\nname = getWaveformName(struc)\n\n–- Input parameters\n\nstruc\t  : Waveform structure [Waveform]\n\n–- Output parameters\n\nname\t  : String associated to waveform name\n\n–-\n\nv 1.0 - Robin Gerzaguet.\n\n\n\n\n\n","category":"method"},{"location":"base/#DigitalComm.initWaveforms-Tuple","page":"Function list","title":"DigitalComm.initWaveforms","text":"\n\nCreate a dictionnary of waveform configurations. To compare and use the same script for different waveform configuration, we propose to add a dictionnary to have a container that contains all waveform configuraton. The function is called with every desired waveform structure. The dictionnary as a key associated to the waveform name, and a field associated to the waveform structure. If the waveform is present several times (several configuration with same waveform type, for instance FBMC with different overlapping factor values), a counter index is added to the waveform key.\n\n–- Syntax\n\ndWav  = initWaveforms(x1,x2,...)\n\n–- Input parameters\n\nx\t\t: Waveform structure [Waveform]\n\n–- Output parameters\n\ndWav\t: Dictionnary of waveforms.\n\n–-\n\nv 1.0 - Robin Gerzaguet.\n\n\n\n\n\n","category":"method"},{"location":"base/#DigitalComm.genZCSequence","page":"Function list","title":"DigitalComm.genZCSequence","text":"\n\nConstant Modulus Zero Autocorrelation (CAZAC) sequence generation. Sequence can be used as preamble sequences for OFDM systems. The function generate the ZC sequence in frequency domain. Generates a Zadoff-Chu  sequence on allocated subcarrier mapped on nFFT vector with generated kernel muPSS and power boost zcBoost\n\n–- Syntax\n\nzcSeq\t  = genZCSequence(nFFT,allocatedSubcarrier,muPSS=0,zcBoost=0)\n\n–- Input parameters\n\nnFFT\t\t\t\t  : FFT size for output [Int]\nallocatedSubcarrier : vector of allocated subcarrier [Array{Int,L}]. \nmuPSS\t\t\t\t  : Kernel for ZC sequence [Int] – default 0\nzcBoost\t\t\t  : Power boost (in dB) applied to sequence [Float32] – default 0.\n\n–- Output parameters\n\nzcSeq\t\t\t\t  : ZC sequence [Array{Complex{Float64}},nFFT]\n\n–-\n\nv 1.0 - Robin Gerzaguet.\n\n\n\n\n\n","category":"function"},{"location":"base/#DigitalComm.get5GNRAlloc-Tuple{Any}","page":"Function list","title":"DigitalComm.get5GNRAlloc","text":"Returns the vector of allocated subcarriers associated to 5G New Radio frequency mapping. In 5G-NR, depending on FFT size, only few subcarriers are allocated (55-65%). This function takes a FFT size as input  and returns an array of size nbSubcarriers. The output has more subcarriers thanj getLTEAlloc (for 4G-LTE)  \nallocatedSubcarrier = getLTEAlloc(nFFT) \nInput parameters \n\nnFFT\t  : Desired FFT size (128, 256, 512, 1024, 1536, 2048, 4096) [Int]\n\nOutput parameters  \n- allocatedSubcarrier : Vector of subcarriers index [Array{Int}]\n\n\n\n\n\n","category":"method"},{"location":"base/#DigitalComm.getLTEAlloc-Tuple{Any}","page":"Function list","title":"DigitalComm.getLTEAlloc","text":"Returns the vector of allocated subcarriers associated to Long Term evolution frequency mapping. In LTE, depending on FFT size, only few subcarriers are allocated (45-55%). This function takes a FFT size as input  and returns an array of size nbSubcarriers  \nallocatedSubcarrier = getLTEAlloc(nFFT) \nInput parameters \n\nnFFT\t  : Desired FFT size (128, 256, 512, 1024, 1536, 2048, 4096) [Int]\n\nOutput parameters  \n- allocatedSubcarrier : Vector of subcarriers index [Array{Int}]\n\n\n\n\n\n","category":"method"},{"location":"base/#BF-OFDM","page":"Function list","title":"BF-OFDM","text":"","category":"section"},{"location":"base/","page":"Function list","title":"Function list","text":"Modules = [DigitalComm]\nPages   = [\"Waveforms/BFOFDM/BFOFDM_filter.jl\",\"Waveforms/BFOFDM/bfofdmSigGen.jl\",\"Waveforms/BFOFDM/bfofdmSigDecode.jl\",\"Waveforms/BFOFDM/carrierManipulation.jl\"]\nOrder   = [:function, :type]","category":"page"},{"location":"base/#DigitalComm.getBFOFDMFilter-Tuple{Any, Any, Any}","page":"Function list","title":"DigitalComm.getBFOFDMFilter","text":"Returns prototype fitlering matrix for BF-OFDM  with specified by overlapping factor K, PPN size nFBMC, filter type. Additional parameters are the CP size of the precoding stage (set to optimal value by default) and filter structure for specific parameter overset.\n\n–- Syntax\n\n(p,pF) = getBFOFDMFilter(K,nFBMC,filter;GI,BT,filterStopBand,fS)>\n\n–- Input parameters\n\nK\t  : Overlapping factor [Int]\nnFBMC : PPN size (Number of FBMC carriers) [Int]\nfilter: Filter type: \"Gaussian\",\"phydyas\",\"FS\",\"DC\": [String]\nBT\t  : Bandwidth time product for custom gaussian filter (used with \"gaussian\") [Float64]\nfilterStopBand : Attenuation with custom DC window (used with \"DC\") [Float64]\nfS\t  : Frequency sampling custom  coefficients (Array{Float64,K}) (used with \"fs\")\n\n–- Output parameters\n\np\t\t: Filter impulse response [Array{Float64,K*nFBMC}].\npF\t\t: Filter coefficient in frequency domain (For Frequency sampling implementation)\n\n\n\nFilter types All filter type can be called with 2 ways. \"filter\" and \"filteropt\". When \"filteropt\" is used, the filter coefficient are obtained through numerical optimisation (SIR optimisation). Otherwise, it uses its associated parameter to extract appropriate coefficients. See [1] and [2] for filter optimisation principles. See [4] for special cases about 5G-NR compatibilty.  The supported filter/windows are:\n\nGaussian\t: Gaussian filter shape, specified by BT. Optimized Gaussian shape can be used [1]\nphydyas\t\t: Classic FBMC pulse shape defined in frequency domain [3]\nFS\t\t\t: Coefficient defined in frequency domain. Filter coefficient are based on intrinsic SIR optimisation [1]\nDC\t\t\t: Dolph Chebyshev window. Can be based on window optimisation (SIR optimisation) or defined by filterStopBand parameter.\n\n–-\n\nReferences\n\n[1]\tDemmer, D and Gerzaguet, R and Doré, J-B and Le Ruyet, D. and Kténas, D, \"Filter Design for 5G BF-OFDM Waveform\", 2017.\n[2] A. Sahin, I. Guvenc, and H. Arslan, “A Survey on Multicarrier Communications: Prototype Filters, Lattice Structures, and Implementation Aspects\", 2014\n[3] Phydyas project, \"Deliverable D5.1 : Prototype filter and structure optimization\", 2009\n[4]\tDemmer, D and Rostom, Z and Gerzaguet, R and Doré, J-B and Le Ruyet, D. \"Study of OFDM Precoded Filter-Bank Waveforms\", 2018\n\nExamples\n\nGet a classic FBMC filter with phydyas and an overlapping factor of 4, with a input PPN of size 64. The precodinng stage is a OFDM of size 64 and a GI of size 4.\n\n# --- phydyas filter\n( hphydyas,hFphydyas )\t = getBFOFDMFilter(4,64,\"phydyas\");\n\n# --- Gaussian shape\n( hGaussian,hFGaussian )\t = getBFOFDMFilter(4,64,\"Gaussian_opt\",GI=4);\n\n# --- Custom Gaussian window\n( hGaussianC,hFGaussianC ) = getBFOFDMFilter(4,64,\"Gaussian\",GI=4,BT=0.5)\n\n–-\n\nv 1.0 - Robin Gerzaguet.\n\n\n\n\n\n","category":"method"},{"location":"base/#DigitalComm.bfofdmSigGen-Tuple{Array{ComplexF64, N} where N, Int64, Int64, Int64, Int64, Float64, Array{Int64, N} where N, Any}","page":"Function list","title":"DigitalComm.bfofdmSigGen","text":"\n\nCreates a Block Filtered - OFDM (BF-OFDM) signal parametrized by its numerlogy and its waveform parameter. Generate a time domain signal based on the input matrix qamMat. The input matrix is a T/F matrix of size (nRe x nbSymb) with nRe the number of allocated subcarrier and nbSymb the number of symbols.\n\nThe waveform is parametrized by the PPN size (number of carriers) nFBMC, the size of the precoding stage nOFDM, the CP size of the precoding stage GI and the compression factor parameter δ. See [1], [2] for waveform description and [3,5] for importance and design of compression rate (set to 0.5 in former works on BF-OFDM).\n\nBF-OFDM is characterized by its pulse shape filter. Pulse shape can be automatically tuned to optimal (in terms of  innterference management) [4]. In such a case, filterType should be a string (can be \"gaussianopt\", \"dcopt\" and \"fs_opt\"). For a specific pulse shape filter, an array of the nFBMC*K filter taps should be given (and generated for example  with getBFOFDMFilter).\n\n–- Syntax\n\nsigId\t  =bfofdmSigGen(qamMat,nFBMC,nOFDM,K,GI,δ,allocatedSubcarriers,filterType;typeTx=\"PPN\")\n\n–- Input parameters\n\nqamMat\t\t: T/F symbols to transmit (QAM symbols) [Array{Complex{Float64},nRe,nbSymb] with nbSymb number of BF-OFDM symbols and nRe number of allocated subcarriers.\nnFBMC\t\t: PPN size\nnOFDM\t\t: OFDM precoding size\nGI\t\t\t: CP size of precoding stage\nK\t\t\t: Overlapping factor\nδ\t\t\t: Compression rate\nallocatedSubcarriers : Vector or allocated subcarriers Array{Int,nRe} with maximum(nRe) < nOFDMnFBMCδ\nfilterType\t: Pulse shape type. Can be a string (see getBFOFDMFilter) or a vector of size K x nFBMC with filter taps.\ntypeTx\t\t: Filterbank architecture. Can be \"PPN\" (polyphase network) or \"FS\" (frequency spreading) if filterType is of type \"fs\" or \"fs_opt\".\n\n–- Output parameters\n\nsigId\t\t: Time domainn BF-OFDM signal. [Array{Complex{Float64},nChip}.\n\n–-\n\nReferences\n\n[1] Gerzaguet, R and Demmer, D and Doré, J-B and Le Ruyet, D. and Kténas, D, \"Block-Filtered OFDM: A new Promising Waveform for Multi-service Scenarios\", 2017\n[2] Demmer, D and Gerzaguet, R and Doré, J-B and Le Ruyet, D. and Kténas, D, \"Block-filtered OFDM: A novel waveform for future wireless technologies\", 2017.\n[3] Demmer, D and Rostom, Z and Gerzaguet, R and Doré, J-B and Le Ruyet, D. \"Study of OFDM Precoded Filter-Bank Waveforms\", 2018\n[4] Demmer, D and Gerzaguet, R and Doré, J-B and Le Ruyet, D. and Kténas, D, \"Filter Design for 5G BF-OFDM Waveform\", 2017.\n[5] Demmer, D.; Zakaria, R.; Gerzaguet, R.; Doré, J. & Le Ruyet, D. Study of OFDM Precoded Filter-Bank Waveforms, IEEE Transactions on Wireless Communications, 2019.\n\nv 1.0 - Robin Gerzaguet.\n\n\n\n\n\n","category":"method"},{"location":"base/#DigitalComm.initBFOFDM-NTuple{7, Any}","page":"Function list","title":"DigitalComm.initBFOFDM","text":"\n\nBF-OFDM initialisation\n\n–- Syntax\n\nbfofdm = initBFOFDM(nFBMC::Int,nOFDM::Int,K::Int,GI::Int,δ::Float64,allocatedSubcarriers::Array{Int},filterType::String;BT=-1,filterStopBand=-1,fS=[],nFFT=-1,nCP=-1)\n\n–- Input parameters\n\nnFBMC\t\t: Number of carriers (PPN size)\nnOFDM\t\t: Number of subbcarriers per carrier (OFDM precoder size)\nK\t\t\t: Overlapping factor of the PPN \nGI\t\t: CP size of the precoder \nδ\t\t\t: Rate factor (compression factor)  \nallocatedSubcarriers\t: Vector of allocated subcarriers   \nfilterName  : Type of filter used (name)  \nfilterTaps  : FIR coefficient values \nBT\t\t: Gaussian parameters (if gaussian filter is used)\nfilterStopBand : DolphChebyshev attenuation factor (if DC is used)\nfS\t\t: Frqeuency spreading coefficients (if FS filter is used)\nnFFT\t\t: Equivalent OFDM FFT size \nnCP\t\t: Equivalent OFDM CP size \n\n–- Output parameters\n\nbfofdm\t\t: BF-OFDM structure \n\n–-\n\nv 1.0 - Robin Gerzaguet.\n\n\n\n\n\n","category":"method"},{"location":"base/#DigitalComm.StrucBFOFDM","page":"Function list","title":"DigitalComm.StrucBFOFDM","text":"\n\nBF-OFDM structure \n\n–- Syntax\n\nnFBMC\t\t: Number of carriers (PPN size)\nnOFDM\t\t: Number of subbcarriers per carrier (OFDM precoder size)\nK\t\t\t: Overlapping factor of the PPN \nGI\t\t: CP size of the precoder \nδ\t\t\t: Rate factor (compression factor)  \nallocatedSubcarriers\t: Vector of allocated subcarriers   \nfilterName  : Type of filter used (name)  \nfilterTaps  : FIR coefficient values \nBT\t\t: Gaussian parameters (if gaussian filter is used)\nfilterStopBand : DolphChebyshev attenuation factor (if DC is used)\nfS\t\t: Frqeuency spreading coefficients (if FS filter is used)\nnFFT\t\t: Equivalent OFDM FFT size \nnCP\t\t: Equivalent OFDM CP size \n\n–-\n\nv 1.0 - Robin Gerzaguet.\n\n\n\n\n\n","category":"type"},{"location":"base/#DigitalComm.bfofdmSigDecode-NTuple{7, Any}","page":"Function list","title":"DigitalComm.bfofdmSigDecode","text":"\n\nDemodulate a BF-OFDM signal and returns the obtained T/F matrix composed of QAM symbols (without equalisation). Based on bfofdmSigGen.jl\n\n–- Syntax\n\nqamRx\t= bfofdmSigDecode(sigRx,nFBMC,nOFDM,K,GI,δ,allocatedSubcarriers;posWindow=\"end\")\n\n–- Input parameters\n\nsigRx\t\t: Complex baseband signal to decode [Array{Complex{Float64}}]\nnFBMC\t\t: PPN size [Int]\nnOFDM\t\t: FFT precoder size [Int]\nK\t\t\t: Overlapping factor [Int]\nGI\t\t: CP size of precoder [Int]\nδ\t\t\t: Compression rate  [Float64]\nallocatedSubcarriers : Vector of allocated subcarriers [Array{Int}]\nposWindow\t  : Receiver window position. By default window is at same place as OFDM (i.e drop CP). For BF-OFDM, middle window position can also be considered with small delay spread channel (reduce ISI incuded by PPN). In that case, a phase rotation must be applied (see [1])\n\n–- Output parameters\n\nqamRx\t\t: Decoded constellation [Array{Complex{Float64}}]\n\nReferences\n\n[1]\t: Demmer, D.; Zakaria, R.; Gerzaguet, R.; Doré, J. & Le Ruyet, D. Study of OFDM Precoded Filter-Bank Waveforms, IEEE Transactions on Wireless Communications, 2019.\n\n–-\n\nv 1.0 - Robin Gerzaguet.\n\n\n\n\n\n","category":"method"},{"location":"base/#DigitalComm.getBFOFDM_carrierFromSubcarriers-NTuple{4, Any}","page":"Function list","title":"DigitalComm.getBFOFDM_carrierFromSubcarriers","text":"\n\nGet the index of the allocated carriers based on the index of the subcarriers. We consider here that a FBMC carriers bear data (i.e is allocated) is at least one of its subcarrier is enable.\n\n–- Syntax\n\nfbmcCarriers\t= getBFOFDM_carrierFromSubcarriers(nFBMC,nOFDM,δ,subcarrier)\n\n–- Input parameters\n\nnFBMC\t  : FBMC carrier size (number of carriers) [Int]\nnOFDM\t  : OFDM subcarrier size [Int]\nδ\t\t  : Rate factor [Float64]\nfbmcCarriers : Vector of allocated carrier [Array{Int,L}], L < nFBMCnOFDMδ \n\n–- Output parameters\n\nfbmcCarriers : Vector of allocated carriers [Array{Int, P ] P < nFBMC\n\n–-\n\nv 1.0 - Robin Gerzaguet.\n\n\n\n\n\n","category":"method"},{"location":"base/#DigitalComm.getBFOFDM_oversampledGridSubcarriers-NTuple{4, Any}","page":"Function list","title":"DigitalComm.getBFOFDM_oversampledGridSubcarriers","text":"\n\nReturns the oversampled grid at the subcarrier level for BF-OFDM. In BF-OFDM as we use a nOFDMnFBMC grid with nOFDMδ allocated subcarrier per carriers (for a precodinng stage of size nOFDM), it can be usefull to get all the index of the allocated subcarrier per carrier. The output is a vector of the allocated subcarrier index in the oversampled frequency grid.\n\n–- Syntax\n\nsubcarrierTx\t= getCarrierFromSubcarriers(nOFDM,δ,fbmcCarriers)\n\n–- Input parameters\n\nnOFDM\t  : OFDM subcarrier size [Int]\nδ\t\t  : Rate factor [Float64]\nfbmcCarriers : Vector of allocated carrier [Array{Int,L}], L < nFBMCnOFDMδ\n\n–- Output parameters\n\nsubcarrierTx : Vector of allocated carriers [Array{Int, LnOFDMδ  ]\n\n–-\n\nv 1.0 - Robin Gerzaguet.\n\n\n\n\n\n","category":"method"},{"location":"base/#DigitalComm.getBFOFDM_subCarrierFromFBMCCarriers-NTuple{4, Any}","page":"Function list","title":"DigitalComm.getBFOFDM_subCarrierFromFBMCCarriers","text":"\n\nGet the index of the oversampled carrier (i.e subcarriers index in the precoding field) based on the index of the allocated carriers. It is assumed that for each carriers, all subcarriers are enable (with orthogonality, i.e Nδ allocated subcarriers).\n\n–- Syntax\n\nsubcarriers\t= getBFOFDM_subCarrierFromFBMCCarriers(nFBMC,nOFDM,δ,fbmcCarriers)\n\n–- Input parameters\n\nnFBMC\t  : FBMC carrier size (number of carriers) [Int]\nnOFDM\t  : OFDM subcarrier size [Int]\nδ\t\t  : Rate factor [Float64]\nfbmcCarriers : Vector of allocated carrier [Array{Int,L}], L < nFBMC\n\n–- Output parameters\n\nsubcarriers : Vector of allocated subcarriers [Array{Int, L δ ]\n\nv 1.0 - Robin Gerzaguet.\n\n\n\n\n\n","category":"method"},{"location":"base/#FBMC","page":"Function list","title":"FBMC","text":"","category":"section"},{"location":"base/","page":"Function list","title":"Function list","text":"Modules = [DigitalComm]\nPages   = [\"Waveforms/FBMC/fbmcSigGen.jl\",\"Waveforms/FBMC/fbmcSigDecode.jl\"]\nOrder   = [:function, :type]","category":"page"},{"location":"base/#DigitalComm.fbmcSigGen-NTuple{4, Any}","page":"Function list","title":"DigitalComm.fbmcSigGen","text":"\n\nGenerate a FBMC-OQAM signal in time domain, based on input complex matrix (before OQAM processing) and FBMC parameters.\n\nTransmitter is based on Polyphase Network implementation, with PHYDIAS filter (parametrized by overlapping factor).\n\n–- Syntax\n\nfbmcSigGen(qamMat,nFFT,K,allocatedSubcarriers)\n\n–- Input parameters\n\nqamMat\t: Complex QAM Time-Frequency matrix [Array{Complex{Float64}}]\nnFFT\t\t: FFT size  [Int]\nK\t\t\t: Overlapping factor [Int] \nallocatedSubcarriers\t: Vector of allocated subcarriers [Array{Int}]\n\n–- Output parameters\n\nsigId\t\t: Complex baseband signal in time domain [Array{Complex{Float64}},nbEch]; nbEch = (2nbSymb-1)nFFT/2+nFFTK)\n\n–-\n\nv 1.0 - Robin Gerzaguet.\n\n\n\n\n\n","category":"method"},{"location":"base/#DigitalComm.getFBMCFilter-Tuple{Any, Any}","page":"Function list","title":"DigitalComm.getFBMCFilter","text":"\n\nReturns the PHYDIAS time domain impulse response of desired FBMC filter parametrized by its overlapping factor and FFT size\n\n–- Syntax\n\np = getFBMCFilter(K,nFFT,type);\n\n–- Input parameters\n\nK\t  : Overlapping factor\nnFFT: FFT size \n\n–- Output parameters\n\np\t  : FBMC time impulse response \n\n–-\n\nv 1.0 - Robin Gerzaguet.\n\n\n\n\n\n","category":"method"},{"location":"base/#DigitalComm.initFBMC-Tuple{Any, Any, Any}","page":"Function list","title":"DigitalComm.initFBMC","text":"\n\nInitiate FBMC structure \n\n–- Syntax\n\nfbmc = initFBMC(nFFT,K,allocatedSubcarriers)\n\n–- Input parameters\n\nnFFT\t  : FFT size \nK\t\t  : Overlapping factor \nallocatedSubcarriers\t: Vector of allocated subcarriers [Array{Int}]\n\n–- Output parameters\n\nfbmc\t  : FBMC structure [StrucFBMC]\n\n–-\n\nv 1.0 - Robin Gerzaguet.\n\n\n\n\n\n","category":"method"},{"location":"base/#DigitalComm.oqamMapping-Tuple{Any}","page":"Function list","title":"DigitalComm.oqamMapping","text":"\n\nApply OQAM pre-processing to incoming matrix qamMat of size nbSubcarriers x nbSymb\n\n–- Syntax\n\noqamMat = oqamConversion(qamMat)\n\n–- Input parameters\n\nqamMat : Input complex qam Matrix [Array{Complex{Float64,nbSubcarriers,nbSymb}}]\n\n–- Output parameters\n\noqamMat : OQAM matrix (pure real and pure imag. alterns) [Array{Complex{Float64,nbSubcarriers,nbSymb*2}}]\n\n–-\n\nv 1.0 - Robin Gerzaguet.\n\n\n\n\n\n","category":"method"},{"location":"base/#DigitalComm.StrucFBMC","page":"Function list","title":"DigitalComm.StrucFBMC","text":"\n\nFBMC waveform structure\n\n–- Syntax\n\nnFFT\t  : FFT size \nK\t\t  : Overlapping factor \nallocatedSubcarriers\t: Vector of allocated subcarriers [Array{Int}]\n\n–-\n\nv 1.0 - Robin Gerzaguet.\n\n\n\n\n\n","category":"type"},{"location":"base/#DigitalComm.fbmcSigDecode-NTuple{4, Any}","page":"Function list","title":"DigitalComm.fbmcSigDecode","text":"\n\nDemodulate FBMC waveform based on the dual operation of fbmcSigGen\n\nFBMC is parametrized by its FFT size, its cyclic prefix length (in samples) and the allocSubcarriers vector\n\nSyntax\n\nsigId\t= fbmcSigDecode(sigRx,nFFT,K,allocSubcarriers)\n\n–-  Input parameters\n\nsigRx\t  : Time domain FBMC signal  [Array{Complex{Float64},nbEch}]\nnFFT\t  : FFT size [Int]\nK\t\t  : Overlapping factor [Int]\n\nallocSubcarriers : Vector of index of allocated subcarriers [Array{Int,nbSubcarriers}]\n\n–-  Output parameters\n\nqamMat  : Time frequency matrix : [Array{Complex{Float64},nbSubcarriers,nbSymb}]\n\n–-\n\nv 1.0 - Robin Gerzaguet.\n\n\n\n\n\n","category":"method"},{"location":"base/#DigitalComm.oqamDemapping-Tuple{Any}","page":"Function list","title":"DigitalComm.oqamDemapping","text":"\n\nApply OQAM demapping to incoming OQAM matrix qamMat of size nbSubcarriers x 2nbSymb\n\n–- Syntax\n\nqamMat = oqamDemapping(qamMat)\n\n–- Input parameters\n\noqamMat : OQAM matrix (pure real and pure imag. alterns) [Array{Complex{Float64,nbSubcarriers,nbSymb*2}}]\n\n–- Output parameters\n\nqamMat : Output complex qam Matrix [Array{Complex{Float64,nbSubcarriers,nbSymb}}]\n\n–-\n\nv 1.0 - Robin Gerzaguet.\n\n\n\n\n\n","category":"method"},{"location":"base/#OFDM","page":"Function list","title":"OFDM","text":"","category":"section"},{"location":"base/","page":"Function list","title":"Function list","text":"Modules = [DigitalComm]\nPages   = [\"Waveforms/OFDM/ofdmSigGen.jl\",\"Waveforms/OFDM/ofdmSigDecode.jl\"]\nOrder   = [:function, :type]","category":"page"},{"location":"base/#DigitalComm.initOFDM-Tuple{Any, Any, Any}","page":"Function list","title":"DigitalComm.initOFDM","text":"\n\nCreate OFDM structure \n\n–- Syntax\n\nofdm\t= initOFDM(nFFT,nCP,allocatedSubcarriers)\n\n–- Input parameters\n\nnFFT\t  : FFT size [Int]\nnCP\t  : Cyclic prefix size [Int]\nallocatedSubcarrier\t: Vector of allocated subbcarriers [Array{Int}]\n\n–- Output parameters\n\nofdm\t  : OFDM structure [StrucOFDM] \n\n–-\n\nv 1.0 - Robin Gerzaguet.\n\n\n\n\n\n","category":"method"},{"location":"base/#DigitalComm.ofdmSigGen!-NTuple{5, Any}","page":"Function list","title":"DigitalComm.ofdmSigGen!","text":"\n\nPopulate a OFDM signal in time domain based on input T/F matrix and OFDM parameters\n\nqamMat is a complex symbol matrix (for instance QPSK) of size length(allocatedSubcarriers) x nbSymb \n\nThe output signal in time domain is of size (nFFT+nCP)xnbSymb.\n\n–- Syntax\n\nofdmSigGen!(sigId,qamMat,nFFT,nCP,allocatedSubcarriers)\n\n–- Input parameters\n\nsigId\t  : Signal in time domain [Array{Complex{Float64}},(nFFT+nCP)xnbSymb]\nqamMat  : Complex T/F matrix to map [Array{Float64},length(allocatedSubcarriers),nbSymb]\nnFFT\t  : FFT size [Int] \nnCP\t  : Cylic prefix size [Int] \nallocatedSubcarrier\t: Vector of allocated subbcarriers [Array{Int}]\n\n–- Output parameters\n\n[]\n\n–-\n\nv 1.0 - Robin Gerzaguet.\n\n\n\n\n\n","category":"method"},{"location":"base/#DigitalComm.ofdmSigGen!-Tuple{Any, Any, DigitalComm.StrucOFDM}","page":"Function list","title":"DigitalComm.ofdmSigGen!","text":"\n\nPopulate a  OFDM signal in time domain based on input T/F matrix and OFDM structure  \n\nqamMat is a complex symbol matrix (for instance QPSK) of size length(allocatedSubcarriers) x nbSymb \n\nThe output signal in time domain is of size (nFFT+nCP)xnbSymb.\n\n–- Syntax\n\nofdmSigGen!(sigId,qamMat,nFFT,nCP,allocatedSubcarriers)\n\n–- Input parameters\n\nsigId\t  : Signal in time domain [Array{Complex{Float64}},(nFFT+nCP)xnbSymb]\nqamMat  : Complex T/F matrix to map [Array{Float64},length(allocatedSubcarriers),nbSymb]\nofdm\t  : OFDM structure [StrucOFDM]\n\n–- Output parameters\n\n[]\n\n–-\n\nv 1.0 - Robin Gerzaguet.\n\n\n\n\n\n","category":"method"},{"location":"base/#DigitalComm.ofdmSigGen-NTuple{4, Any}","page":"Function list","title":"DigitalComm.ofdmSigGen","text":"\n\nCreate OFDM signal in time domain based on input T/F matrix and OFDM parameters\n\nqamMat is a complex symbol matrix (for instance QPSK) of size length(allocatedSubcarriers) x nbSymb \n\nThe output signal in time domain is of size (nFFT+nCP)xnbSymb.\n\n–- Syntax\n\nsigId = ofdmSigGen(qamMat,nFFT,nCP,allocatedSubcarriers)\n\n–- Input parameters\n\nqamMat  : Complex T/F matrix to map [Array{Float64},length(allocatedSubcarriers),nbSymb]\nnFFT\t  : FFT size [Int] \nnCP\t  : Cylic prefix size [Int] \nallocatedSubcarrier\t: Vector of allocated subbcarriers [Array{Int}]\n\n–- Output parameters\n\nsigId\t  : Signal in time domain [Array{Complex{Float64}},(nFFT+nCP)xnbSymb]\n\n–-\n\nv 1.0 - Robin Gerzaguet.\n\n\n\n\n\n","category":"method"},{"location":"base/#DigitalComm.ofdmSigGen-Tuple{Any, DigitalComm.StrucOFDM}","page":"Function list","title":"DigitalComm.ofdmSigGen","text":"\n\nCreate OFDM signal in time domain based on input T/F matrix and OFDM structure  \n\nqamMat is a complex symbol matrix (for instance QPSK) of size length(allocatedSubcarriers) x nbSymb \n\nThe output signal in time domain is of size (nFFT+nCP)xnbSymb.\n\n–- Syntax\n\nsigId = ofdmSigGen(qamMat,nFFT,nCP,allocatedSubcarriers)\n\n–- Input parameters\n\nqamMat  : Complex T/F matrix to map [Array{Float64},length(allocatedSubcarriers),nbSymb]\nofdm\t  : OFDM structure [StrucOFDM]\n\n–- Output parameters\n\nsigId\t  : Signal in time domain [Array{Complex{Float64}},(nFFT+nCP)xnbSymb]\n\n–-\n\nv 1.0 - Robin Gerzaguet.\n\n\n\n\n\n","category":"method"},{"location":"base/#DigitalComm.StrucOFDM","page":"Function list","title":"DigitalComm.StrucOFDM","text":"\n\nStructure for OFDM\n\n–- Syntax\n\nnFFT\t\t: FFT size [Int] \nnCP\t\t: Cyclic prefix size [Int] \nallocatedSubcarriers\t: Vector of allocated subbcarriers [Array{Int}]\n\n–-\n\nv 1.0 - Robin Gerzaguet.\n\n\n\n\n\n","category":"type"},{"location":"base/#DigitalComm.ofdmSigDecode!-NTuple{5, Any}","page":"Function list","title":"DigitalComm.ofdmSigDecode!","text":"ofdmSigDecode!\n\nDecodes a time domain OFDM signal and populate the  T/F matrix with decoded QAM symbols\n\n–- Syntax\n\nofdmSigDecode(qamRx,sigId,nFFT,nCP,allocSubcarriers);\n\n–-  Input parameters\n\nqamRx  : Time frequency matrix : [Array{Complex{Float64},nbSubcarriers,nbSymb}]\nsigId\t  : OFDM signal in time domain [Array{Complex{Float64},nbEch}]  ,(nbEch\t: Number of samples: nbSymb*(nFFT+nCp))\nnFFT\t  : FFT size [Int]\nnCp\t  : Cyclic prefix size (in samples) [Int]\n\nallocSubcarriers : Vector of index of allocated subcarriers [Array{Int,nbSubcarriers}]\n\n–-  Output parameters\n\n[]\n\nv 1.0 - Robin Gerzaguet.\n\n\n\n\n\n","category":"method"},{"location":"base/#DigitalComm.ofdmSigDecode!-Tuple{Any, Any, DigitalComm.StrucOFDM}","page":"Function list","title":"DigitalComm.ofdmSigDecode!","text":"ofdmSigDecode!\n\nDecodes a time domain OFDM signal and returns a T/F matrix with decoded QAM symbols\n\n–- Syntax\n\nqamRx\t= ofdmSigDecode!(qamRx,sigId,ofdm);\n\n–-  Input parameters\n\nqamRx  : Time frequency matrix : [Array{Complex{Float64},nbSubcarriers,nbSymb}]\nsigId\t  : OFDM signal in time domain [Array{Complex{Float64},nbEch}]  ,(nbEch\t: Number of samples: nbSymb*(nFFT+nCp))\nofdm\t  : OFDM structure [StrucOFDM]\n\n–-  Output parameters\n\n[]\n\n–-\n\nv 1.0 - Robin Gerzaguet.\n\n\n\n\n\n","category":"method"},{"location":"base/#DigitalComm.ofdmSigDecode-NTuple{4, Any}","page":"Function list","title":"DigitalComm.ofdmSigDecode","text":"ofdmSigDecode\n\nDecodes a time domain OFDM signal and returns a T/F matrix with decoded QAM symbols\n\n–- Syntax\n\nqamRx\t= ofdmSigDecode(sigId,nFFT,nCP,allocSubcarriers);\n\n–-  Input parameters\n\nsigId\t  : OFDM signal in time domain [Array{Complex{Float64},nbEch}]  ,(nbEch\t: Number of samples: nbSymb*(nFFT+nCp))\nnFFT\t  : FFT size [Int]\nnCp\t  : Cyclic prefix size (in samples) [Int]\n\nallocSubcarriers : Vector of index of allocated subcarriers [Array{Int,nbSubcarriers}]\n\n–-  Output parameters\n\nqamRx  : Time frequency matrix : [Array{Complex{Float64},nbSubcarriers,nbSymb}]\n\n–-\n\nv 1.0 - Robin Gerzaguet.\n\n\n\n\n\n","category":"method"},{"location":"base/#DigitalComm.ofdmSigDecode-Tuple{Any, DigitalComm.StrucOFDM}","page":"Function list","title":"DigitalComm.ofdmSigDecode","text":"ofdmSigDecode\n\nDecodes a time domain OFDM signal and returns a T/F matrix with decoded QAM symbols\n\n–- Syntax\n\nqamRx\t= ofdmSigDecode(sigId,ofdm);\n\n–-  Input parameters\n\nsigId\t  : OFDM signal in time domain [Array{Complex{Float64},nbEch}]  ,(nbEch\t: Number of samples: nbSymb*(nFFT+nCp))\nofdm\t  : OFDM structure [StrucOFDM]\n\n–-  Output parameters\n\nqamRx  : Time frequency matrix : [Array{Complex{Float64},nbSubcarriers,nbSymb}]\n\n–-\n\nv 1.0 - Robin Gerzaguet.\n\n\n\n\n\n","category":"method"},{"location":"base/#SC-FDMA","page":"Function list","title":"SC-FDMA","text":"","category":"section"},{"location":"base/","page":"Function list","title":"Function list","text":"Modules = [DigitalComm]\nPages   = [\"Waveforms/UFOFDM/ufofdmSigGen.jl\",\"Waveforms/UFOFDM/ufofdmSigDecode.jl\"]\nOrder   = [:function, :type]","category":"page"},{"location":"base/#DigitalComm.convT-Union{Tuple{T}, Tuple{Array{T, N} where N, Array{T, N} where N}} where T","page":"Function list","title":"DigitalComm.convT","text":"\n\nPerform time domain naive convolution. For UF-OFDM, size of filter is small so doing it in frequency domain is not appropriate\n\n–- Syntax\n\nc = convT(a,b);\n\n–- Input parameters\n\na\t  : First signal \nb\t  : Second signal \n\n–- Output parameters\n\nc\t  : a * b \n\n–-\n\nv 1.0 - Robin Gerzaguet.\n\n\n\n\n\n","category":"method"},{"location":"base/#DigitalComm.initUFOFDM-Tuple{Any, Any, Any}","page":"Function list","title":"DigitalComm.initUFOFDM","text":"\n\nCreate UF-OFDM structure\n\n–- Syntax\n\nufofdm\t= initUFOFDM(nFFT,L,allocatedSubcarriers;sizeRB=12,applyPD=1,attenuation=40)\n\n–- Input parameters\n\nnFFT\t\t: FFT size [Int] \nL\t\t\t: Filter size [Int]\nallocatedSubcarriers\t: Vector of allocated subbcarriers [Array{Int}] \nsizeRB\t: Carrier size in terms of subcarrier (often 12)  [Array{Int}]\napplyPD\t: Apply Pre-distortion at Tx stage (default 1, 0 : not applied) [Int=0 or 1] \nattenuation : dolphChebyshev filter attenation \nfilterTaps  : Filter impulse response coefficient [Array{Float64}]- \n\n–- Output parameters\n\nufofdm\t: UF-OFDM structure [StrucUFOFDM] \n\n–-\n\nv 1.0 - Robin Gerzaguet.\n\n\n\n\n\n","category":"method"},{"location":"base/#DigitalComm.ufofdmSigGen-NTuple{4, Any}","page":"Function list","title":"DigitalComm.ufofdmSigGen","text":"\n\nApply Universal Filtered Orthogonal Frequency Division Multiplexing (UF-OFDM) to the time frequency matrix qamMat and returns a time domain UF-OFDM signal [1,2]\n\nufofdm is parametrized by its FFT size, the filter length (in samples) and the allocatedSubcarriers vector. Optional parameters are carrier size in subcarrier (by default RB size which is 12) Dolph-Chebyshev window attenuation (40) and predistortion application (set to 1)\n\n–- Syntax\n\nsigId\t= genereSignalufofdm(qamMat,nFFT,nCp,allocatedSubcarriers;sizeRB=12,applyPD=1,attenuation=40)\n\n–-  Input parameters\n\nqamMat  : Time frequency matrix : [Array{Complex{Float64},nbSubcarriers,nbSymb}]\nnbSymb\t\t\t: Number of ufofdm symbol tro be transmitted\nnbSubcarriers\t: Number of allocated subcarriers (shall be < nFFT)\nnFFT\t  : FFT size [Int]\nL\t\t  : Dolph Chebyshev filter length [Int]\nallocatedSubcarriers : Vector of index of allocated subcarriers [Array{Int,nbSubcarriers}]\nsizeRB  : Carrier size in subcarriers (default : LTE RB size: 12) [Int]\napplyPD : Filter shape compensation (enabled by default) [Int]\nattenuation : DC filter attenation in dB (default: 90) [Float64]\nfilterTaps : Filter coefficient (default empty and recreated)\npdCoeffs\t  : Predistortion  Filter coefficient (default empty and recreated)\n\n–-  Output parameters\n\nsigId\t  : ufofdm signal in time domain [Array{Complex{Float64},nbEch}]\n\nReferences\n\n[1] R. Gerzaguet and al. The 5G candidate waveform race: a comparison of complexity and performance. EURASIP Journal on Wireless Communications and Networking, 2017\n[2] V. Vakilian and al: Universal-filtered multi-carrier technique for wireless systems beyond LTE. Proc. IEEE Globecom Workshops (GC Wkshps), 2013\n\n–-\n\nv 1.0 - Robin Gerzaguet.\n\n\n\n\n\n","category":"method"},{"location":"base/#DigitalComm.ufofdmSigGen-Tuple{Any, DigitalComm.StrucUFOFDM}","page":"Function list","title":"DigitalComm.ufofdmSigGen","text":"\n\nApply Universal Filtered Orthogonal Frequency Division Multiplexing (UF-OFDM) to the time frequency matrix qamMat and returns a time domain UF-OFDM signal [1,2]\n\nufofdm is parametrized by its FFT size, the filter length (in samples) and the allocatedSubcarriers vector. Optional parameters are carrier size in subcarrier (by default RB size which is 12) Dolph-Chebyshev window attenuation (40) and predistortion application (set to 1)\n\n–- Syntax\n\nsigId\t= genereSignalufofdm(qamMat,ufofdm);\n\n–-  Input parameters\n\nqamMat  : Time frequency matrix : [Array{Complex{Float64},nbSubcarriers,nbSymb}]\nufofdm  : UF-OFDM structure [StrucUFOFDM]\n\n–-  Output parameters\n\nsigId\t  : ufofdm signal in time domain [Array{Complex{Float64},nbEch}]\n\nReferences\n\n[1] R. Gerzaguet and al. The 5G candidate waveform race: a comparison of complexity and performance. EURASIP Journal on Wireless Communications and Networking, 2017\n[2] V. Vakilian and al: Universal-filtered multi-carrier technique for wireless systems beyond LTE. Proc. IEEE Globecom Workshops (GC Wkshps), 2013\n\n–-\n\nv 1.0 - Robin Gerzaguet.\n\n\n\n\n\n","category":"method"},{"location":"base/#DigitalComm.StrucUFOFDM","page":"Function list","title":"DigitalComm.StrucUFOFDM","text":"Structure for UFOFDM\n\n–- Syntax\n\nnFFT\t\t: FFT size [Int] \nL\t\t\t: Filter size [Int]\nallocatedSubcarriers\t: Vector of allocated subbcarriers [Array{Int}] \nsizeRB\t: Carrier size in terms of subcarrier (often 12)  [Array{Int}]\napplyPD\t: Apply Pre-distortion at Tx stage (default 1, 0 : not applied) [Int=0 or 1] \nattenuation : dolphChebyshev filter attenation \nfilterTaps  : Filter impulse response coefficient [Array{Float64}]\npd\t\t  : PD coefficients [Array{Complex{Float64}}]\n\n–-\n\nv 1.0 - Robin Gerzaguet.\n\n\n\n\n\n","category":"type"},{"location":"base/#UF-OFDM","page":"Function list","title":"UF-OFDM","text":"","category":"section"},{"location":"base/","page":"Function list","title":"Function list","text":"Modules = [DigitalComm]\nPages   = [\"Waveforms/filterUFOFDM.jl\",\"Waveforms/SCFDMA/scfdmaSigGen.jl\",\"Waveforms/SCFDMA/scfdmaSigDecode.jl\"]\nOrder   = [:function, :type]","category":"page"},{"location":"base/#DigitalComm.initSCFDMA-NTuple{4, Any}","page":"Function list","title":"DigitalComm.initSCFDMA","text":"\n\nCreate SCFDMA structure \n\n–- Syntax\n\nofdm\t= initSCFDMA(nFFT,nCP,allocatedSubcarriers)\n\n–- Input parameters\n\nnFFT\t  : FFT size [Int]\nnCP\t  : Cyclic prefix size [Int]\nallocatedSubcarrier\t: Vector of allocated subbcarriers [Array{Int}]\nsizeDFT\t: Size of DFT precoder (classic value is 12) [Int]\n\n–- Output parameters\n\nscfdma: SCFDMA structure [StrucSCFDMA] \n\n–-\n\nv 1.0 - Robin Gerzaguet.\n\n\n\n\n\n","category":"method"},{"location":"base/#DigitalComm.scfdmaSigGen-NTuple{5, Any}","page":"Function list","title":"DigitalComm.scfdmaSigGen","text":"\n\nCreate SCFDMA signal in time domain based on input T/F matrix and SCFDMA parameters. SCFDMA apply a precoder before the IFFT at the transmitter side in order to lower the signal fluctuation\n\nqamMat is a complex symbol matrix (for instance QPSK) of size length(allocatedSubcarriers) x nbSymb \n\nThe output signal in time domain is of size (nFFT+nCP)xnbSymb.\n\n–- Syntax\n\nsigId = scfdmaSigGen(qamMat,nFFT,nCP,allocatedSubcarriers)\n\n–- Input parameters\n\nqamMat  : Complex T/F matrix to map [Array{Float64},length(allocatedSubcarriers),nbSymb]\nnFFT\t  : FFT size [Int] \nnCP\t  : Cylic prefix size [Int] \nallocatedSubcarrier\t: Vector of allocated subbcarriers [Array{Int}]\nsizeDFT\t: Size of DFT precoder (classic value is 12) [Int]\n\n–- Output parameters\n\nsigId\t  : Signal in time domain [Array{Complex{Float64}},(nFFT+nCP)xnbSymb]\n\n–-\n\nv 1.0 - Robin Gerzaguet.\n\n\n\n\n\n","category":"method"},{"location":"base/#DigitalComm.StrucSCFDMA","page":"Function list","title":"DigitalComm.StrucSCFDMA","text":"\n\nStructure for SCFDMA\n\n–- Syntax\n\nnFFT\t\t: FFT size [Int] \nnCP\t\t: Cyclic prefix size [Int] \nallocatedSubcarriers\t: Vector of allocated subbcarriers [Array{Int}]\nsizeDFT\t: Size of DFT precoder (classic value is 12) [Int]\n\n–-\n\nv 1.0 - Robin Gerzaguet.\n\n\n\n\n\n","category":"type"},{"location":"base/#DigitalComm.scfdmaPostProcessing-Tuple{Any, Any}","page":"Function list","title":"DigitalComm.scfdmaPostProcessing","text":"\n\nApply Post processing for SC-FDMA (i.e DFT post-processing stage). This function can be called if scfdmaSigDecode is called with post processing flag to 0 (if frequency egalisation is done for example)\n\n–- Syntax\n\nqamPost\t  = scfdmaPostProcessing(qamMat,sizeDFT)\n\n–- Input parameters\n\nqamMat  : T/F matrix after Rx FFT (and before Rx IDFT) [Array{Complex{Float64}},nbSubcarriers,nbSymb]\nsizeDFT\t: Precoder bloc size (often 12)\n\n–- Output parameters\n\nqamPost\t: T/F matrix after IDFT processing [Array{Complex{Float64},nbSubcarriers,nbSymb}]\n\n–-\n\nv 1.0 - Robin Gerzaguet.\n\n\n\n\n\n","category":"method"},{"location":"base/#DigitalComm.scfdmaSigDecode","page":"Function list","title":"DigitalComm.scfdmaSigDecode","text":"\n\nApply SCFDMA demodulator to input signal and returns the T/F QAM matrix\n\n–- Syntax\n\nqamRx\t= scfdmaSigDecode(sigId,nFFT,nCP,allocSubcarriers,sizeDFT);\n\n–- Input parameters\n\n–-  Input parameters\n\nsigId\t  : SCFDMA signal in time domain [Array{Complex{Float64},nbEch}]\nnFFT\t  : FFT size [Int]\nnCp\t  : Cyclic prefix size (in samples) [Int]\nallocSubcarriers : Vector of index of allocated subcarriers [Array{Int,nbSubcarriers}]\nsizeDFT\t: Post processing size (DFT size)\ndoPostProcessing : Do the post processing stage (IDFT): Default 1. In some case, we need the raw data (i.e data before postprocessing stage) such as in channel equalisation. In this case, the post processing should be done in a separate step (with the call of scfdmaPostProcessing function)\n\n–-  Output parameters\n\nqamRx  : Time frequency matrix : [Array{Complex{Float64},nbSubcarriers,nbSymb}]\n\n–-\n\nv 1.0 - Robin Gerzaguet.\n\n\n\n\n\n","category":"function"},{"location":"base/#DigitalComm.scfdmaSigDecode-2","page":"Function list","title":"DigitalComm.scfdmaSigDecode","text":"\n\nApply SCFDMA demodulator to input signal and returns the T/F QAM matrix\n\n–- Syntax\n\nqamRx\t= scfdmaSigDecode(sigId,nFFT,nCP,allocSubcarriers,sizeDFT);\n\n–- Input parameters\n\n–-  Input parameters\n\nsigId\t  : SCFDMA signal in time domain [Array{Complex{Float64},nbEch}]\nscfdma  : SCFDMA structure [StrucSCFDMA]\ndoPostProcessing : Do the post processing stage (IDFT): Default 1. In some case, we need the raw data (i.e data before postprocessing stage) such as in channel equalisation. In this case, the post processing should be done in a separate step (with the call of scfdmaPostProcessing function)\n\n–-  Output parameters\n\nqamRx  : Time frequency matrix : [Array{Complex{Float64},nbSubcarriers,nbSymb}]\n\n–-\n\nv 1.0 - Robin Gerzaguet.\n\n\n\n\n\n","category":"function"},{"location":"base/#WOLA","page":"Function list","title":"WOLA","text":"","category":"section"},{"location":"base/","page":"Function list","title":"Function list","text":"Modules = [DigitalComm]\nPages   = [\"Waveforms/WOLA/wolaSigGen.jl\",\"Waveforms/WOLA/wolaSigDecode.jl\"]\nOrder   = [:function, :type]","category":"page"},{"location":"base/#DigitalComm.initWOLA-NTuple{7, Any}","page":"Function list","title":"DigitalComm.initWOLA","text":"\n\nCreate and initiate a WOLA waveform structure \n\n–- Syntax\n\nwola = initWOLA(nFFT,nCP,allocatedSubcarriers,winFuncTx,winLengthTx,winFuncRx,winLengthRx;windowTx=[],windowRx=[])\n\n–- Input parameters\n\nnFFT\t  : FFT size [Int] \nnCP\t  : CP size [Int] \nallocatedSubcarriers\t: Vector of allocated subcarriers [Array{Int}] \nwinFuncTx\t  : Name of window used @Tx \nwinLengthTx : Size of window @Tx \nwinFuncRx\t  : Name of window used @Rx \nwinLengthRx : Size of window @Rx \nwindowTx\t  : Coefficient of Tx window. By default it is empty. To force a given window, populate this vector. If let empty, the window will be created based on winLengthTx and winFuncTx\nwindowRx\t  : Coefficient of Rx window. By default it is empty. To force a given window, populate this vector. If let empty, the window will be created based on winLengthRx and winFuncRx\n\n–- Output parameters\n\nwola\t\t  : Waveform structure\n\n–-\n\nv 1.0 - Robin Gerzaguet.\n\n\n\n\n\n","category":"method"},{"location":"base/#DigitalComm.wolaSigGen","page":"Function list","title":"DigitalComm.wolaSigGen","text":"\n\nApply Weighted Overlap and Add Orthogonal Frequency Division Multiplexing (WOLA-OFDM) to the time frequency matrix qamMat and returns a time domain OFDM signal OFDM is parametrized by its FFT size, its cyclic prefix length (in samples) and the allocSubcarriers vector. The WOLA part is parametrized by the window applied at each beginning and ending of symbols. The window size can be (and is likely to be) higher than the length of the CP and pure OFDM compatibility is ensured by overlapping the symbols. The interested reader can refer to [1] [2] and [3] for WOLA principle description.\n\n–-\n\nSyntax\n\nsigId\t= wolaSigGen(qamMat,nFFT,nCP,allocSubcarriers,winFunc,winLength=0)\n\n–-  Input parameters\n\nqamMat  : Time frequency matrix : [Array{Complex{Float64},nbSubcarriers,nbSymb}]\nnbSymb\t\t\t: Number of OFDM symbol tro be transmitted\nnbSubcarriers\t: Number of allocated subcarriers (shall be < nFFT)\nnFFT\t  : FFT size [Int]\nnCP\t  : Cyclic prefix size (in samples) [Int]\nallocSubcarriers : Vector of index of allocated subcarriers [Array{Int,nbSubcarriers}]\nwinFunc : Type of window. Can be a string of supported window or directly the window taps.\nwinLength : Length of window. This parameter is not used if winFunc is an array of the window tap.\n\n–-  Output parameters\n\nsigId\t  : WOLA-OFDM signal in time domain [Array{Complex{Float64},nbEch}]. nbEch\t: Number of samples: nbSymb*(nFFT+nCP)\n\n–-\n\nSupported window\n\n-\t\"Triangle\"\t\t: Triangle window -\t\"srrc\"\t\t\t: Square Root Raised Cosine -\t\"Meyer\"\t\t\t: Meyer window (See [1])\n\n–-\n\nReferences\n\n[1] R. Zayani, Y. Medjahdi, H. Shaiek and D. Roviras, \"WOLA-OFDM: A Potential Candidate for Asynchronous 5G,\" 2016.\n[2] Y. Medjahdi and al, \"On the road to 5G: Comparative study of Physical layer in MTC context\", 2017.\n[3] R. Gerzaguet and al, \"Comparison of Promising Candidate Waveforms for 5G: WOLA-OFDM Versus BF-OFDM\", 2017.\n\n–-\n\nv 1.0 - Robin Gerzaguet.\n\n\n\n\n\n","category":"function"},{"location":"base/#DigitalComm.StrucWOLA","page":"Function list","title":"DigitalComm.StrucWOLA","text":"\n\nWOLA waveform structure \n\n–- Syntax\n\nnFFT\t  : FFT size [Int] \nnCP\t  : CP size [Int] \nallocatedSubcarriers\t: Vector of allocated subcarriers [Array{Int}] \nwindowTx\t: Window used @ transmitter side \nwindowRx\t: Window used @ recevier side \n\n–-\n\nv 1.0 - Robin Gerzaguet.\n\n\n\n\n\n","category":"type"},{"location":"base/#DigitalComm.wolaSigDecode","page":"Function list","title":"DigitalComm.wolaSigDecode","text":"\n\nApply WOLA-OFDM demodulator to input signal and returns the T/F QAM matrix\n\n–-\n\nSyntax qamRx\t= wolaSigDecode(sigId,nFFT,nCP,allocSubcarriers);\n\n–-  Input parameters\n\nsigId\t  : OFDM signal in time domain [Array{Complex{Float64},nbEch}]\nnbEch\t: Number of samples: nbSymb*(nFFT+nCP)\nnFFT\t  : FFT size [Int]\nnCP\t  : Cyclic prefix size (in samples) [Int]\nallocSubcarriers : Vector of index of allocated subcarriers [Array{Int,nbSubcarriers}]\nwinLengthTx\t: Window size @Tx side (FFT rotation)\ndoTailBiting\t: Do tail biting approach (by default 1) [Int]\nwinFunc : Type of window. Can be a string of supported window or directly the window taps.\nwinLength : Length of window. This parameter is not used if winFunc is an array of the window tap.\n\n–-  Output parameters\n\nqamMat  : Time frequency matrix : [Array{Complex{Float64},nbSubcarriers,nbSymb}]\n\n–-\n\nSupported window\n\n-\t\"Triangle\"\t\t: Triangle window -\t\"srrc\"\t\t\t: Square Root Raised Cosine -\t\"Meyer\"\t\t\t: Meyer window (See [1])\n\n–-\n\nReferences\n\n[1] R. Zayani, Y. Medjahdi, H. Shaiek and D. Roviras, \"WOLA-OFDM: A Potential Candidate for Asynchronous 5G,\" 2016.\n[2] Y. Medjahdi and al, \"On the road to 5G: Comparative study of Physical layer in MTC context\", 2017.\n[3] R. Gerzaguet and al, \"Comparison of Promising Candidate Waveforms for 5G: WOLA-OFDM Versus BF-OFDM\", 2017.\n\n–-\n\nv 1.0 - Robin Gerzaguet.\n\n\n\n\n\n","category":"function"},{"location":"Examples/example_PSD/#Plotting-PSD-of-several-multicarrier-waveforms","page":"Plotting PSD of several multicarrier waveforms","title":"Plotting PSD of several multicarrier waveforms","text":"","category":"section"},{"location":"Examples/example_PSD/","page":"Plotting PSD of several multicarrier waveforms","title":"Plotting PSD of several multicarrier waveforms","text":"The purpose is to compre the Power spectral density of several multicarrier waveform. The following module can be used:","category":"page"},{"location":"Examples/example_PSD/","page":"Plotting PSD of several multicarrier waveforms","title":"Plotting PSD of several multicarrier waveforms","text":"module example_PSD_waveform \n# ---------------------------------------------------- \n# --- Modules  \n# ---------------------------------------------------- \nusing DigitalComm \n# --- External Modules\nusing Plots \ngr();\nusing Printf\nusing FFTW\n# ---------------------------------------------------- \n# --- Core functions  \n# ---------------------------------------------------- \n\"\"\" psdWaveform.m \n---  \nCompute the power spectral density (i.e the spectrum here) of the signal parametrized by the waveform structure waveform, for a number of symbol nbSymb.\nThe frequency allocation is the one inherited from the waveform structure (i.e waveform.allocatedSubcarriers).\n# --- Syntax \n( freq,psd )    = psdWaveform(waveform,nbSymb,allocatedSubcarriers);\n# ---  Input parameters \n- waveform  : Structure associated to transmitted waveform \n- nbSymb      : Number of symbol to be transmitted [Int]\n- nbIt    : Monte carlo parameter for PSD evaluation (should be > 1)\n# --- Output parameters \n- freq    : Vector of frequency evaluation (between -0.5 and 0.5). [Array{Float64,L}]\n- psd     : Spectrum evaluated on freq [Array{Complex{Float64}},L]\n# --- Input parameters \n- \n# --- Output parameters \n- \n# --- \n# v 1.0 - Robin Gerzaguet.\n\"\"\"\nfunction  psdWaveform(waveform,nbSymb,nbIt)\n    # ----------------------------------------------------\n    # --- PSD calculation\n    # ---------------------------------------------------- \n    # --- Getting frequency allocation \n    allocatedSubcarriers  = waveform.allocatedSubcarriers;\n    # --- Getting number of bits \n    # First, frequency size \n    nbSubcarriers         = length(allocatedSubcarriers);\n    # Force a fiven mcs \n    mcs                   = 4;    # QPSK.\n    # Deduce number of required bits \n    nbBits                = nbSymb * nbSubcarriers * Int(log2(mcs));\n    # --- Init psd evaluator \n    psd = 0;\n    # --- Iterative PSD calculation\n    for iN = 1 : 1 : nbIt\n        # --- Binary sequence\n        bitSeq        = genBitSequence(nbBits);\n        # Mapping\n        qamSeq        = bitMappingQAM(mcs,bitSeq);\n        # --- T/F matrix\n        qamMat        = reshape(qamSeq,nbSubcarriers,nbSymb);\n        # --- Signal\n        sigPSD        = genSig(qamMat,waveform);\n        # --- Mean PSD:\n        psd           = psd .+ 1/nbIt*1/length(sigPSD)*abs.(fftshift(fft(sigPSD))).^2;\n    end\n    # --- Calculating sampling frequency\n    # Returns Nyquist frequency \n    fe      = 1;\n    Basefe  = (0:(length(psd) .-1))./length(psd)*fe .-fe/2;\n    return (Basefe,psd);\nend\n# ---------------------------------------------------- \n# --- Main routine  \n# ---------------------------------------------------- \nfunction main()\n    # ----------------------------------------------------\n    # --- Overall parameters\n    # ----------------------------------------------------\n    # --- Overall PHY parameters\n    nbIt            = 50;             # --- Iteration number\n    nbSymb          = 14;             # --- Number of symbols (one frame)\n    nFFT            = 1024;           # --- Base FFT size\n    samplingFreq    = 15.36;          # --- Frequency value (MHz)\n    # --- Frequency allocation\n    #allocatedSubcarriers= getLTEAlloc(nFFT);\n    #allocatedSubcarriers = (1:12*4);\n    # 4 RB alloc. 1 RB space. 4 RB allocated\n    allocatedSubcarriers = [1:12*4; 12*5 .+ (1:12*4)];\n    # ----------------------------------------------------\n    # --- Waveform contender\n    # ----------------------------------------------------\n    # --- Init OFDM structure\n    ofdm  = initOFDM(\n                        nFFT,                           # --- nFFT                 : FFT size\n                        72,                             # --- nCP                  : CP size\n                        allocatedSubcarriers            # --- allocatedSubcarriers : Subcarrier allocation\n                        );\n    # --- Init SCFDMA structure\n    scfdma  = initSCFDMA(\n                            nFFT,                       # --- nFFT                 : FFT size\n                            72,                         # --- nCP                  : CP size\n                            allocatedSubcarriers,       # --- allocatedSubcarriers : Subcarrier allocation\n                            12;                         # --- sizeDFT              : DFT preprocessing size\n                            );\n    # --- Init UF-OFDM structure\n    ufofdm  = initUFOFDM(\n                            nFFT,                       # --- nFFT                 : FFT size\n                            73,                         # --- L                    : Filter length (same size +1 due to conv)\n                            allocatedSubcarriers,       # --- allocatedSubcarriers : Subcarrier allocation\n                            applyPD=1,                  # --- applyPD              : Do predistortion at Tx stage\n                            attenuation=40,             # --- attenuation          : Filter attenuation in dB\n                            );\n    # --- Init BF-OFDM structure\n    bfofdm  = initBFOFDM(\n                            32,                         # --- nFBMC                : PPN size (max number of carriers)\n                            64,                         # --- nOFDM                : Precoder size (OFDM sizer)\n                            3,                          # --- K                    : Overlapping factor\n                            9,                          # --- GI                   : CP size of precoder\n                            0.5,                        # --- δ                    : compression factor\n                            allocatedSubcarriers,       # --- allocatedSubcarriers : Subcarrier allocation\n                            \"gaussian\",                 # --- filterName           : Pulse shape name\n                            BT=0.36,                    # --- BT                   : Potential BT value for Gaussian\n                            filterStopBand = 110,       # --- filterStopBand       : DC stopband value\n                            fS=[],                      # --- fS                   : Potential frequency coefficient for FS filter\n                            nFFT= 1024,                 # --- nFFT                 : associated FFT value in Rx\n                            nCP= 72,                    # --- nCP                  : extended CP size\n                            );\n    # --- Init WOLA-OFDM structure\n    wola  = initWOLA(\n                        nFFT,                           # --- nFFT                 : FFT size\n                        72,                             # --- nCP                  : CP size\n                        allocatedSubcarriers,           # --- allocatedSubcarriers : Subcarrier allocation\n                        \"triangle\",                     # --- Window type @Tx side\n                        20,                             # --- Window size @Tx side\n                        \"triangle\",                     # --- Window type @Rx side\n                        20,                             # --- Window size @Rx side\n                        );\n    fbmc  = initFBMC(\n                        nFFT,                           # --- nFFT                 : FFT size\n                        4,                              # --- K                    : Overlapping factor\n                        allocatedSubcarriers            # --- allocatedSubcarriers : Subcarrier allocation\n                        );\n    # ----------------------------------------------------\n    # --- Merging structures\n    # ----------------------------------------------------\n    # Create  a dictionnary to rule them all \n    waveforms   = initWaveforms(ofdm,\n                                scfdma,\n                                ufofdm,\n                                bfofdm,\n                                wola,\n                                fbmc,\n                                );\n    # ---------------------------------------------------- \n    # --- PSD main calculation  \n    # ---------------------------------------------------- \n    # --- Init plot container \n    plt     = plot(reuse=false);\n    decim   = 1;    # decimation for light plots\n    # --- Iterative PSD generation\n    for (name,struc) in waveforms \n        # --- Calculate PSD for the configuration \n        (fe,psd)  = psdWaveform(struc,nbSymb,nbIt); \n        # Plot the result \n        plot!(plt,fe[1:decim:end].*samplingFreq,10 .* log10.(psd[1:decim:end]/maximum(psd)),label=name,legend=:topleft);\n    end\n    # --- Update plot and adding labels \n    # Purpose is to zoom out on allocated region.\n    scsN        = (1/1024)*samplingFreq;    # Subscarrier spacing (normalized)\n    rbV         = (12*12);                  # See several RB for psd fall-off\n    ylims!(-120,5);\n    xlims!(-rbV*scsN,maximum(allocatedSubcarriers)*scsN+2*12*scsN);\n    xlabel!(\"Frequency [MHz]\");\n    ylabel!(\"Spectrum\");\n    display(plt)\nend\nend","category":"page"},{"location":"Examples/example_PSD/","page":"Plotting PSD of several multicarrier waveforms","title":"Plotting PSD of several multicarrier waveforms","text":"By running example_PSD_waveform.main(); a comparison plot between the different PSD can be obtained","category":"page"},{"location":"Examples/example_PSD/","page":"Plotting PSD of several multicarrier waveforms","title":"Plotting PSD of several multicarrier waveforms","text":"(Image: PSD)","category":"page"},{"location":"Examples/example_BER/#Compute-the-theoretical-BER-for-AWGN-channel-and-various-constellation-size","page":"Compute the theoretical BER for AWGN channel and various constellation size","title":"Compute the theoretical BER for AWGN channel and various constellation size","text":"","category":"section"},{"location":"Examples/example_BER/","page":"Compute the theoretical BER for AWGN channel and various constellation size","title":"Compute the theoretical BER for AWGN channel and various constellation size","text":"Based on the previous skeleton, we can now compute an iterative testbench to compute the Bit Error Rate for various constellation size, and compare the simulation with the theory. As  a gentle reminder, the theoretical bit error rate can be approximated as","category":"page"},{"location":"Examples/example_BER/","page":"Compute the theoretical BER for AWGN channel and various constellation size","title":"Compute the theoretical BER for AWGN channel and various constellation size","text":"mathrmBER = frac 4 left( 1 - frac1sqrtM right)  log_2(M) times Q( sqrt frac6  log_2(M)2(M-1) fracEbN_0","category":"page"},{"location":"Examples/example_BER/","page":"Compute the theoretical BER for AWGN channel and various constellation size","title":"Compute the theoretical BER for AWGN channel and various constellation size","text":"First of all let's call the modules","category":"page"},{"location":"Examples/example_BER/","page":"Compute the theoretical BER for AWGN channel and various constellation size","title":"Compute the theoretical BER for AWGN channel and various constellation size","text":"using DigitalComm \nusing PGFPlotsX","category":"page"},{"location":"Examples/example_BER/","page":"Compute the theoretical BER for AWGN channel and various constellation size","title":"Compute the theoretical BER for AWGN channel and various constellation size","text":"We define first the main monte-carlo function that compute an elementary Tx-Rx link, and returns the number of error and number of bit computed (to be accumulated)","category":"page"},{"location":"Examples/example_BER/","page":"Compute the theoretical BER for AWGN channel and various constellation size","title":"Compute the theoretical BER for AWGN channel and various constellation size","text":"function monteCarlo(snr,mcs,nbSymb) \n    # Number of bits  \n    nbBits    = nbSymb * Int(log2(mcs));\n    # --- Binary sequence generation \n    bitSeq    = genBitSequence(nbBits);\n    # --- QPSK mapping\n    qamSeq    = bitMappingQAM(mcs,bitSeq);\n    # ---------------------------------------------------- \n    # --- Channel  \n    # ---------------------------------------------------- \n    #  --- AWGN\n    # Theoretical power is 1 (normalized constellation)\n    qamNoise,  = addNoise(qamSeq,snr,1);\n    # ----------------------------------------------------\n    # --- Rx Stage: SRRC\n    # ----------------------------------------------------\n    # --- Binary demapper\n    bitDec  = bitDemappingQAM(mcs,qamNoise);\n    # --- Error counter \n    nbE     = sum(xor.(bitDec,bitSeq));\n    # --- Return Error and bits \n    return (nbE,nbBits);\nend","category":"page"},{"location":"Examples/example_BER/","page":"Compute the theoretical BER for AWGN channel and various constellation size","title":"Compute the theoretical BER for AWGN channel and various constellation size","text":"A function to plot the BER versus the SNR, for different mcs and compare to theory","category":"page"},{"location":"Examples/example_BER/","page":"Compute the theoretical BER for AWGN channel and various constellation size","title":"Compute the theoretical BER for AWGN channel and various constellation size","text":"function doPlot(snrVect,ber,qamVect)\n    a = 0;\n    @pgf a = Axis({\n        ymode     = \"log\",\n        height      =\"3in\",\n        width       =\"4in\",\n        grid,\n        xlabel      = \"SNR [dB]\",\n        ylabel      = \"Bit Error Rate \",\n        ymax       = 1,\n        ymin       = 10.0^(-5),\n        title       = \"AWGN BER for QAM\",\n        legend_style=\"{at={(0,0)},anchor=south west,legend cell align=left,align=left,draw=white!15!black}\"\n        },\n        Plot({color=\"red\",mark=\"square*\"},Table([snrVect,ber[1,:]])),\n        LegendEntry(\"QPSK\"),\n        Plot({color=\"green\",mark=\"*\"},Table([snrVect,ber[2,:]])),\n        LegendEntry(\"16-QAM\"),\n\n        Plot({color=\"purple\",mark=\"triangle*\"},Table([snrVect,ber[3,:]])),\n        LegendEntry(\"64-QAM\"),\n        Plot({color=\"blue\",mark=\"diamond*\"},Table([snrVect,ber[4,:]])),\n        LegendEntry(\"256-QAM\"),\n    );\n    # ---  Adding theoretical curve\n    snrLin  = (10.0).^(snrVect/10)\n    for qamScheme = qamVect\n        ebNo    = snrLin / log2(qamScheme);\n        # This approximation is only valid for high SNR (one symbol error is converted to one bit error with Gray coding).\n        berTheo   = 4 * ( 1 - 1 / sqrt(qamScheme)) / log2(qamScheme) * qFunc.(sqrt.( 2*ebNo * 3 * log2(qamScheme) / (2*(qamScheme-1)  )));\n        @pgf push!(a,Plot({color=\"black\"},Table([snrVect,berTheo])));\n    end\n    display(a);\nend","category":"page"},{"location":"Examples/example_BER/","page":"Compute the theoretical BER for AWGN channel and various constellation size","title":"Compute the theoretical BER for AWGN channel and various constellation size","text":"Then, the main routine to compute the BER for a given number of iterations and a range of SNR","category":"page"},{"location":"Examples/example_BER/","page":"Compute the theoretical BER for AWGN channel and various constellation size","title":"Compute the theoretical BER for AWGN channel and various constellation size","text":"function main() \n# --- Parameters \nnbIt            = 10000;          # Number of iterations  \nnbSymb          = 1024;           # Number of symbols per iterations \nmcs             = [4,16,64,256];  # Constellation size \nsnrRange        = (-1:26);        # SNR, expressed in dB \n# --- Init performance metrics\nnbSNR           = length(snrRange);\nber             = zeros(Float64,length(mcs),nbSNR);\nfor iMcs = 1 : 1  : length(mcs)\n    for iSNR = 1 : 1 : nbSNR\n        # --- Create BER counters \n        nbE   = 0;\n        nbB   = 0;\n        for iN = 1 : 1 : nbIt\n            # --- Elementary MC call \n            # Corresponds to a given SNR and a given iteration \n            # As we are ergodic in AWGN, it is only nbSymb*nbIt that matters for BER computation\n            (a,b) = monteCarlo(snrRange[iSNR],mcs[iMcs],nbSymb); \n            # --- Update counters \n            nbE += a;     # Increment errors \n            nbB += b;     # Increment bit counters \n        end \n        ber[iMcs,iSNR] = nbE / nbB; \n    end\nend \n# --- Plotting routine\ndoPlot(snrRange,ber,mcs);\nend","category":"page"},{"location":"Examples/example_BER/","page":"Compute the theoretical BER for AWGN channel and various constellation size","title":"Compute the theoretical BER for AWGN channel and various constellation size","text":"The output plot is the following, showing adequacy between theory and practise for high SNR (the theoretical curve is under the assumption that one symbol error leads to one erroneous bit (gray coding) which is true only with intermediate noise levels). (Image: BER)","category":"page"},{"location":"Examples/example_AWGN/#Transmission-of-xQAM-with-additive-white-Gaussian-noise","page":"Transmission of xQAM with additive white Gaussian noise","title":"Transmission of xQAM with additive white Gaussian noise","text":"","category":"section"},{"location":"Examples/example_AWGN/","page":"Transmission of xQAM with additive white Gaussian noise","title":"Transmission of xQAM with additive white Gaussian noise","text":"To simulate a transmission of QPSK // 16QAM // 64QAM // 256QAM other a white additive Gaussian noise and display the received constellation, the following code can be used","category":"page"},{"location":"Examples/example_AWGN/#Transmitter","page":"Transmission of xQAM with additive white Gaussian noise","title":"Transmitter","text":"","category":"section"},{"location":"Examples/example_AWGN/","page":"Transmission of xQAM with additive white Gaussian noise","title":"Transmission of xQAM with additive white Gaussian noise","text":"using ..DigitalComm # hide\nusing Plots \n# --- Parameters \nsnr       = 20;\nmcs       = 16;\nnbBits    = 1024* Int(log2(mcs));\n# --- Binary sequence generation \nbitSeq    = genBitSequence(nbBits);\n# --- QPSK mapping\nqamSeq    = bitMappingQAM(mcs,bitSeq); nothing","category":"page"},{"location":"Examples/example_AWGN/#Channel","page":"Transmission of xQAM with additive white Gaussian noise","title":"Channel","text":"","category":"section"},{"location":"Examples/example_AWGN/","page":"Transmission of xQAM with additive white Gaussian noise","title":"Transmission of xQAM with additive white Gaussian noise","text":"#  --- AWGN\n# Theoretical power is 1 (normalized constellation)\nqamNoise,  = addNoise(qamSeq,snr,1); nothing","category":"page"},{"location":"Examples/example_AWGN/#Receiver","page":"Transmission of xQAM with additive white Gaussian noise","title":"Receiver","text":"","category":"section"},{"location":"Examples/example_AWGN/","page":"Transmission of xQAM with additive white Gaussian noise","title":"Transmission of xQAM with additive white Gaussian noise","text":"# --- Binary demapper\nbitDec  = bitDemappingQAM(mcs,qamNoise);\n# --- BER measure\nber   = sum(xor.(bitDec,bitSeq)) /length(bitSeq);\n# --- Display constellation \nplt   = scatter(real(qamNoise),imag(qamNoise),label=\"Noisy\");\nscatter(plt,real(qamSeq),imag(qamSeq),label=\"Ideal\");\nxlabel!(\"Real part\");\nylabel!(\"Imag part\");\n\nsavefig(\"constellation.svg\"); nothing # hide","category":"page"},{"location":"Examples/example_AWGN/","page":"Transmission of xQAM with additive white Gaussian noise","title":"Transmission of xQAM with additive white Gaussian noise","text":"It plots the received constellation impaired by noise (here a 20dB SNR is used) (Image: Constellation)","category":"page"},{"location":"#DigitalComm.jl-documentation","page":"Introduction to DigitalComm","title":"DigitalComm.jl documentation","text":"","category":"section"},{"location":"#Summary","page":"Introduction to DigitalComm","title":"Summary","text":"","category":"section"},{"location":"","page":"Introduction to DigitalComm","title":"Introduction to DigitalComm","text":"This package aims to provide some usefull tools to manipulate digital communication blocks in Julia. Currently, the package support the following elements","category":"page"},{"location":"","page":"Introduction to DigitalComm","title":"Introduction to DigitalComm","text":"Bit manipulation\nGeneration of random binary sequence\nConversion between binary sequences and octal sequences\nModulation // demodulation\nQuadrature Amplitude Modulation (QAM) with 4-QAM (QPSK), 16-QAM, 64-QAM and 256-QAM.\nHard demapper for the x-QAM formats\nMax log Soft demapper for the x-QAM formats\nSingle carrier pulses shapes\nRaised Cosine pulse shape\nSquare root raised Cosine pulse shape\nMulticarrier Waveform generation and decoding\nSupport of multicarrier Waveforms: OFDM, UF-OFDM, WOLA, BF-OFDM","category":"page"},{"location":"#Installation","page":"Introduction to DigitalComm","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction to DigitalComm","title":"Introduction to DigitalComm","text":"The package can be installed with the Julia package manager. From the Julia REPL, type ] to enter the Pkg REPL mode and run:","category":"page"},{"location":"","page":"Introduction to DigitalComm","title":"Introduction to DigitalComm","text":"pkg> add DigitalComm","category":"page"},{"location":"","page":"Introduction to DigitalComm","title":"Introduction to DigitalComm","text":"Or, equivalently, via the Pkg API:","category":"page"},{"location":"","page":"Introduction to DigitalComm","title":"Introduction to DigitalComm","text":"julia> import Pkg; Pkg.add(\"DigitalComm\")","category":"page"},{"location":"#Documentation","page":"Introduction to DigitalComm","title":"Documentation","text":"","category":"section"},{"location":"","page":"Introduction to DigitalComm","title":"Introduction to DigitalComm","text":"The base documentation with the different functions can be found in the base section\nDifferent examples are described in in the example section. Other examples are provided in the example subfolder of the project. ","category":"page"}]
}
